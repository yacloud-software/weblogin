// Code generated by protoc-gen-go.
// source: protos/golang.conradwood.net/apis/weblogin/weblogin.proto
// DO NOT EDIT!

/*
Package weblogin is a generated protocol buffer package.

It is generated from these files:
	protos/golang.conradwood.net/apis/weblogin/weblogin.proto

It has these top-level messages:
	SignupEmail
	BasicAuthRequest
	AuthResponse
	WebloginRequest
	EmailPageResponse
	WebloginResponse
	State
	StateResponse
	RegisterState
	RegisterProto
	Email
	ActivityLog
	V3State
	AuthActivityRequest
*/
package weblogin

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import auth "golang.conradwood.net/apis/auth"
import h2gproxy "golang.conradwood.net/apis/h2gproxy"
import session "golang.yacloud.eu/apis/session"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AuthAction int32

const (
	AuthAction_UNDEFINED             AuthAction = 0
	AuthAction_LOGIN_RENDERED        AuthAction = 1
	AuthAction_CREDENTIALS_SUBMITTED AuthAction = 2
	AuthAction_SIGNUP_RENDERED       AuthAction = 3
	AuthAction_SIGNUP_SUBMITTED      AuthAction = 4
	AuthAction_SIGNUP_EMAILSENT      AuthAction = 5
	AuthAction_SIGNUP_EMAILCLICKED   AuthAction = 6
	AuthAction_FORGOT_PASSWORD_SENT  AuthAction = 7
	AuthAction_RESET_PASSWORD_SENT   AuthAction = 8
	AuthAction_LOGGED_OUT            AuthAction = 9
	AuthAction_SESSION_SET           AuthAction = 10
)

var AuthAction_name = map[int32]string{
	0:  "UNDEFINED",
	1:  "LOGIN_RENDERED",
	2:  "CREDENTIALS_SUBMITTED",
	3:  "SIGNUP_RENDERED",
	4:  "SIGNUP_SUBMITTED",
	5:  "SIGNUP_EMAILSENT",
	6:  "SIGNUP_EMAILCLICKED",
	7:  "FORGOT_PASSWORD_SENT",
	8:  "RESET_PASSWORD_SENT",
	9:  "LOGGED_OUT",
	10: "SESSION_SET",
}
var AuthAction_value = map[string]int32{
	"UNDEFINED":             0,
	"LOGIN_RENDERED":        1,
	"CREDENTIALS_SUBMITTED": 2,
	"SIGNUP_RENDERED":       3,
	"SIGNUP_SUBMITTED":      4,
	"SIGNUP_EMAILSENT":      5,
	"SIGNUP_EMAILCLICKED":   6,
	"FORGOT_PASSWORD_SENT":  7,
	"RESET_PASSWORD_SENT":   8,
	"LOGGED_OUT":            9,
	"SESSION_SET":           10,
}

func (x AuthAction) String() string {
	return proto.EnumName(AuthAction_name, int32(x))
}
func (AuthAction) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type SignupEmail struct {
	Host  string `protobuf:"bytes,1,opt,name=Host" json:"Host,omitempty"`
	Email string `protobuf:"bytes,2,opt,name=Email" json:"Email,omitempty"`
}

func (m *SignupEmail) Reset()                    { *m = SignupEmail{} }
func (m *SignupEmail) String() string            { return proto.CompactTextString(m) }
func (*SignupEmail) ProtoMessage()               {}
func (*SignupEmail) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SignupEmail) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SignupEmail) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

type BasicAuthRequest struct {
	// the stuff extracted from "Authorization" Header
	Username string `protobuf:"bytes,1,opt,name=Username" json:"Username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=Password" json:"Password,omitempty"`
}

func (m *BasicAuthRequest) Reset()                    { *m = BasicAuthRequest{} }
func (m *BasicAuthRequest) String() string            { return proto.CompactTextString(m) }
func (*BasicAuthRequest) ProtoMessage()               {}
func (*BasicAuthRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *BasicAuthRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *BasicAuthRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type AuthResponse struct {
	IsValid  bool       `protobuf:"varint,1,opt,name=IsValid" json:"IsValid,omitempty"`
	Response *auth.User `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *AuthResponse) Reset()                    { *m = AuthResponse{} }
func (m *AuthResponse) String() string            { return proto.CompactTextString(m) }
func (*AuthResponse) ProtoMessage()               {}
func (*AuthResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AuthResponse) GetIsValid() bool {
	if m != nil {
		return m.IsValid
	}
	return false
}

func (m *AuthResponse) GetResponse() *auth.User {
	if m != nil {
		return m.Response
	}
	return nil
}

type WebloginRequest struct {
	Method    string             `protobuf:"bytes,1,opt,name=Method" json:"Method,omitempty"`
	Scheme    string             `protobuf:"bytes,2,opt,name=Scheme" json:"Scheme,omitempty"`
	Host      string             `protobuf:"bytes,3,opt,name=Host" json:"Host,omitempty"`
	Path      string             `protobuf:"bytes,4,opt,name=Path" json:"Path,omitempty"`
	Query     string             `protobuf:"bytes,5,opt,name=Query" json:"Query,omitempty"`
	Body      string             `protobuf:"bytes,6,opt,name=Body" json:"Body,omitempty"`
	Submitted map[string]string  `protobuf:"bytes,7,rep,name=Submitted" json:"Submitted,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Peer      string             `protobuf:"bytes,8,opt,name=Peer" json:"Peer,omitempty"`
	Cookies   []*h2gproxy.Cookie `protobuf:"bytes,9,rep,name=Cookies" json:"Cookies,omitempty"`
	UserAgent string             `protobuf:"bytes,10,opt,name=UserAgent" json:"UserAgent,omitempty"`
}

func (m *WebloginRequest) Reset()                    { *m = WebloginRequest{} }
func (m *WebloginRequest) String() string            { return proto.CompactTextString(m) }
func (*WebloginRequest) ProtoMessage()               {}
func (*WebloginRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *WebloginRequest) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *WebloginRequest) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *WebloginRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *WebloginRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *WebloginRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *WebloginRequest) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *WebloginRequest) GetSubmitted() map[string]string {
	if m != nil {
		return m.Submitted
	}
	return nil
}

func (m *WebloginRequest) GetPeer() string {
	if m != nil {
		return m.Peer
	}
	return ""
}

func (m *WebloginRequest) GetCookies() []*h2gproxy.Cookie {
	if m != nil {
		return m.Cookies
	}
	return nil
}

func (m *WebloginRequest) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

type EmailPageResponse struct {
	HTML     string            `protobuf:"bytes,1,opt,name=HTML" json:"HTML,omitempty"`
	Verified bool              `protobuf:"varint,2,opt,name=Verified" json:"Verified,omitempty"`
	User     *auth.User        `protobuf:"bytes,3,opt,name=User" json:"User,omitempty"`
	Headers  map[string]string `protobuf:"bytes,4,rep,name=Headers" json:"Headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *EmailPageResponse) Reset()                    { *m = EmailPageResponse{} }
func (m *EmailPageResponse) String() string            { return proto.CompactTextString(m) }
func (*EmailPageResponse) ProtoMessage()               {}
func (*EmailPageResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *EmailPageResponse) GetHTML() string {
	if m != nil {
		return m.HTML
	}
	return ""
}

func (m *EmailPageResponse) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

func (m *EmailPageResponse) GetUser() *auth.User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *EmailPageResponse) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

type WebloginResponse struct {
	Body                  []byte             `protobuf:"bytes,1,opt,name=Body,proto3" json:"Body,omitempty"`
	Authenticated         bool               `protobuf:"varint,2,opt,name=Authenticated" json:"Authenticated,omitempty"`
	User                  *auth.User         `protobuf:"bytes,3,opt,name=User" json:"User,omitempty"`
	Token                 string             `protobuf:"bytes,4,opt,name=Token" json:"Token,omitempty"`
	CookieLivetime        uint32             `protobuf:"varint,5,opt,name=CookieLivetime" json:"CookieLivetime,omitempty"`
	RedirectTo            string             `protobuf:"bytes,6,opt,name=RedirectTo" json:"RedirectTo,omitempty"`
	Cookies               []*h2gproxy.Cookie `protobuf:"bytes,7,rep,name=Cookies" json:"Cookies,omitempty"`
	Headers               map[string]string  `protobuf:"bytes,8,rep,name=Headers" json:"Headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ForceGetAfterRedirect bool               `protobuf:"varint,9,opt,name=ForceGetAfterRedirect" json:"ForceGetAfterRedirect,omitempty"`
	PeerIsDosing          bool               `protobuf:"varint,10,opt,name=PeerIsDosing" json:"PeerIsDosing,omitempty"`
	PeerIP                string             `protobuf:"bytes,11,opt,name=PeerIP" json:"PeerIP,omitempty"`
	HTTPCode              uint32             `protobuf:"varint,12,opt,name=HTTPCode" json:"HTTPCode,omitempty"`
	MimeType              string             `protobuf:"bytes,13,opt,name=MimeType" json:"MimeType,omitempty"`
	Session               *session.Session   `protobuf:"bytes,14,opt,name=Session" json:"Session,omitempty"`
}

func (m *WebloginResponse) Reset()                    { *m = WebloginResponse{} }
func (m *WebloginResponse) String() string            { return proto.CompactTextString(m) }
func (*WebloginResponse) ProtoMessage()               {}
func (*WebloginResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *WebloginResponse) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *WebloginResponse) GetAuthenticated() bool {
	if m != nil {
		return m.Authenticated
	}
	return false
}

func (m *WebloginResponse) GetUser() *auth.User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *WebloginResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *WebloginResponse) GetCookieLivetime() uint32 {
	if m != nil {
		return m.CookieLivetime
	}
	return 0
}

func (m *WebloginResponse) GetRedirectTo() string {
	if m != nil {
		return m.RedirectTo
	}
	return ""
}

func (m *WebloginResponse) GetCookies() []*h2gproxy.Cookie {
	if m != nil {
		return m.Cookies
	}
	return nil
}

func (m *WebloginResponse) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *WebloginResponse) GetForceGetAfterRedirect() bool {
	if m != nil {
		return m.ForceGetAfterRedirect
	}
	return false
}

func (m *WebloginResponse) GetPeerIsDosing() bool {
	if m != nil {
		return m.PeerIsDosing
	}
	return false
}

func (m *WebloginResponse) GetPeerIP() string {
	if m != nil {
		return m.PeerIP
	}
	return ""
}

func (m *WebloginResponse) GetHTTPCode() uint32 {
	if m != nil {
		return m.HTTPCode
	}
	return 0
}

func (m *WebloginResponse) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *WebloginResponse) GetSession() *session.Session {
	if m != nil {
		return m.Session
	}
	return nil
}

// this protobuf is never exposed to the user. it is held server-side and referred to by a shortlived magic
type State struct {
	TriggerHost  string `protobuf:"bytes,1,opt,name=TriggerHost" json:"TriggerHost,omitempty"`
	TriggerPath  string `protobuf:"bytes,2,opt,name=TriggerPath" json:"TriggerPath,omitempty"`
	TriggerQuery string `protobuf:"bytes,3,opt,name=TriggerQuery" json:"TriggerQuery,omitempty"`
	Token        string `protobuf:"bytes,4,opt,name=Token" json:"Token,omitempty"`
	Method       string `protobuf:"bytes,5,opt,name=Method" json:"Method,omitempty"`
	TokenSource  uint32 `protobuf:"varint,6,opt,name=TokenSource" json:"TokenSource,omitempty"`
}

func (m *State) Reset()                    { *m = State{} }
func (m *State) String() string            { return proto.CompactTextString(m) }
func (*State) ProtoMessage()               {}
func (*State) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *State) GetTriggerHost() string {
	if m != nil {
		return m.TriggerHost
	}
	return ""
}

func (m *State) GetTriggerPath() string {
	if m != nil {
		return m.TriggerPath
	}
	return ""
}

func (m *State) GetTriggerQuery() string {
	if m != nil {
		return m.TriggerQuery
	}
	return ""
}

func (m *State) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *State) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *State) GetTokenSource() uint32 {
	if m != nil {
		return m.TokenSource
	}
	return 0
}

type StateResponse struct {
	YacloudWebloginState string `protobuf:"bytes,1,opt,name=YacloudWebloginState" json:"YacloudWebloginState,omitempty"`
	URLStateName         string `protobuf:"bytes,2,opt,name=URLStateName" json:"URLStateName,omitempty"`
}

func (m *StateResponse) Reset()                    { *m = StateResponse{} }
func (m *StateResponse) String() string            { return proto.CompactTextString(m) }
func (*StateResponse) ProtoMessage()               {}
func (*StateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *StateResponse) GetYacloudWebloginState() string {
	if m != nil {
		return m.YacloudWebloginState
	}
	return ""
}

func (m *StateResponse) GetURLStateName() string {
	if m != nil {
		return m.URLStateName
	}
	return ""
}

type RegisterState struct {
	Host    string `protobuf:"bytes,1,opt,name=Host" json:"Host,omitempty"`
	Email   string `protobuf:"bytes,2,opt,name=Email" json:"Email,omitempty"`
	Created uint32 `protobuf:"varint,3,opt,name=Created" json:"Created,omitempty"`
	Magic   string `protobuf:"bytes,4,opt,name=Magic" json:"Magic,omitempty"`
}

func (m *RegisterState) Reset()                    { *m = RegisterState{} }
func (m *RegisterState) String() string            { return proto.CompactTextString(m) }
func (*RegisterState) ProtoMessage()               {}
func (*RegisterState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *RegisterState) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *RegisterState) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *RegisterState) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *RegisterState) GetMagic() string {
	if m != nil {
		return m.Magic
	}
	return ""
}

type RegisterProto struct {
	State     string `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	Signature []byte `protobuf:"bytes,2,opt,name=Signature,proto3" json:"Signature,omitempty"`
}

func (m *RegisterProto) Reset()                    { *m = RegisterProto{} }
func (m *RegisterProto) String() string            { return proto.CompactTextString(m) }
func (*RegisterProto) ProtoMessage()               {}
func (*RegisterProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *RegisterProto) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *RegisterProto) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type Email struct {
	Subject string `protobuf:"bytes,1,opt,name=Subject" json:"Subject,omitempty"`
	Body    string `protobuf:"bytes,2,opt,name=Body" json:"Body,omitempty"`
	Link    string `protobuf:"bytes,3,opt,name=Link" json:"Link,omitempty"`
}

func (m *Email) Reset()                    { *m = Email{} }
func (m *Email) String() string            { return proto.CompactTextString(m) }
func (*Email) ProtoMessage()               {}
func (*Email) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Email) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Email) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *Email) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

type ActivityLog struct {
	ID          uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	IP          string `protobuf:"bytes,2,opt,name=IP" json:"IP,omitempty"`
	UserID      string `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	Email       string `protobuf:"bytes,4,opt,name=Email" json:"Email,omitempty"`
	TriggerHost string `protobuf:"bytes,5,opt,name=TriggerHost" json:"TriggerHost,omitempty"`
	Occured     uint32 `protobuf:"varint,6,opt,name=Occured" json:"Occured,omitempty"`
	LogMessage  string `protobuf:"bytes,7,opt,name=LogMessage" json:"LogMessage,omitempty"`
}

func (m *ActivityLog) Reset()                    { *m = ActivityLog{} }
func (m *ActivityLog) String() string            { return proto.CompactTextString(m) }
func (*ActivityLog) ProtoMessage()               {}
func (*ActivityLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ActivityLog) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ActivityLog) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *ActivityLog) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *ActivityLog) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *ActivityLog) GetTriggerHost() string {
	if m != nil {
		return m.TriggerHost
	}
	return ""
}

func (m *ActivityLog) GetOccured() uint32 {
	if m != nil {
		return m.Occured
	}
	return 0
}

func (m *ActivityLog) GetLogMessage() string {
	if m != nil {
		return m.LogMessage
	}
	return ""
}

// this is the state of a process from beginning to end.
type V3State struct {
	TriggerHost           string `protobuf:"bytes,1,opt,name=TriggerHost" json:"TriggerHost,omitempty"`
	TriggerPath           string `protobuf:"bytes,2,opt,name=TriggerPath" json:"TriggerPath,omitempty"`
	TriggerQuery          string `protobuf:"bytes,3,opt,name=TriggerQuery" json:"TriggerQuery,omitempty"`
	HaveTriedGlobalCookie bool   `protobuf:"varint,4,opt,name=HaveTriedGlobalCookie" json:"HaveTriedGlobalCookie,omitempty"`
	RequestID             uint64 `protobuf:"varint,5,opt,name=RequestID" json:"RequestID,omitempty"`
}

func (m *V3State) Reset()                    { *m = V3State{} }
func (m *V3State) String() string            { return proto.CompactTextString(m) }
func (*V3State) ProtoMessage()               {}
func (*V3State) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *V3State) GetTriggerHost() string {
	if m != nil {
		return m.TriggerHost
	}
	return ""
}

func (m *V3State) GetTriggerPath() string {
	if m != nil {
		return m.TriggerPath
	}
	return ""
}

func (m *V3State) GetTriggerQuery() string {
	if m != nil {
		return m.TriggerQuery
	}
	return ""
}

func (m *V3State) GetHaveTriedGlobalCookie() bool {
	if m != nil {
		return m.HaveTriedGlobalCookie
	}
	return false
}

func (m *V3State) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

type AuthActivityRequest struct {
	ID               uint64     `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Timestamp        uint32     `protobuf:"varint,2,opt,name=Timestamp" json:"Timestamp,omitempty"`
	IP               string     `protobuf:"bytes,3,opt,name=IP" json:"IP,omitempty"`
	PreviousUserID   string     `protobuf:"bytes,4,opt,name=PreviousUserID" json:"PreviousUserID,omitempty"`
	UserID           string     `protobuf:"bytes,5,opt,name=UserID" json:"UserID,omitempty"`
	Email            string     `protobuf:"bytes,6,opt,name=Email" json:"Email,omitempty"`
	Action           AuthAction `protobuf:"varint,7,opt,name=Action,enum=weblogin.AuthAction" json:"Action,omitempty"`
	URL              string     `protobuf:"bytes,8,opt,name=URL" json:"URL,omitempty"`
	UserErrorMessage string     `protobuf:"bytes,9,opt,name=UserErrorMessage" json:"UserErrorMessage,omitempty"`
	LogErrorMessage  string     `protobuf:"bytes,10,opt,name=LogErrorMessage" json:"LogErrorMessage,omitempty"`
	RequestID        string     `protobuf:"bytes,11,opt,name=RequestID" json:"RequestID,omitempty"`
	SessionID        string     `protobuf:"bytes,12,opt,name=SessionID" json:"SessionID,omitempty"`
}

func (m *AuthActivityRequest) Reset()                    { *m = AuthActivityRequest{} }
func (m *AuthActivityRequest) String() string            { return proto.CompactTextString(m) }
func (*AuthActivityRequest) ProtoMessage()               {}
func (*AuthActivityRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *AuthActivityRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *AuthActivityRequest) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *AuthActivityRequest) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *AuthActivityRequest) GetPreviousUserID() string {
	if m != nil {
		return m.PreviousUserID
	}
	return ""
}

func (m *AuthActivityRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *AuthActivityRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *AuthActivityRequest) GetAction() AuthAction {
	if m != nil {
		return m.Action
	}
	return AuthAction_UNDEFINED
}

func (m *AuthActivityRequest) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *AuthActivityRequest) GetUserErrorMessage() string {
	if m != nil {
		return m.UserErrorMessage
	}
	return ""
}

func (m *AuthActivityRequest) GetLogErrorMessage() string {
	if m != nil {
		return m.LogErrorMessage
	}
	return ""
}

func (m *AuthActivityRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *AuthActivityRequest) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

func init() {
	proto.RegisterType((*SignupEmail)(nil), "weblogin.SignupEmail")
	proto.RegisterType((*BasicAuthRequest)(nil), "weblogin.BasicAuthRequest")
	proto.RegisterType((*AuthResponse)(nil), "weblogin.AuthResponse")
	proto.RegisterType((*WebloginRequest)(nil), "weblogin.WebloginRequest")
	proto.RegisterType((*EmailPageResponse)(nil), "weblogin.EmailPageResponse")
	proto.RegisterType((*WebloginResponse)(nil), "weblogin.WebloginResponse")
	proto.RegisterType((*State)(nil), "weblogin.State")
	proto.RegisterType((*StateResponse)(nil), "weblogin.StateResponse")
	proto.RegisterType((*RegisterState)(nil), "weblogin.RegisterState")
	proto.RegisterType((*RegisterProto)(nil), "weblogin.RegisterProto")
	proto.RegisterType((*Email)(nil), "weblogin.Email")
	proto.RegisterType((*ActivityLog)(nil), "weblogin.ActivityLog")
	proto.RegisterType((*V3State)(nil), "weblogin.V3State")
	proto.RegisterType((*AuthActivityRequest)(nil), "weblogin.AuthActivityRequest")
	proto.RegisterEnum("weblogin.AuthAction", AuthAction_name, AuthAction_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Weblogin service

type WebloginClient interface {
	CreateRegisterEmail(ctx context.Context, in *RegisterState, opts ...grpc.CallOption) (*Email, error)
	// sometimes we need basic auth if so, we get a request to same URL with a an
	// Authorization Header
	// if so, the h2gproxy needs to verify the header
	IsBasicAuthValid(ctx context.Context, in *BasicAuthRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	// serve the login page
	GetLoginPage(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*WebloginResponse, error)
	// generic html serve thing for h2gproxy
	ServeHTML(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*WebloginResponse, error)
	// called if a user is authenticated but the users' email address is not yet verified
	// returns true if email is now verified
	GetVerifyEmail(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*EmailPageResponse, error)
	// helper for h2gproxy. verify a "weblogin=foobar" url. Body is ignored in the response.
	// cookie is helpful though
	VerifyURL(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*WebloginResponse, error)
	// helper for h2gproxy. create a state (before redirecting browser to weblogin)
	SaveState(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*StateResponse, error)
	// send/re-send a sign-up email
	SignupEmailRPC(ctx context.Context, in *SignupEmail, opts ...grpc.CallOption) (*common.Void, error)
}

type webloginClient struct {
	cc *grpc.ClientConn
}

func NewWebloginClient(cc *grpc.ClientConn) WebloginClient {
	return &webloginClient{cc}
}

func (c *webloginClient) CreateRegisterEmail(ctx context.Context, in *RegisterState, opts ...grpc.CallOption) (*Email, error) {
	out := new(Email)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/CreateRegisterEmail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webloginClient) IsBasicAuthValid(ctx context.Context, in *BasicAuthRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/IsBasicAuthValid", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webloginClient) GetLoginPage(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*WebloginResponse, error) {
	out := new(WebloginResponse)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/GetLoginPage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webloginClient) ServeHTML(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*WebloginResponse, error) {
	out := new(WebloginResponse)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/ServeHTML", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webloginClient) GetVerifyEmail(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*EmailPageResponse, error) {
	out := new(EmailPageResponse)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/GetVerifyEmail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webloginClient) VerifyURL(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*WebloginResponse, error) {
	out := new(WebloginResponse)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/VerifyURL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webloginClient) SaveState(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*StateResponse, error) {
	out := new(StateResponse)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/SaveState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webloginClient) SignupEmailRPC(ctx context.Context, in *SignupEmail, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/SignupEmailRPC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Weblogin service

type WebloginServer interface {
	CreateRegisterEmail(context.Context, *RegisterState) (*Email, error)
	// sometimes we need basic auth if so, we get a request to same URL with a an
	// Authorization Header
	// if so, the h2gproxy needs to verify the header
	IsBasicAuthValid(context.Context, *BasicAuthRequest) (*AuthResponse, error)
	// serve the login page
	GetLoginPage(context.Context, *WebloginRequest) (*WebloginResponse, error)
	// generic html serve thing for h2gproxy
	ServeHTML(context.Context, *WebloginRequest) (*WebloginResponse, error)
	// called if a user is authenticated but the users' email address is not yet verified
	// returns true if email is now verified
	GetVerifyEmail(context.Context, *WebloginRequest) (*EmailPageResponse, error)
	// helper for h2gproxy. verify a "weblogin=foobar" url. Body is ignored in the response.
	// cookie is helpful though
	VerifyURL(context.Context, *WebloginRequest) (*WebloginResponse, error)
	// helper for h2gproxy. create a state (before redirecting browser to weblogin)
	SaveState(context.Context, *WebloginRequest) (*StateResponse, error)
	// send/re-send a sign-up email
	SignupEmailRPC(context.Context, *SignupEmail) (*common.Void, error)
}

func RegisterWebloginServer(s *grpc.Server, srv WebloginServer) {
	s.RegisterService(&_Weblogin_serviceDesc, srv)
}

func _Weblogin_CreateRegisterEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).CreateRegisterEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/CreateRegisterEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).CreateRegisterEmail(ctx, req.(*RegisterState))
	}
	return interceptor(ctx, in, info, handler)
}

func _Weblogin_IsBasicAuthValid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BasicAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).IsBasicAuthValid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/IsBasicAuthValid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).IsBasicAuthValid(ctx, req.(*BasicAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Weblogin_GetLoginPage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebloginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).GetLoginPage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/GetLoginPage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).GetLoginPage(ctx, req.(*WebloginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Weblogin_ServeHTML_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebloginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).ServeHTML(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/ServeHTML",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).ServeHTML(ctx, req.(*WebloginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Weblogin_GetVerifyEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebloginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).GetVerifyEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/GetVerifyEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).GetVerifyEmail(ctx, req.(*WebloginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Weblogin_VerifyURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebloginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).VerifyURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/VerifyURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).VerifyURL(ctx, req.(*WebloginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Weblogin_SaveState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebloginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).SaveState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/SaveState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).SaveState(ctx, req.(*WebloginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Weblogin_SignupEmailRPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignupEmail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).SignupEmailRPC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/SignupEmailRPC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).SignupEmailRPC(ctx, req.(*SignupEmail))
	}
	return interceptor(ctx, in, info, handler)
}

var _Weblogin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "weblogin.Weblogin",
	HandlerType: (*WebloginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRegisterEmail",
			Handler:    _Weblogin_CreateRegisterEmail_Handler,
		},
		{
			MethodName: "IsBasicAuthValid",
			Handler:    _Weblogin_IsBasicAuthValid_Handler,
		},
		{
			MethodName: "GetLoginPage",
			Handler:    _Weblogin_GetLoginPage_Handler,
		},
		{
			MethodName: "ServeHTML",
			Handler:    _Weblogin_ServeHTML_Handler,
		},
		{
			MethodName: "GetVerifyEmail",
			Handler:    _Weblogin_GetVerifyEmail_Handler,
		},
		{
			MethodName: "VerifyURL",
			Handler:    _Weblogin_VerifyURL_Handler,
		},
		{
			MethodName: "SaveState",
			Handler:    _Weblogin_SaveState_Handler,
		},
		{
			MethodName: "SignupEmailRPC",
			Handler:    _Weblogin_SignupEmailRPC_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/golang.conradwood.net/apis/weblogin/weblogin.proto",
}

// Client API for TrackerService service

type TrackerServiceClient interface {
	LogActivity(ctx context.Context, in *AuthActivityRequest, opts ...grpc.CallOption) (*common.Void, error)
}

type trackerServiceClient struct {
	cc *grpc.ClientConn
}

func NewTrackerServiceClient(cc *grpc.ClientConn) TrackerServiceClient {
	return &trackerServiceClient{cc}
}

func (c *trackerServiceClient) LogActivity(ctx context.Context, in *AuthActivityRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/weblogin.TrackerService/LogActivity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TrackerService service

type TrackerServiceServer interface {
	LogActivity(context.Context, *AuthActivityRequest) (*common.Void, error)
}

func RegisterTrackerServiceServer(s *grpc.Server, srv TrackerServiceServer) {
	s.RegisterService(&_TrackerService_serviceDesc, srv)
}

func _TrackerService_LogActivity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthActivityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrackerServiceServer).LogActivity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.TrackerService/LogActivity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrackerServiceServer).LogActivity(ctx, req.(*AuthActivityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TrackerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "weblogin.TrackerService",
	HandlerType: (*TrackerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LogActivity",
			Handler:    _TrackerService_LogActivity_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/golang.conradwood.net/apis/weblogin/weblogin.proto",
}

func init() {
	proto.RegisterFile("protos/golang.conradwood.net/apis/weblogin/weblogin.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1539 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x57, 0x49, 0x6f, 0x1b, 0x47,
	0x16, 0x1e, 0x52, 0xa4, 0x48, 0x3e, 0x2e, 0xe2, 0x94, 0x24, 0xbb, 0xcd, 0xf1, 0x18, 0x06, 0x3d,
	0xf0, 0x08, 0xc2, 0x80, 0x06, 0x68, 0x0f, 0xc6, 0x63, 0x04, 0x30, 0x28, 0xb2, 0x45, 0xb5, 0xd3,
	0x5c, 0xd2, 0xdd, 0x92, 0x91, 0x5c, 0x84, 0x56, 0xb3, 0xdc, 0xaa, 0x88, 0xec, 0x52, 0x7a, 0x91,
	0xc3, 0x6b, 0x2e, 0xf9, 0x0f, 0x39, 0xe7, 0x3f, 0xe4, 0x98, 0x53, 0x4e, 0xf9, 0x19, 0xf9, 0x11,
	0xc9, 0x31, 0xa8, 0xa5, 0x17, 0x52, 0xb2, 0xec, 0x38, 0x40, 0x2e, 0x64, 0xbd, 0xa5, 0x5e, 0xbd,
	0x7a, 0xdf, 0xeb, 0xaf, 0xaa, 0xe0, 0xff, 0x97, 0x3e, 0x0d, 0x69, 0xf0, 0xc4, 0xa5, 0x73, 0xdb,
	0x73, 0x3b, 0x0e, 0xf5, 0x7c, 0x7b, 0xf6, 0x96, 0xd2, 0x59, 0xc7, 0xc3, 0xe1, 0x13, 0xfb, 0x92,
	0x04, 0x4f, 0xde, 0xe2, 0xb3, 0x39, 0x75, 0x89, 0x97, 0x0c, 0x3a, 0x7c, 0x0e, 0x2a, 0xc7, 0x72,
	0x6b, 0xff, 0x96, 0xd9, 0x76, 0x14, 0x9e, 0xf3, 0x1f, 0x31, 0xab, 0xd5, 0xbd, 0xc5, 0xf7, 0xbc,
	0xeb, 0x5e, 0xfa, 0xf4, 0xeb, 0x65, 0x32, 0x90, 0x73, 0xfe, 0x23, 0xe7, 0x2c, 0x6d, 0x67, 0x4e,
	0xa3, 0x59, 0x07, 0x47, 0xc2, 0x3f, 0xc0, 0x41, 0x40, 0xa8, 0x17, 0xff, 0x4b, 0xef, 0xce, 0x2d,
	0x2b, 0x38, 0x74, 0xb1, 0xa0, 0x9e, 0xfc, 0x13, 0xfe, 0xed, 0xff, 0x41, 0xd5, 0x24, 0xae, 0x17,
	0x5d, 0xaa, 0x0b, 0x9b, 0xcc, 0x11, 0x82, 0xc2, 0x11, 0x0d, 0x42, 0x25, 0xf7, 0x30, 0xb7, 0x57,
	0x31, 0xf8, 0x18, 0xed, 0x40, 0x91, 0x1b, 0x95, 0x3c, 0x57, 0x0a, 0xa1, 0xfd, 0x0a, 0x9a, 0x07,
	0x76, 0x40, 0x9c, 0x5e, 0x14, 0x9e, 0x1b, 0xf8, 0xab, 0x08, 0x07, 0x21, 0x6a, 0x41, 0xf9, 0x38,
	0xc0, 0xbe, 0x67, 0x2f, 0xb0, 0x8c, 0x90, 0xc8, 0xcc, 0x36, 0xb5, 0x83, 0xe0, 0x2d, 0xf5, 0x67,
	0x32, 0x50, 0x22, 0xb7, 0xa7, 0x50, 0x13, 0x61, 0x82, 0x4b, 0xea, 0x05, 0x18, 0x29, 0x50, 0xd2,
	0x82, 0x13, 0x7b, 0x4e, 0x66, 0x3c, 0x4c, 0xd9, 0x88, 0x45, 0xf4, 0x18, 0xca, 0xb1, 0x17, 0x8f,
	0x52, 0xed, 0x42, 0x87, 0xd7, 0x97, 0xad, 0x63, 0x24, 0xb6, 0xf6, 0xaf, 0x79, 0xd8, 0x7a, 0x2d,
	0x11, 0x8a, 0xb3, 0xbb, 0x03, 0x9b, 0x23, 0x1c, 0x9e, 0xd3, 0x99, 0xcc, 0x4d, 0x4a, 0x4c, 0x6f,
	0x3a, 0xe7, 0x78, 0x81, 0x65, 0x5e, 0x52, 0x4a, 0x6a, 0xb1, 0x91, 0xa9, 0x05, 0x82, 0xc2, 0xd4,
	0x0e, 0xcf, 0x95, 0x82, 0xd0, 0xb1, 0x31, 0xab, 0xcf, 0x67, 0x11, 0xf6, 0x97, 0x4a, 0x51, 0xd4,
	0x87, 0x0b, 0xcc, 0xf3, 0x80, 0xce, 0x96, 0xca, 0xa6, 0xf0, 0x64, 0x63, 0x74, 0x08, 0x15, 0x33,
	0x3a, 0x5b, 0x90, 0x30, 0xc4, 0x33, 0xa5, 0xf4, 0x70, 0x63, 0xaf, 0xda, 0xdd, 0xeb, 0x24, 0x8d,
	0xb5, 0x96, 0x6f, 0x27, 0x71, 0x55, 0xbd, 0xd0, 0x5f, 0x1a, 0xe9, 0x54, 0x9e, 0x05, 0xc6, 0xbe,
	0x52, 0x96, 0x59, 0x60, 0xec, 0xa3, 0x7d, 0x28, 0xf5, 0x29, 0xbd, 0x20, 0x38, 0x50, 0x2a, 0x3c,
	0x72, 0xb3, 0x93, 0x34, 0x92, 0x30, 0x18, 0xb1, 0x03, 0xba, 0x0f, 0x15, 0x56, 0xaf, 0x9e, 0x8b,
	0xbd, 0x50, 0x01, 0x1e, 0x24, 0x55, 0xb4, 0x3e, 0x81, 0xc6, 0xea, 0xd2, 0xa8, 0x09, 0x1b, 0x17,
	0x78, 0x29, 0xcb, 0xc6, 0x86, 0x6c, 0xcf, 0x57, 0xf6, 0x3c, 0x8a, 0x4b, 0x26, 0x84, 0x17, 0xf9,
	0xe7, 0xb9, 0xf6, 0x2f, 0x39, 0xf8, 0x3b, 0xef, 0x90, 0xa9, 0xed, 0xe2, 0x04, 0x51, 0x56, 0x4b,
	0x6b, 0xa4, 0x27, 0x7d, 0x65, 0x8d, 0x74, 0xd6, 0x11, 0x27, 0xd8, 0x27, 0x6f, 0x08, 0x16, 0x1d,
	0x51, 0x36, 0x12, 0x19, 0x3d, 0x80, 0x02, 0x4b, 0x88, 0xd7, 0x7e, 0x15, 0x63, 0xae, 0x47, 0x07,
	0x50, 0x3a, 0xc2, 0xf6, 0x0c, 0xfb, 0x81, 0x52, 0x58, 0xaf, 0xe3, 0xb5, 0xd5, 0x3b, 0xd2, 0x55,
	0xd4, 0x31, 0x9e, 0xd8, 0x7a, 0x01, 0xb5, 0xac, 0xe1, 0x0f, 0xed, 0xf2, 0xe7, 0x02, 0x34, 0x53,
	0xbc, 0xd2, 0x4d, 0x72, 0xc8, 0x59, 0x84, 0x9a, 0x84, 0xfc, 0x5f, 0x50, 0x67, 0xad, 0x8d, 0xbd,
	0x90, 0x38, 0x76, 0x98, 0xec, 0x74, 0x55, 0xf9, 0xde, 0xed, 0xee, 0x40, 0xd1, 0xa2, 0x17, 0xd8,
	0x93, 0x7d, 0x27, 0x04, 0xf4, 0x18, 0x1a, 0x02, 0x51, 0x9d, 0x5c, 0xe1, 0x90, 0x2c, 0x30, 0xef,
	0xc0, 0xba, 0xb1, 0xa6, 0x45, 0x0f, 0x00, 0x0c, 0x3c, 0x23, 0x3e, 0x76, 0x42, 0x8b, 0xca, 0x86,
	0xcc, 0x68, 0xb2, 0xad, 0x53, 0x7a, 0x5f, 0xeb, 0xf4, 0xd2, 0xc2, 0x97, 0xb9, 0xef, 0xbf, 0x6f,
	0x6a, 0xe0, 0xdb, 0xea, 0x8e, 0x9e, 0xc1, 0xee, 0x21, 0xf5, 0x1d, 0x3c, 0xc4, 0x61, 0xef, 0x4d,
	0x88, 0xfd, 0x38, 0x13, 0xa5, 0xc2, 0x4b, 0x73, 0xb3, 0x11, 0xb5, 0xa1, 0xc6, 0xfa, 0x5c, 0x0b,
	0x06, 0x34, 0x20, 0x9e, 0xcb, 0xdb, 0xb6, 0x6c, 0xac, 0xe8, 0xd8, 0x97, 0xcc, 0xe5, 0xa9, 0x52,
	0x15, 0x5f, 0xb2, 0x90, 0x58, 0xa7, 0x1d, 0x59, 0xd6, 0xb4, 0x4f, 0x67, 0x58, 0xa9, 0xf1, 0x12,
	0x25, 0x32, 0xb3, 0x8d, 0xc8, 0x02, 0x5b, 0xcb, 0x4b, 0xac, 0xd4, 0x05, 0x2f, 0xc5, 0x32, 0x2b,
	0x8c, 0x29, 0xd8, 0x55, 0x69, 0x70, 0x64, 0x9a, 0x9d, 0x98, 0x6d, 0xa5, 0xde, 0x88, 0x1d, 0xfe,
	0x54, 0x37, 0xfd, 0x98, 0x83, 0xa2, 0x19, 0xda, 0x21, 0x46, 0x0f, 0xa1, 0x6a, 0xf9, 0xc4, 0x75,
	0xb1, 0x9f, 0xa1, 0xe1, 0xac, 0x2a, 0xe3, 0xc1, 0x89, 0x28, 0xbf, 0xe2, 0xc1, 0xf9, 0xa8, 0x0d,
	0x35, 0x29, 0x0a, 0x5a, 0x12, 0xfc, 0xb5, 0xa2, 0x7b, 0x47, 0x43, 0xa5, 0x0c, 0x59, 0x5c, 0x61,
	0x48, 0xb6, 0x26, 0x73, 0x30, 0x69, 0xe4, 0x3b, 0x98, 0x77, 0x50, 0xdd, 0xc8, 0xaa, 0xda, 0x2e,
	0xd4, 0xf9, 0x06, 0x92, 0x6f, 0xa1, 0x0b, 0x3b, 0x9f, 0x8b, 0x03, 0x2b, 0xee, 0x0a, 0x6e, 0x97,
	0x3b, 0xba, 0xd1, 0xc6, 0x12, 0x3f, 0x36, 0x74, 0x3e, 0x1e, 0xdb, 0x09, 0x1d, 0xaf, 0xe8, 0xda,
	0x04, 0xea, 0x06, 0x76, 0x49, 0x10, 0x62, 0x5f, 0x4c, 0xfa, 0xe0, 0x13, 0x8b, 0x9d, 0x2a, 0x7d,
	0x1f, 0xf3, 0x8f, 0x70, 0x83, 0xef, 0x20, 0x16, 0x99, 0xff, 0xc8, 0x76, 0x89, 0x13, 0x57, 0x83,
	0x0b, 0xed, 0x7e, 0xba, 0xd4, 0x94, 0x9f, 0xf9, 0x3b, 0x12, 0x25, 0xb9, 0x96, 0x84, 0xec, 0x3e,
	0x54, 0xd8, 0x09, 0x6a, 0x87, 0x91, 0x2f, 0x52, 0xae, 0x19, 0xa9, 0xa2, 0xad, 0x41, 0xba, 0xba,
	0x19, 0x9d, 0x7d, 0xc9, 0xfa, 0x5c, 0x4c, 0x8f, 0xc5, 0x84, 0x36, 0xf2, 0x99, 0x93, 0x02, 0x41,
	0x41, 0x27, 0xde, 0x45, 0x7c, 0xf6, 0xb0, 0x71, 0xfb, 0x87, 0x1c, 0x54, 0x7b, 0x4e, 0x48, 0xae,
	0x48, 0xb8, 0xd4, 0xa9, 0x8b, 0x1a, 0x90, 0xd7, 0x06, 0x3c, 0x58, 0xc1, 0xc8, 0x6b, 0x03, 0x2e,
	0x4f, 0x65, 0x94, 0xbc, 0x36, 0x65, 0x68, 0x32, 0xf2, 0xd0, 0x06, 0x32, 0x8a, 0x94, 0xd2, 0xea,
	0x14, 0xb2, 0xd5, 0x59, 0xeb, 0xbc, 0xe2, 0xf5, 0xce, 0x53, 0xa0, 0x34, 0x71, 0x9c, 0xc8, 0xc7,
	0x33, 0xd9, 0x01, 0xb1, 0xc8, 0x08, 0x46, 0xa7, 0xee, 0x08, 0x07, 0x81, 0xed, 0x62, 0xa5, 0x24,
	0x08, 0x26, 0xd5, 0xb4, 0x7f, 0xca, 0x41, 0xe9, 0xe4, 0xe9, 0x5f, 0xdb, 0xe1, 0xcf, 0x60, 0xf7,
	0xc8, 0xbe, 0xc2, 0x96, 0x4f, 0xf0, 0x6c, 0x38, 0xa7, 0x67, 0xf6, 0x5c, 0x50, 0x18, 0xdf, 0x75,
	0xd9, 0xb8, 0xd9, 0xc8, 0xc0, 0x94, 0xc7, 0xaf, 0x36, 0xe0, 0x35, 0x28, 0x18, 0xa9, 0xa2, 0xfd,
	0xed, 0x06, 0x6c, 0x33, 0xe2, 0x8e, 0x51, 0x88, 0x6f, 0x16, 0xeb, 0x48, 0xdc, 0x87, 0x8a, 0x45,
	0x16, 0x38, 0x08, 0xed, 0xc5, 0x25, 0xcf, 0xbf, 0x6e, 0xa4, 0x0a, 0x89, 0xd3, 0x46, 0x82, 0xd3,
	0x63, 0x68, 0x4c, 0x7d, 0x7c, 0x45, 0x68, 0x14, 0x48, 0xbc, 0x04, 0x30, 0x6b, 0xda, 0x0c, 0x9e,
	0xc5, 0x9b, 0xf1, 0xdc, 0xcc, 0xe2, 0xf9, 0x1c, 0x36, 0x59, 0x9a, 0xd4, 0xe3, 0x78, 0x34, 0xba,
	0x3b, 0x29, 0x4f, 0xc7, 0x5b, 0xa0, 0xde, 0x01, 0x7c, 0xf7, 0xcd, 0xbd, 0xcd, 0x88, 0x78, 0xe1,
	0xd3, 0xae, 0x21, 0xfd, 0x19, 0x73, 0x1d, 0x1b, 0xba, 0xbc, 0x5c, 0xb0, 0x21, 0xda, 0x87, 0x26,
	0x5b, 0x4b, 0xf5, 0x7d, 0xea, 0xc7, 0x28, 0x57, 0xb8, 0xf9, 0x9a, 0x1e, 0xed, 0xc1, 0x96, 0x4e,
	0xdd, 0x15, 0x57, 0x71, 0xc3, 0x58, 0x57, 0xaf, 0xd6, 0x5a, 0x10, 0x76, 0xaa, 0xe0, 0x9f, 0x95,
	0xa0, 0x56, 0x6d, 0xc0, 0x49, 0xbb, 0x62, 0xa4, 0x8a, 0xfd, 0xdf, 0x72, 0x00, 0xe9, 0x36, 0x50,
	0x1d, 0x2a, 0xc7, 0xe3, 0x81, 0x7a, 0xa8, 0x8d, 0xd5, 0x41, 0xf3, 0x6f, 0x08, 0x41, 0x43, 0x9f,
	0x0c, 0xb5, 0xf1, 0xa9, 0xa1, 0x8e, 0x07, 0xaa, 0xa1, 0x0e, 0x9a, 0x39, 0x74, 0x0f, 0x76, 0xfb,
	0x86, 0x3a, 0x50, 0xc7, 0x96, 0xd6, 0xd3, 0xcd, 0x53, 0xf3, 0xf8, 0x60, 0xa4, 0x59, 0x96, 0x3a,
	0x68, 0xe6, 0xd1, 0x36, 0x6c, 0x99, 0xda, 0x70, 0x7c, 0x3c, 0x4d, 0xfd, 0x37, 0xd0, 0x0e, 0x34,
	0xa5, 0x32, 0x75, 0x2d, 0x64, 0xb4, 0xea, 0xa8, 0xa7, 0xe9, 0xa6, 0x3a, 0xb6, 0x9a, 0x45, 0x74,
	0x17, 0xb6, 0xb3, 0xda, 0xbe, 0xae, 0xf5, 0x3f, 0x55, 0x07, 0xcd, 0x4d, 0xa4, 0xc0, 0xce, 0xe1,
	0xc4, 0x18, 0x4e, 0xac, 0xd3, 0x69, 0xcf, 0x34, 0x5f, 0x4f, 0x8c, 0xc1, 0x29, 0x9f, 0x52, 0x62,
	0x53, 0x0c, 0xd5, 0x54, 0xd7, 0x0d, 0x65, 0xd4, 0x00, 0xd0, 0x27, 0xc3, 0xa1, 0x3a, 0x38, 0x9d,
	0x1c, 0x5b, 0xcd, 0x0a, 0xda, 0x82, 0xaa, 0xa9, 0x9a, 0xa6, 0x36, 0x19, 0x9f, 0x9a, 0xaa, 0xd5,
	0x84, 0xee, 0xf7, 0x05, 0x28, 0xc7, 0xbc, 0x89, 0x5e, 0xc2, 0xb6, 0x20, 0xb1, 0x98, 0xa9, 0x04,
	0xf8, 0x77, 0x53, 0xb0, 0x57, 0xd8, 0xb2, 0xb5, 0xb5, 0x76, 0x4d, 0x42, 0x87, 0xd0, 0xd4, 0x82,
	0xe4, 0x22, 0x2f, 0x2e, 0xd9, 0xad, 0xd4, 0x69, 0xfd, 0x8a, 0xdf, 0xba, 0xb3, 0xda, 0x46, 0x09,
	0xdf, 0xab, 0x50, 0x1b, 0xe2, 0x50, 0x67, 0x06, 0x76, 0xf5, 0x42, 0xf7, 0xde, 0x79, 0xaf, 0x6d,
	0xb5, 0xde, 0x7d, 0x63, 0x40, 0x07, 0x0c, 0x75, 0xff, 0x0a, 0xf3, 0x0b, 0xe2, 0x47, 0xc6, 0x38,
	0x82, 0xc6, 0x10, 0x87, 0xfc, 0x2a, 0xb9, 0x14, 0x9b, 0xbc, 0x25, 0xd0, 0x3f, 0x6e, 0xb9, 0x37,
	0xb2, 0x6c, 0x44, 0x18, 0xf6, 0x11, 0x7c, 0x64, 0x36, 0x2f, 0xa1, 0x62, 0xda, 0x57, 0x58, 0x90,
	0xdf, 0x2d, 0x31, 0x32, 0x90, 0xad, 0x9e, 0xa4, 0xff, 0x85, 0x46, 0xe6, 0x85, 0x66, 0x4c, 0xfb,
	0x68, 0x37, 0xe3, 0x9a, 0x5a, 0x5a, 0xb5, 0x8e, 0x7c, 0xd9, 0x9d, 0x50, 0x32, 0xeb, 0xea, 0xd0,
	0xb0, 0x7c, 0xdb, 0xb9, 0xc0, 0x3e, 0x2b, 0x28, 0x71, 0x30, 0x7a, 0x01, 0x55, 0x9d, 0xba, 0x31,
	0x77, 0xa1, 0x7f, 0x5e, 0x27, 0x84, 0x0c, 0xa7, 0xad, 0x46, 0x3b, 0x78, 0x05, 0x8f, 0x3c, 0x1c,
	0x66, 0x5f, 0x95, 0xf2, 0x9d, 0xc9, 0x1e, 0x96, 0x49, 0xa0, 0x2f, 0x1e, 0x7d, 0xc0, 0x4b, 0xfa,
	0x6c, 0x93, 0xbf, 0x3c, 0x9f, 0xfe, 0x1e, 0x00, 0x00, 0xff, 0xff, 0x2e, 0x63, 0xf9, 0xc4, 0x7e,
	0x0f, 0x00, 0x00,
}
