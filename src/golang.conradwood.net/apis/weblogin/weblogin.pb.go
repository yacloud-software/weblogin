// Code generated by protoc-gen-go.
// source: protos/golang.conradwood.net/apis/weblogin/weblogin.proto
// DO NOT EDIT!

/*
Package weblogin is a generated protocol buffer package.

It is generated from these files:
	protos/golang.conradwood.net/apis/weblogin/weblogin.proto

It has these top-level messages:
	BasicAuthRequest
	AuthResponse
	WebloginRequest
	EmailPageResponse
	WebloginResponse
	State
	StateResponse
	RegisterState
	RegisterProto
	Email
	ActivityLog
	V3State
*/
package weblogin

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import auth "golang.conradwood.net/apis/auth"
import h2gproxy "golang.conradwood.net/apis/h2gproxy"
import session "golang.yacloud.eu/apis/session"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type BasicAuthRequest struct {
	// the stuff extracted from "Authorization" Header
	Username string `protobuf:"bytes,1,opt,name=Username" json:"Username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=Password" json:"Password,omitempty"`
}

func (m *BasicAuthRequest) Reset()                    { *m = BasicAuthRequest{} }
func (m *BasicAuthRequest) String() string            { return proto.CompactTextString(m) }
func (*BasicAuthRequest) ProtoMessage()               {}
func (*BasicAuthRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *BasicAuthRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *BasicAuthRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type AuthResponse struct {
	IsValid  bool       `protobuf:"varint,1,opt,name=IsValid" json:"IsValid,omitempty"`
	Response *auth.User `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *AuthResponse) Reset()                    { *m = AuthResponse{} }
func (m *AuthResponse) String() string            { return proto.CompactTextString(m) }
func (*AuthResponse) ProtoMessage()               {}
func (*AuthResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AuthResponse) GetIsValid() bool {
	if m != nil {
		return m.IsValid
	}
	return false
}

func (m *AuthResponse) GetResponse() *auth.User {
	if m != nil {
		return m.Response
	}
	return nil
}

type WebloginRequest struct {
	Method    string             `protobuf:"bytes,1,opt,name=Method" json:"Method,omitempty"`
	Scheme    string             `protobuf:"bytes,2,opt,name=Scheme" json:"Scheme,omitempty"`
	Host      string             `protobuf:"bytes,3,opt,name=Host" json:"Host,omitempty"`
	Path      string             `protobuf:"bytes,4,opt,name=Path" json:"Path,omitempty"`
	Query     string             `protobuf:"bytes,5,opt,name=Query" json:"Query,omitempty"`
	Body      string             `protobuf:"bytes,6,opt,name=Body" json:"Body,omitempty"`
	Submitted map[string]string  `protobuf:"bytes,7,rep,name=Submitted" json:"Submitted,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Peer      string             `protobuf:"bytes,8,opt,name=Peer" json:"Peer,omitempty"`
	Cookies   []*h2gproxy.Cookie `protobuf:"bytes,9,rep,name=Cookies" json:"Cookies,omitempty"`
	UserAgent string             `protobuf:"bytes,10,opt,name=UserAgent" json:"UserAgent,omitempty"`
}

func (m *WebloginRequest) Reset()                    { *m = WebloginRequest{} }
func (m *WebloginRequest) String() string            { return proto.CompactTextString(m) }
func (*WebloginRequest) ProtoMessage()               {}
func (*WebloginRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *WebloginRequest) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *WebloginRequest) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *WebloginRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *WebloginRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *WebloginRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *WebloginRequest) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *WebloginRequest) GetSubmitted() map[string]string {
	if m != nil {
		return m.Submitted
	}
	return nil
}

func (m *WebloginRequest) GetPeer() string {
	if m != nil {
		return m.Peer
	}
	return ""
}

func (m *WebloginRequest) GetCookies() []*h2gproxy.Cookie {
	if m != nil {
		return m.Cookies
	}
	return nil
}

func (m *WebloginRequest) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

type EmailPageResponse struct {
	HTML     string            `protobuf:"bytes,1,opt,name=HTML" json:"HTML,omitempty"`
	Verified bool              `protobuf:"varint,2,opt,name=Verified" json:"Verified,omitempty"`
	User     *auth.User        `protobuf:"bytes,3,opt,name=User" json:"User,omitempty"`
	Headers  map[string]string `protobuf:"bytes,4,rep,name=Headers" json:"Headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *EmailPageResponse) Reset()                    { *m = EmailPageResponse{} }
func (m *EmailPageResponse) String() string            { return proto.CompactTextString(m) }
func (*EmailPageResponse) ProtoMessage()               {}
func (*EmailPageResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *EmailPageResponse) GetHTML() string {
	if m != nil {
		return m.HTML
	}
	return ""
}

func (m *EmailPageResponse) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

func (m *EmailPageResponse) GetUser() *auth.User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *EmailPageResponse) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

type WebloginResponse struct {
	Body                  []byte             `protobuf:"bytes,1,opt,name=Body,proto3" json:"Body,omitempty"`
	Authenticated         bool               `protobuf:"varint,2,opt,name=Authenticated" json:"Authenticated,omitempty"`
	User                  *auth.User         `protobuf:"bytes,3,opt,name=User" json:"User,omitempty"`
	Token                 string             `protobuf:"bytes,4,opt,name=Token" json:"Token,omitempty"`
	CookieLivetime        uint32             `protobuf:"varint,5,opt,name=CookieLivetime" json:"CookieLivetime,omitempty"`
	RedirectTo            string             `protobuf:"bytes,6,opt,name=RedirectTo" json:"RedirectTo,omitempty"`
	Cookies               []*h2gproxy.Cookie `protobuf:"bytes,7,rep,name=Cookies" json:"Cookies,omitempty"`
	Headers               map[string]string  `protobuf:"bytes,8,rep,name=Headers" json:"Headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ForceGetAfterRedirect bool               `protobuf:"varint,9,opt,name=ForceGetAfterRedirect" json:"ForceGetAfterRedirect,omitempty"`
	PeerIsDosing          bool               `protobuf:"varint,10,opt,name=PeerIsDosing" json:"PeerIsDosing,omitempty"`
	PeerIP                string             `protobuf:"bytes,11,opt,name=PeerIP" json:"PeerIP,omitempty"`
	HTTPCode              uint32             `protobuf:"varint,12,opt,name=HTTPCode" json:"HTTPCode,omitempty"`
	MimeType              string             `protobuf:"bytes,13,opt,name=MimeType" json:"MimeType,omitempty"`
	Session               *session.Session   `protobuf:"bytes,14,opt,name=Session" json:"Session,omitempty"`
}

func (m *WebloginResponse) Reset()                    { *m = WebloginResponse{} }
func (m *WebloginResponse) String() string            { return proto.CompactTextString(m) }
func (*WebloginResponse) ProtoMessage()               {}
func (*WebloginResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *WebloginResponse) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *WebloginResponse) GetAuthenticated() bool {
	if m != nil {
		return m.Authenticated
	}
	return false
}

func (m *WebloginResponse) GetUser() *auth.User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *WebloginResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *WebloginResponse) GetCookieLivetime() uint32 {
	if m != nil {
		return m.CookieLivetime
	}
	return 0
}

func (m *WebloginResponse) GetRedirectTo() string {
	if m != nil {
		return m.RedirectTo
	}
	return ""
}

func (m *WebloginResponse) GetCookies() []*h2gproxy.Cookie {
	if m != nil {
		return m.Cookies
	}
	return nil
}

func (m *WebloginResponse) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *WebloginResponse) GetForceGetAfterRedirect() bool {
	if m != nil {
		return m.ForceGetAfterRedirect
	}
	return false
}

func (m *WebloginResponse) GetPeerIsDosing() bool {
	if m != nil {
		return m.PeerIsDosing
	}
	return false
}

func (m *WebloginResponse) GetPeerIP() string {
	if m != nil {
		return m.PeerIP
	}
	return ""
}

func (m *WebloginResponse) GetHTTPCode() uint32 {
	if m != nil {
		return m.HTTPCode
	}
	return 0
}

func (m *WebloginResponse) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *WebloginResponse) GetSession() *session.Session {
	if m != nil {
		return m.Session
	}
	return nil
}

// this protobuf is never exposed to the user. it is held server-side and referred to by a shortlived magic
type State struct {
	TriggerHost  string `protobuf:"bytes,1,opt,name=TriggerHost" json:"TriggerHost,omitempty"`
	TriggerPath  string `protobuf:"bytes,2,opt,name=TriggerPath" json:"TriggerPath,omitempty"`
	TriggerQuery string `protobuf:"bytes,3,opt,name=TriggerQuery" json:"TriggerQuery,omitempty"`
	Token        string `protobuf:"bytes,4,opt,name=Token" json:"Token,omitempty"`
	Method       string `protobuf:"bytes,5,opt,name=Method" json:"Method,omitempty"`
}

func (m *State) Reset()                    { *m = State{} }
func (m *State) String() string            { return proto.CompactTextString(m) }
func (*State) ProtoMessage()               {}
func (*State) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *State) GetTriggerHost() string {
	if m != nil {
		return m.TriggerHost
	}
	return ""
}

func (m *State) GetTriggerPath() string {
	if m != nil {
		return m.TriggerPath
	}
	return ""
}

func (m *State) GetTriggerQuery() string {
	if m != nil {
		return m.TriggerQuery
	}
	return ""
}

func (m *State) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *State) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

type StateResponse struct {
	YacloudWebloginState string `protobuf:"bytes,1,opt,name=YacloudWebloginState" json:"YacloudWebloginState,omitempty"`
	URLStateName         string `protobuf:"bytes,2,opt,name=URLStateName" json:"URLStateName,omitempty"`
}

func (m *StateResponse) Reset()                    { *m = StateResponse{} }
func (m *StateResponse) String() string            { return proto.CompactTextString(m) }
func (*StateResponse) ProtoMessage()               {}
func (*StateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *StateResponse) GetYacloudWebloginState() string {
	if m != nil {
		return m.YacloudWebloginState
	}
	return ""
}

func (m *StateResponse) GetURLStateName() string {
	if m != nil {
		return m.URLStateName
	}
	return ""
}

type RegisterState struct {
	Host    string `protobuf:"bytes,1,opt,name=Host" json:"Host,omitempty"`
	Email   string `protobuf:"bytes,2,opt,name=Email" json:"Email,omitempty"`
	Created uint32 `protobuf:"varint,3,opt,name=Created" json:"Created,omitempty"`
	Magic   string `protobuf:"bytes,4,opt,name=Magic" json:"Magic,omitempty"`
}

func (m *RegisterState) Reset()                    { *m = RegisterState{} }
func (m *RegisterState) String() string            { return proto.CompactTextString(m) }
func (*RegisterState) ProtoMessage()               {}
func (*RegisterState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *RegisterState) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *RegisterState) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *RegisterState) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *RegisterState) GetMagic() string {
	if m != nil {
		return m.Magic
	}
	return ""
}

type RegisterProto struct {
	State     string `protobuf:"bytes,1,opt,name=State" json:"State,omitempty"`
	Signature []byte `protobuf:"bytes,2,opt,name=Signature,proto3" json:"Signature,omitempty"`
}

func (m *RegisterProto) Reset()                    { *m = RegisterProto{} }
func (m *RegisterProto) String() string            { return proto.CompactTextString(m) }
func (*RegisterProto) ProtoMessage()               {}
func (*RegisterProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *RegisterProto) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *RegisterProto) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type Email struct {
	Subject string `protobuf:"bytes,1,opt,name=Subject" json:"Subject,omitempty"`
	Body    string `protobuf:"bytes,2,opt,name=Body" json:"Body,omitempty"`
	Link    string `protobuf:"bytes,3,opt,name=Link" json:"Link,omitempty"`
}

func (m *Email) Reset()                    { *m = Email{} }
func (m *Email) String() string            { return proto.CompactTextString(m) }
func (*Email) ProtoMessage()               {}
func (*Email) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Email) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Email) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *Email) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

type ActivityLog struct {
	ID          uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	IP          string `protobuf:"bytes,2,opt,name=IP" json:"IP,omitempty"`
	UserID      string `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	Email       string `protobuf:"bytes,4,opt,name=Email" json:"Email,omitempty"`
	TriggerHost string `protobuf:"bytes,5,opt,name=TriggerHost" json:"TriggerHost,omitempty"`
	Occured     uint32 `protobuf:"varint,6,opt,name=Occured" json:"Occured,omitempty"`
	LogMessage  string `protobuf:"bytes,7,opt,name=LogMessage" json:"LogMessage,omitempty"`
}

func (m *ActivityLog) Reset()                    { *m = ActivityLog{} }
func (m *ActivityLog) String() string            { return proto.CompactTextString(m) }
func (*ActivityLog) ProtoMessage()               {}
func (*ActivityLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ActivityLog) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ActivityLog) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *ActivityLog) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *ActivityLog) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *ActivityLog) GetTriggerHost() string {
	if m != nil {
		return m.TriggerHost
	}
	return ""
}

func (m *ActivityLog) GetOccured() uint32 {
	if m != nil {
		return m.Occured
	}
	return 0
}

func (m *ActivityLog) GetLogMessage() string {
	if m != nil {
		return m.LogMessage
	}
	return ""
}

// this is the state of a process from beginning to end.
type V3State struct {
	TriggerHost           string `protobuf:"bytes,1,opt,name=TriggerHost" json:"TriggerHost,omitempty"`
	TriggerPath           string `protobuf:"bytes,2,opt,name=TriggerPath" json:"TriggerPath,omitempty"`
	TriggerQuery          string `protobuf:"bytes,3,opt,name=TriggerQuery" json:"TriggerQuery,omitempty"`
	HaveTriedGlobalCookie bool   `protobuf:"varint,4,opt,name=HaveTriedGlobalCookie" json:"HaveTriedGlobalCookie,omitempty"`
	RequestID             uint64 `protobuf:"varint,5,opt,name=RequestID" json:"RequestID,omitempty"`
}

func (m *V3State) Reset()                    { *m = V3State{} }
func (m *V3State) String() string            { return proto.CompactTextString(m) }
func (*V3State) ProtoMessage()               {}
func (*V3State) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *V3State) GetTriggerHost() string {
	if m != nil {
		return m.TriggerHost
	}
	return ""
}

func (m *V3State) GetTriggerPath() string {
	if m != nil {
		return m.TriggerPath
	}
	return ""
}

func (m *V3State) GetTriggerQuery() string {
	if m != nil {
		return m.TriggerQuery
	}
	return ""
}

func (m *V3State) GetHaveTriedGlobalCookie() bool {
	if m != nil {
		return m.HaveTriedGlobalCookie
	}
	return false
}

func (m *V3State) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func init() {
	proto.RegisterType((*BasicAuthRequest)(nil), "weblogin.BasicAuthRequest")
	proto.RegisterType((*AuthResponse)(nil), "weblogin.AuthResponse")
	proto.RegisterType((*WebloginRequest)(nil), "weblogin.WebloginRequest")
	proto.RegisterType((*EmailPageResponse)(nil), "weblogin.EmailPageResponse")
	proto.RegisterType((*WebloginResponse)(nil), "weblogin.WebloginResponse")
	proto.RegisterType((*State)(nil), "weblogin.State")
	proto.RegisterType((*StateResponse)(nil), "weblogin.StateResponse")
	proto.RegisterType((*RegisterState)(nil), "weblogin.RegisterState")
	proto.RegisterType((*RegisterProto)(nil), "weblogin.RegisterProto")
	proto.RegisterType((*Email)(nil), "weblogin.Email")
	proto.RegisterType((*ActivityLog)(nil), "weblogin.ActivityLog")
	proto.RegisterType((*V3State)(nil), "weblogin.V3State")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Weblogin service

type WebloginClient interface {
	CreateRegisterEmail(ctx context.Context, in *RegisterState, opts ...grpc.CallOption) (*Email, error)
	// sometimes we need basic auth if so, we get a request to same URL with a an
	// Authorization Header
	// if so, the h2gproxy needs to verify the header
	IsBasicAuthValid(ctx context.Context, in *BasicAuthRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	// serve the login page
	GetLoginPage(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*WebloginResponse, error)
	// generic html serve thing for h2gproxy
	ServeHTML(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*WebloginResponse, error)
	// called if a user is authenticated but the users' email address is not yet verified
	// returns true if email is now verified
	GetVerifyEmail(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*EmailPageResponse, error)
	// helper for h2gproxy. verify a "weblogin=foobar" url. Body is ignored in the response.
	// cookie is helpful though
	VerifyURL(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*WebloginResponse, error)
	// helper for h2gproxy. create a state (before redirecting browser to weblogin)
	SaveState(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*StateResponse, error)
}

type webloginClient struct {
	cc *grpc.ClientConn
}

func NewWebloginClient(cc *grpc.ClientConn) WebloginClient {
	return &webloginClient{cc}
}

func (c *webloginClient) CreateRegisterEmail(ctx context.Context, in *RegisterState, opts ...grpc.CallOption) (*Email, error) {
	out := new(Email)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/CreateRegisterEmail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webloginClient) IsBasicAuthValid(ctx context.Context, in *BasicAuthRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/IsBasicAuthValid", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webloginClient) GetLoginPage(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*WebloginResponse, error) {
	out := new(WebloginResponse)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/GetLoginPage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webloginClient) ServeHTML(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*WebloginResponse, error) {
	out := new(WebloginResponse)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/ServeHTML", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webloginClient) GetVerifyEmail(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*EmailPageResponse, error) {
	out := new(EmailPageResponse)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/GetVerifyEmail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webloginClient) VerifyURL(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*WebloginResponse, error) {
	out := new(WebloginResponse)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/VerifyURL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webloginClient) SaveState(ctx context.Context, in *WebloginRequest, opts ...grpc.CallOption) (*StateResponse, error) {
	out := new(StateResponse)
	err := grpc.Invoke(ctx, "/weblogin.Weblogin/SaveState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Weblogin service

type WebloginServer interface {
	CreateRegisterEmail(context.Context, *RegisterState) (*Email, error)
	// sometimes we need basic auth if so, we get a request to same URL with a an
	// Authorization Header
	// if so, the h2gproxy needs to verify the header
	IsBasicAuthValid(context.Context, *BasicAuthRequest) (*AuthResponse, error)
	// serve the login page
	GetLoginPage(context.Context, *WebloginRequest) (*WebloginResponse, error)
	// generic html serve thing for h2gproxy
	ServeHTML(context.Context, *WebloginRequest) (*WebloginResponse, error)
	// called if a user is authenticated but the users' email address is not yet verified
	// returns true if email is now verified
	GetVerifyEmail(context.Context, *WebloginRequest) (*EmailPageResponse, error)
	// helper for h2gproxy. verify a "weblogin=foobar" url. Body is ignored in the response.
	// cookie is helpful though
	VerifyURL(context.Context, *WebloginRequest) (*WebloginResponse, error)
	// helper for h2gproxy. create a state (before redirecting browser to weblogin)
	SaveState(context.Context, *WebloginRequest) (*StateResponse, error)
}

func RegisterWebloginServer(s *grpc.Server, srv WebloginServer) {
	s.RegisterService(&_Weblogin_serviceDesc, srv)
}

func _Weblogin_CreateRegisterEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).CreateRegisterEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/CreateRegisterEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).CreateRegisterEmail(ctx, req.(*RegisterState))
	}
	return interceptor(ctx, in, info, handler)
}

func _Weblogin_IsBasicAuthValid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BasicAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).IsBasicAuthValid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/IsBasicAuthValid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).IsBasicAuthValid(ctx, req.(*BasicAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Weblogin_GetLoginPage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebloginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).GetLoginPage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/GetLoginPage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).GetLoginPage(ctx, req.(*WebloginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Weblogin_ServeHTML_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebloginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).ServeHTML(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/ServeHTML",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).ServeHTML(ctx, req.(*WebloginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Weblogin_GetVerifyEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebloginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).GetVerifyEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/GetVerifyEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).GetVerifyEmail(ctx, req.(*WebloginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Weblogin_VerifyURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebloginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).VerifyURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/VerifyURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).VerifyURL(ctx, req.(*WebloginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Weblogin_SaveState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebloginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebloginServer).SaveState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/weblogin.Weblogin/SaveState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebloginServer).SaveState(ctx, req.(*WebloginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Weblogin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "weblogin.Weblogin",
	HandlerType: (*WebloginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRegisterEmail",
			Handler:    _Weblogin_CreateRegisterEmail_Handler,
		},
		{
			MethodName: "IsBasicAuthValid",
			Handler:    _Weblogin_IsBasicAuthValid_Handler,
		},
		{
			MethodName: "GetLoginPage",
			Handler:    _Weblogin_GetLoginPage_Handler,
		},
		{
			MethodName: "ServeHTML",
			Handler:    _Weblogin_ServeHTML_Handler,
		},
		{
			MethodName: "GetVerifyEmail",
			Handler:    _Weblogin_GetVerifyEmail_Handler,
		},
		{
			MethodName: "VerifyURL",
			Handler:    _Weblogin_VerifyURL_Handler,
		},
		{
			MethodName: "SaveState",
			Handler:    _Weblogin_SaveState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/golang.conradwood.net/apis/weblogin/weblogin.proto",
}

func init() {
	proto.RegisterFile("protos/golang.conradwood.net/apis/weblogin/weblogin.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1135 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x56, 0xdd, 0x6e, 0x1b, 0xc5,
	0x17, 0x97, 0x1d, 0xbb, 0xb6, 0x4f, 0xec, 0xd4, 0xff, 0xf9, 0xa7, 0x65, 0x31, 0x55, 0x15, 0x2d,
	0x50, 0xa2, 0x0a, 0x39, 0x92, 0xdb, 0x0b, 0xa8, 0x90, 0xaa, 0x7c, 0xc7, 0xc8, 0x01, 0xb3, 0x76,
	0x82, 0xb8, 0x9c, 0x78, 0x4f, 0xd7, 0x43, 0xec, 0x9d, 0xb0, 0x33, 0x76, 0xf0, 0xc3, 0xf0, 0x1c,
	0x3c, 0x01, 0x57, 0x3c, 0x06, 0xd7, 0x5c, 0x73, 0x8b, 0xe6, 0x6b, 0x77, 0xed, 0x26, 0xae, 0x28,
	0x12, 0x37, 0xf6, 0x9c, 0x8f, 0x39, 0x73, 0xe6, 0x9c, 0xdf, 0xfe, 0xce, 0xc0, 0x97, 0x37, 0x09,
	0x97, 0x5c, 0xec, 0x45, 0x7c, 0x42, 0xe3, 0xa8, 0x3d, 0xe2, 0x71, 0x42, 0xc3, 0x5b, 0xce, 0xc3,
	0x76, 0x8c, 0x72, 0x8f, 0xde, 0x30, 0xb1, 0x77, 0x8b, 0x57, 0x13, 0x1e, 0xb1, 0x38, 0x5d, 0xb4,
	0xf5, 0x1e, 0x52, 0x75, 0x72, 0xeb, 0xf9, 0x9a, 0xdd, 0x74, 0x26, 0xc7, 0xfa, 0xc7, 0xec, 0x6a,
	0x75, 0xd6, 0xf8, 0x8e, 0x3b, 0xd1, 0x4d, 0xc2, 0x7f, 0x5e, 0xa4, 0x0b, 0xbb, 0xe7, 0x73, 0xbb,
	0x67, 0x41, 0x47, 0x13, 0x3e, 0x0b, 0xdb, 0x38, 0x33, 0xfe, 0x02, 0x85, 0x60, 0x3c, 0x76, 0xff,
	0xc6, 0xdb, 0xff, 0x1a, 0x9a, 0x07, 0x54, 0xb0, 0xd1, 0xfe, 0x4c, 0x8e, 0x03, 0xfc, 0x69, 0x86,
	0x42, 0x92, 0x16, 0x54, 0x2f, 0x04, 0x26, 0x31, 0x9d, 0xa2, 0x57, 0xd8, 0x29, 0xec, 0xd6, 0x82,
	0x54, 0x56, 0xb6, 0x3e, 0x15, 0xe2, 0x96, 0x27, 0xa1, 0x57, 0x34, 0x36, 0x27, 0xfb, 0x7d, 0xa8,
	0x9b, 0x30, 0xe2, 0x86, 0xc7, 0x02, 0x89, 0x07, 0x95, 0xae, 0xb8, 0xa4, 0x13, 0x16, 0xea, 0x30,
	0xd5, 0xc0, 0x89, 0xe4, 0x19, 0x54, 0x9d, 0x97, 0x8e, 0xb2, 0xd9, 0x81, 0xb6, 0xbe, 0xb6, 0x3a,
	0x27, 0x48, 0x6d, 0xfe, 0x5f, 0x45, 0x78, 0xf8, 0xbd, 0x2d, 0x9c, 0xcb, 0xee, 0x31, 0x3c, 0x38,
	0x47, 0x39, 0xe6, 0xa1, 0xcd, 0xcd, 0x4a, 0x4a, 0x3f, 0x18, 0x8d, 0x71, 0x8a, 0x36, 0x2f, 0x2b,
	0x11, 0x02, 0xa5, 0x33, 0x2e, 0xa4, 0xb7, 0xa1, 0xb5, 0x7a, 0xad, 0x74, 0x7d, 0x2a, 0xc7, 0x5e,
	0xc9, 0xe8, 0xd4, 0x9a, 0x6c, 0x43, 0xf9, 0xbb, 0x19, 0x26, 0x0b, 0xaf, 0xac, 0x95, 0x46, 0x50,
	0x9e, 0x07, 0x3c, 0x5c, 0x78, 0x0f, 0x8c, 0xa7, 0x5a, 0x93, 0x13, 0xa8, 0x0d, 0x66, 0x57, 0x53,
	0x26, 0x25, 0x86, 0x5e, 0x65, 0x67, 0x63, 0x77, 0xb3, 0xb3, 0xdb, 0x4e, 0xfb, 0xbd, 0x92, 0x6f,
	0x3b, 0x75, 0x3d, 0x8e, 0x65, 0xb2, 0x08, 0xb2, 0xad, 0x3a, 0x0b, 0xc4, 0xc4, 0xab, 0xda, 0x2c,
	0x10, 0x13, 0xf2, 0x1c, 0x2a, 0x87, 0x9c, 0x5f, 0x33, 0x14, 0x5e, 0x4d, 0x47, 0x6e, 0xb6, 0xd3,
	0xfe, 0x1a, 0x43, 0xe0, 0x1c, 0xc8, 0x13, 0xa8, 0xa9, 0x7a, 0xed, 0x47, 0x18, 0x4b, 0x0f, 0x74,
	0x90, 0x4c, 0xd1, 0xfa, 0x0a, 0xb6, 0x96, 0x8f, 0x26, 0x4d, 0xd8, 0xb8, 0xc6, 0x85, 0x2d, 0x9b,
	0x5a, 0xaa, 0x3b, 0xcf, 0xe9, 0x64, 0xe6, 0x4a, 0x66, 0x84, 0x57, 0xc5, 0x2f, 0x0a, 0xfe, 0x1f,
	0x05, 0xf8, 0xdf, 0xf1, 0x94, 0xb2, 0x49, 0x9f, 0x46, 0x98, 0x76, 0x54, 0xd5, 0x72, 0x78, 0xde,
	0xb3, 0x21, 0xf4, 0x5a, 0x21, 0xe2, 0x12, 0x13, 0xf6, 0x86, 0xa1, 0x41, 0x44, 0x35, 0x48, 0x65,
	0xf2, 0x14, 0x4a, 0x2a, 0x21, 0x5d, 0xfb, 0xe5, 0x1e, 0x6b, 0x3d, 0x39, 0x80, 0xca, 0x19, 0xd2,
	0x10, 0x13, 0xe1, 0x95, 0x56, 0xeb, 0xf8, 0xd6, 0xe9, 0x6d, 0xeb, 0x6a, 0xea, 0xe8, 0x36, 0xb6,
	0x5e, 0x41, 0x3d, 0x6f, 0xf8, 0x47, 0xb7, 0xfc, 0xbd, 0x04, 0xcd, 0xac, 0x5f, 0xd9, 0x25, 0x75,
	0xcb, 0x55, 0x84, 0xba, 0x6d, 0xf9, 0x27, 0xd0, 0x50, 0xd0, 0xc6, 0x58, 0xb2, 0x11, 0x95, 0xe9,
	0x4d, 0x97, 0x95, 0xef, 0xbc, 0xee, 0x36, 0x94, 0x87, 0xfc, 0x1a, 0x63, 0x8b, 0x3b, 0x23, 0x90,
	0x67, 0xb0, 0x65, 0x3a, 0xda, 0x63, 0x73, 0x94, 0x6c, 0x8a, 0x1a, 0x81, 0x8d, 0x60, 0x45, 0x4b,
	0x9e, 0x02, 0x04, 0x18, 0xb2, 0x04, 0x47, 0x72, 0xc8, 0x2d, 0x20, 0x73, 0x9a, 0x3c, 0x74, 0x2a,
	0xef, 0x82, 0xce, 0x7e, 0x56, 0xf8, 0xaa, 0xf6, 0xfd, 0xec, 0x2e, 0x00, 0xaf, 0xab, 0x3b, 0x79,
	0x09, 0x8f, 0x4e, 0x78, 0x32, 0xc2, 0x53, 0x94, 0xfb, 0x6f, 0x24, 0x26, 0x2e, 0x13, 0xaf, 0xa6,
	0x4b, 0x73, 0xb7, 0x91, 0xf8, 0x50, 0x57, 0x38, 0xef, 0x8a, 0x23, 0x2e, 0x58, 0x1c, 0x69, 0xd8,
	0x56, 0x83, 0x25, 0x9d, 0xfa, 0x92, 0xb5, 0xdc, 0xf7, 0x36, 0xcd, 0x97, 0x6c, 0x24, 0x85, 0xb4,
	0xb3, 0xe1, 0xb0, 0x7f, 0xc8, 0x43, 0xf4, 0xea, 0xba, 0x44, 0xa9, 0xac, 0x6c, 0xe7, 0x6c, 0x8a,
	0xc3, 0xc5, 0x0d, 0x7a, 0x0d, 0xc3, 0x4b, 0x4e, 0x56, 0x85, 0x19, 0x18, 0xd2, 0xf3, 0xb6, 0x74,
	0x67, 0x9a, 0x6d, 0x47, 0x82, 0x56, 0x1f, 0x38, 0x87, 0x7f, 0x85, 0xa6, 0x5f, 0x0a, 0x50, 0x1e,
	0x48, 0x2a, 0x91, 0xec, 0xc0, 0xe6, 0x30, 0x61, 0x51, 0x84, 0x89, 0xa6, 0x1e, 0xb3, 0x3b, 0xaf,
	0xca, 0x79, 0x68, 0x22, 0x2a, 0x2e, 0x79, 0x68, 0x3e, 0xf2, 0xa1, 0x6e, 0x45, 0x43, 0x4b, 0x86,
	0xbf, 0x96, 0x74, 0xf7, 0x00, 0x2a, 0x63, 0xc8, 0x72, 0x9e, 0x21, 0xfd, 0x08, 0x1a, 0x3a, 0xbd,
	0x14, 0xe9, 0x1d, 0xd8, 0xfe, 0xc1, 0x4c, 0x09, 0xd7, 0x73, 0x6d, 0xb7, 0xf9, 0xde, 0x69, 0x53,
	0x69, 0x5d, 0x04, 0x3d, 0xbd, 0xfe, 0x86, 0xa6, 0x64, 0xbb, 0xa4, 0xf3, 0x19, 0x34, 0x02, 0x8c,
	0x98, 0x90, 0x98, 0x98, 0x4d, 0x8e, 0x83, 0x0b, 0x39, 0x0e, 0xde, 0x86, 0xb2, 0xfe, 0xc4, 0x5d,
	0x1d, 0xb5, 0xa0, 0x66, 0xc6, 0x61, 0x82, 0xfa, 0x13, 0xdb, 0xd0, 0x2d, 0x76, 0xa2, 0xf2, 0x3f,
	0xa7, 0x11, 0x1b, 0xb9, 0xbb, 0x6a, 0xc1, 0x3f, 0xcc, 0x8e, 0xea, 0xeb, 0x41, 0xbb, 0x6d, 0x7b,
	0x60, 0xcf, 0xb2, 0x0d, 0x79, 0x02, 0xb5, 0x01, 0x8b, 0x62, 0x2a, 0x67, 0x89, 0x49, 0xb9, 0x1e,
	0x64, 0x0a, 0xbf, 0x0b, 0xd9, 0xe9, 0x83, 0xd9, 0xd5, 0x8f, 0x0a, 0xc5, 0x66, 0xbb, 0x13, 0x53,
	0x52, 0x28, 0xe6, 0xe6, 0x00, 0x81, 0x52, 0x8f, 0xc5, 0xd7, 0x6e, 0xb2, 0xa8, 0xb5, 0xff, 0x6b,
	0x01, 0x36, 0xf7, 0x47, 0x92, 0xcd, 0x99, 0x5c, 0xf4, 0x78, 0x44, 0xb6, 0xa0, 0xd8, 0x3d, 0xd2,
	0xc1, 0x4a, 0x41, 0xb1, 0x7b, 0xa4, 0xe5, 0xbe, 0x8d, 0x52, 0xec, 0xf6, 0x55, 0xaf, 0x14, 0x35,
	0x74, 0x8f, 0x6c, 0x14, 0x2b, 0x65, 0xd5, 0x29, 0xe5, 0xab, 0xb3, 0x82, 0xab, 0xf2, 0xdb, 0xb8,
	0xf2, 0xa0, 0xf2, 0xed, 0x68, 0x34, 0x4b, 0x30, 0xd4, 0x0c, 0xd1, 0x08, 0x9c, 0xa8, 0xe8, 0xa3,
	0xc7, 0xa3, 0x73, 0x14, 0x82, 0x46, 0xe8, 0x55, 0x0c, 0x7d, 0x64, 0x1a, 0xff, 0xb7, 0x02, 0x54,
	0x2e, 0x5f, 0xfc, 0xb7, 0xf8, 0x7d, 0x09, 0x8f, 0xce, 0xe8, 0x1c, 0x87, 0x09, 0xc3, 0xf0, 0x74,
	0xc2, 0xaf, 0xe8, 0xc4, 0x10, 0x94, 0xbe, 0x75, 0x35, 0xb8, 0xdb, 0xa8, 0x9a, 0x69, 0x87, 0x6b,
	0xf7, 0x48, 0xd7, 0xa0, 0x14, 0x64, 0x8a, 0xce, 0x9f, 0x1b, 0x50, 0x75, 0x90, 0x25, 0xaf, 0xe1,
	0xff, 0x06, 0x3f, 0x0e, 0x24, 0xa6, 0x8e, 0x1f, 0x64, 0x6c, 0xb7, 0x04, 0xd4, 0xd6, 0xc3, 0x95,
	0xf9, 0x43, 0x4e, 0xa0, 0xd9, 0x15, 0xe9, 0x0b, 0xc9, 0xbc, 0x5e, 0x5a, 0x99, 0xd3, 0xea, 0xdb,
	0xa9, 0xf5, 0x38, 0xb3, 0x2d, 0xbd, 0x85, 0x8e, 0xa1, 0x7e, 0x8a, 0xb2, 0xa7, 0x0c, 0x6a, 0xa6,
	0x91, 0x0f, 0xef, 0x7d, 0x30, 0xb4, 0x5a, 0xf7, 0x53, 0x31, 0x39, 0x80, 0xda, 0x00, 0x93, 0x39,
	0xea, 0xc9, 0xfb, 0x9e, 0x31, 0xce, 0x60, 0xeb, 0x14, 0xa5, 0x9e, 0xd1, 0x0b, 0x73, 0xc9, 0x35,
	0x81, 0x3e, 0x5a, 0x33, 0x90, 0x55, 0x36, 0x26, 0xcc, 0x45, 0xf0, 0xde, 0xd9, 0xbc, 0x86, 0xda,
	0x80, 0xce, 0xd1, 0xe0, 0x6e, 0x4d, 0x8c, 0x5c, 0xcb, 0x96, 0x48, 0xec, 0xe0, 0x53, 0xf8, 0x38,
	0x46, 0x99, 0x7f, 0x22, 0xdb, 0x07, 0xb0, 0x7a, 0xf5, 0xa6, 0x9b, 0xae, 0x1e, 0xe8, 0xf7, 0xee,
	0x8b, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xb6, 0x3d, 0x48, 0x1f, 0xc4, 0x0b, 0x00, 0x00,
}
