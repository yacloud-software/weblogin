// Code generated by protoc-gen-go.
// source: golang.singingcat.net/apis/scupdate/scupdate.proto
// DO NOT EDIT!

/*
Package scupdate is a generated protocol buffer package.

It is generated from these files:
	golang.singingcat.net/apis/scupdate/scupdate.proto

It has these top-level messages:
	ActiveUpdate
	Tracker
	UpdateInfo
	UpdateRequest
	BlobUpdateRequest
	Match
	UpdateResponse
	ComReceived
	UpdateStatus
	UpdateStatusList
	FirmwareInfo
	HistoryList
	History
	UpgradeRepoRequest
	UpdateFromRepoRequest
*/
package scupdate

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import gitserver "golang.conradwood.net/apis/gitserver"
import singingcat "golang.singingcat.net/apis/singingcat"
import scapply "golang.singingcat.net/apis/scapply"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type UpgradeResult int32

const (
	UpgradeResult_PENDING  UpgradeResult = 0
	UpgradeResult_TIMEOUT  UpgradeResult = 1
	UpgradeResult_SUCCESS  UpgradeResult = 2
	UpgradeResult_REJECTED UpgradeResult = 3
	UpgradeResult_FAILED   UpgradeResult = 4
)

var UpgradeResult_name = map[int32]string{
	0: "PENDING",
	1: "TIMEOUT",
	2: "SUCCESS",
	3: "REJECTED",
	4: "FAILED",
}
var UpgradeResult_value = map[string]int32{
	"PENDING":  0,
	"TIMEOUT":  1,
	"SUCCESS":  2,
	"REJECTED": 3,
	"FAILED":   4,
}

func (x UpgradeResult) String() string {
	return proto.EnumName(UpgradeResult_name, int32(x))
}
func (UpgradeResult) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// flags the module understands when triggering an update
type UpdateFlags int32

const (
	// \brief unless this is set, flags are ignored
	UpdateFlags_FLASH_FLAGS_USE UpdateFlags = 0
	// \brief if set, will mark this as an app and set it to 'latest' in partition table
	UpdateFlags_FLASH_FLAGS_SET_LATEST_APP UpdateFlags = 1
	// \brief if set, user app will be stopped before flashing
	UpdateFlags_FLASH_FLAGS_STOP_USERAPP UpdateFlags = 2
	// \brief if set, user app will start after flashing
	UpdateFlags_FLASH_FLAGS_START_USERAPP UpdateFlags = 3
	// \brief if set, will mark this as a user app and update config to execute this
	UpdateFlags_FLASH_FLAGS_SET_LATEST_USERAPP UpdateFlags = 4
	// \brief if set, will erase section of flash in one go prior to receiving data. otherwise, will flash each sector as it is received
	UpdateFlags_FLASH_FLAGS_PRE_ERASE UpdateFlags = 5
	// \brief if set, return baseaddress of available slot for userapp instead of firmware
	UpdateFlags_FLASH_FLAGS_RETURN_APP_SLOT UpdateFlags = 6
)

var UpdateFlags_name = map[int32]string{
	0: "FLASH_FLAGS_USE",
	1: "FLASH_FLAGS_SET_LATEST_APP",
	2: "FLASH_FLAGS_STOP_USERAPP",
	3: "FLASH_FLAGS_START_USERAPP",
	4: "FLASH_FLAGS_SET_LATEST_USERAPP",
	5: "FLASH_FLAGS_PRE_ERASE",
	6: "FLASH_FLAGS_RETURN_APP_SLOT",
}
var UpdateFlags_value = map[string]int32{
	"FLASH_FLAGS_USE":                0,
	"FLASH_FLAGS_SET_LATEST_APP":     1,
	"FLASH_FLAGS_STOP_USERAPP":       2,
	"FLASH_FLAGS_START_USERAPP":      3,
	"FLASH_FLAGS_SET_LATEST_USERAPP": 4,
	"FLASH_FLAGS_PRE_ERASE":          5,
	"FLASH_FLAGS_RETURN_APP_SLOT":    6,
}

func (x UpdateFlags) String() string {
	return proto.EnumName(UpdateFlags_name, int32(x))
}
func (UpdateFlags) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// a database proto
type ActiveUpdate struct {
	ID               uint64                      `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ModuleID         uint64                      `protobuf:"varint,2,opt,name=ModuleID" json:"ModuleID,omitempty"`
	Created          uint32                      `protobuf:"varint,3,opt,name=Created" json:"Created,omitempty"`
	BuildNumber      uint32                      `protobuf:"varint,4,opt,name=BuildNumber" json:"BuildNumber,omitempty"`
	Repository       uint64                      `protobuf:"varint,5,opt,name=Repository" json:"Repository,omitempty"`
	RequestedBy      string                      `protobuf:"bytes,6,opt,name=RequestedBy" json:"RequestedBy,omitempty"`
	Context          []byte                      `protobuf:"bytes,7,opt,name=Context,proto3" json:"Context,omitempty"`
	Completed        uint32                      `protobuf:"varint,8,opt,name=Completed" json:"Completed,omitempty"`
	GitRepo          *gitserver.SourceRepository `protobuf:"bytes,9,opt,name=GitRepo" json:"GitRepo,omitempty"`
	ServiceTriggered bool                        `protobuf:"varint,10,opt,name=ServiceTriggered" json:"ServiceTriggered,omitempty"`
}

func (m *ActiveUpdate) Reset()                    { *m = ActiveUpdate{} }
func (m *ActiveUpdate) String() string            { return proto.CompactTextString(m) }
func (*ActiveUpdate) ProtoMessage()               {}
func (*ActiveUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ActiveUpdate) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ActiveUpdate) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *ActiveUpdate) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *ActiveUpdate) GetBuildNumber() uint32 {
	if m != nil {
		return m.BuildNumber
	}
	return 0
}

func (m *ActiveUpdate) GetRepository() uint64 {
	if m != nil {
		return m.Repository
	}
	return 0
}

func (m *ActiveUpdate) GetRequestedBy() string {
	if m != nil {
		return m.RequestedBy
	}
	return ""
}

func (m *ActiveUpdate) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ActiveUpdate) GetCompleted() uint32 {
	if m != nil {
		return m.Completed
	}
	return 0
}

func (m *ActiveUpdate) GetGitRepo() *gitserver.SourceRepository {
	if m != nil {
		return m.GitRepo
	}
	return nil
}

func (m *ActiveUpdate) GetServiceTriggered() bool {
	if m != nil {
		return m.ServiceTriggered
	}
	return false
}

// a database proto (a tracker)
type Tracker struct {
	ID            uint64        `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	State         uint32        `protobuf:"varint,2,opt,name=State" json:"State,omitempty"`
	FD            uint32        `protobuf:"varint,3,opt,name=FD" json:"FD,omitempty"`
	ModuleID      uint64        `protobuf:"varint,4,opt,name=ModuleID" json:"ModuleID,omitempty"`
	ActiveUpdate  *ActiveUpdate `protobuf:"bytes,5,opt,name=ActiveUpdate" json:"ActiveUpdate,omitempty"`
	Context       []byte        `protobuf:"bytes,6,opt,name=Context,proto3" json:"Context,omitempty"`
	UserID        string        `protobuf:"bytes,7,opt,name=UserID" json:"UserID,omitempty"`
	Created       uint32        `protobuf:"varint,8,opt,name=Created" json:"Created,omitempty"`
	Started       uint32        `protobuf:"varint,9,opt,name=Started" json:"Started,omitempty"`
	LastReply     uint32        `protobuf:"varint,10,opt,name=LastReply" json:"LastReply,omitempty"`
	ActualAddress uint64        `protobuf:"varint,11,opt,name=ActualAddress" json:"ActualAddress,omitempty"`
}

func (m *Tracker) Reset()                    { *m = Tracker{} }
func (m *Tracker) String() string            { return proto.CompactTextString(m) }
func (*Tracker) ProtoMessage()               {}
func (*Tracker) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Tracker) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Tracker) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *Tracker) GetFD() uint32 {
	if m != nil {
		return m.FD
	}
	return 0
}

func (m *Tracker) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *Tracker) GetActiveUpdate() *ActiveUpdate {
	if m != nil {
		return m.ActiveUpdate
	}
	return nil
}

func (m *Tracker) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Tracker) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *Tracker) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Tracker) GetStarted() uint32 {
	if m != nil {
		return m.Started
	}
	return 0
}

func (m *Tracker) GetLastReply() uint32 {
	if m != nil {
		return m.LastReply
	}
	return 0
}

func (m *Tracker) GetActualAddress() uint64 {
	if m != nil {
		return m.ActualAddress
	}
	return 0
}

// a database proto - an "Upgrade" might have multiple attempts, one of these
// protos for each attempt
type UpdateInfo struct {
	ID            uint64        `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UpgradeID     uint64        `protobuf:"varint,2,opt,name=UpgradeID" json:"UpgradeID,omitempty"`
	FirstPacket   uint32        `protobuf:"varint,3,opt,name=FirstPacket" json:"FirstPacket,omitempty"`
	FirstResponse uint32        `protobuf:"varint,4,opt,name=FirstResponse" json:"FirstResponse,omitempty"`
	LastPacket    uint32        `protobuf:"varint,5,opt,name=LastPacket" json:"LastPacket,omitempty"`
	LastResponse  uint32        `protobuf:"varint,6,opt,name=LastResponse" json:"LastResponse,omitempty"`
	Result        UpgradeResult `protobuf:"varint,7,opt,name=Result,enum=scupdate.UpgradeResult" json:"Result,omitempty"`
	SizeBytes     uint32        `protobuf:"varint,8,opt,name=SizeBytes" json:"SizeBytes,omitempty"`
	DoneBytes     uint32        `protobuf:"varint,9,opt,name=DoneBytes" json:"DoneBytes,omitempty"`
	ErrorCode     uint32        `protobuf:"varint,10,opt,name=ErrorCode" json:"ErrorCode,omitempty"`
	ErrorMessage  string        `protobuf:"bytes,11,opt,name=ErrorMessage" json:"ErrorMessage,omitempty"`
	Occured       uint32        `protobuf:"varint,12,opt,name=Occured" json:"Occured,omitempty"`
}

func (m *UpdateInfo) Reset()                    { *m = UpdateInfo{} }
func (m *UpdateInfo) String() string            { return proto.CompactTextString(m) }
func (*UpdateInfo) ProtoMessage()               {}
func (*UpdateInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UpdateInfo) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UpdateInfo) GetUpgradeID() uint64 {
	if m != nil {
		return m.UpgradeID
	}
	return 0
}

func (m *UpdateInfo) GetFirstPacket() uint32 {
	if m != nil {
		return m.FirstPacket
	}
	return 0
}

func (m *UpdateInfo) GetFirstResponse() uint32 {
	if m != nil {
		return m.FirstResponse
	}
	return 0
}

func (m *UpdateInfo) GetLastPacket() uint32 {
	if m != nil {
		return m.LastPacket
	}
	return 0
}

func (m *UpdateInfo) GetLastResponse() uint32 {
	if m != nil {
		return m.LastResponse
	}
	return 0
}

func (m *UpdateInfo) GetResult() UpgradeResult {
	if m != nil {
		return m.Result
	}
	return UpgradeResult_PENDING
}

func (m *UpdateInfo) GetSizeBytes() uint32 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *UpdateInfo) GetDoneBytes() uint32 {
	if m != nil {
		return m.DoneBytes
	}
	return 0
}

func (m *UpdateInfo) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *UpdateInfo) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *UpdateInfo) GetOccured() uint32 {
	if m != nil {
		return m.Occured
	}
	return 0
}

type UpdateRequest struct {
	ModuleID    uint64 `protobuf:"varint,1,opt,name=ModuleID" json:"ModuleID,omitempty"`
	BuildNumber uint32 `protobuf:"varint,2,opt,name=BuildNumber" json:"BuildNumber,omitempty"`
	Repository  uint32 `protobuf:"varint,3,opt,name=Repository" json:"Repository,omitempty"`
}

func (m *UpdateRequest) Reset()                    { *m = UpdateRequest{} }
func (m *UpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateRequest) ProtoMessage()               {}
func (*UpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *UpdateRequest) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *UpdateRequest) GetBuildNumber() uint32 {
	if m != nil {
		return m.BuildNumber
	}
	return 0
}

func (m *UpdateRequest) GetRepository() uint32 {
	if m != nil {
		return m.Repository
	}
	return 0
}

type BlobUpdateRequest struct {
	ModuleID      uint64   `protobuf:"varint,1,opt,name=ModuleID" json:"ModuleID,omitempty"`
	Blob          []byte   `protobuf:"bytes,2,opt,name=Blob,proto3" json:"Blob,omitempty"`
	IsLoader      bool     `protobuf:"varint,3,opt,name=IsLoader" json:"IsLoader,omitempty"`
	Address       uint32   `protobuf:"varint,4,opt,name=Address" json:"Address,omitempty"`
	Prerequisites []*Match `protobuf:"bytes,5,rep,name=Prerequisites" json:"Prerequisites,omitempty"`
}

func (m *BlobUpdateRequest) Reset()                    { *m = BlobUpdateRequest{} }
func (m *BlobUpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*BlobUpdateRequest) ProtoMessage()               {}
func (*BlobUpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *BlobUpdateRequest) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *BlobUpdateRequest) GetBlob() []byte {
	if m != nil {
		return m.Blob
	}
	return nil
}

func (m *BlobUpdateRequest) GetIsLoader() bool {
	if m != nil {
		return m.IsLoader
	}
	return false
}

func (m *BlobUpdateRequest) GetAddress() uint32 {
	if m != nil {
		return m.Address
	}
	return 0
}

func (m *BlobUpdateRequest) GetPrerequisites() []*Match {
	if m != nil {
		return m.Prerequisites
	}
	return nil
}

// check if a given version exists at a specific address, if not decline update
type Match struct {
	MinimumVersion uint64 `protobuf:"varint,1,opt,name=MinimumVersion" json:"MinimumVersion,omitempty"`
	MaximumVersion uint64 `protobuf:"varint,2,opt,name=MaximumVersion" json:"MaximumVersion,omitempty"`
	BaseAddress    uint32 `protobuf:"varint,3,opt,name=BaseAddress" json:"BaseAddress,omitempty"`
	Repository     uint64 `protobuf:"varint,4,opt,name=Repository" json:"Repository,omitempty"`
	NotMatch       bool   `protobuf:"varint,5,opt,name=NotMatch" json:"NotMatch,omitempty"`
	Alternative    *Match `protobuf:"bytes,6,opt,name=Alternative" json:"Alternative,omitempty"`
}

func (m *Match) Reset()                    { *m = Match{} }
func (m *Match) String() string            { return proto.CompactTextString(m) }
func (*Match) ProtoMessage()               {}
func (*Match) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Match) GetMinimumVersion() uint64 {
	if m != nil {
		return m.MinimumVersion
	}
	return 0
}

func (m *Match) GetMaximumVersion() uint64 {
	if m != nil {
		return m.MaximumVersion
	}
	return 0
}

func (m *Match) GetBaseAddress() uint32 {
	if m != nil {
		return m.BaseAddress
	}
	return 0
}

func (m *Match) GetRepository() uint64 {
	if m != nil {
		return m.Repository
	}
	return 0
}

func (m *Match) GetNotMatch() bool {
	if m != nil {
		return m.NotMatch
	}
	return false
}

func (m *Match) GetAlternative() *Match {
	if m != nil {
		return m.Alternative
	}
	return nil
}

type UpdateResponse struct {
	UpdateID uint64 `protobuf:"varint,1,opt,name=UpdateID" json:"UpdateID,omitempty"`
}

func (m *UpdateResponse) Reset()                    { *m = UpdateResponse{} }
func (m *UpdateResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateResponse) ProtoMessage()               {}
func (*UpdateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *UpdateResponse) GetUpdateID() uint64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

type ComReceived struct {
	Command *singingcat.Command `protobuf:"bytes,1,opt,name=Command" json:"Command,omitempty"`
}

func (m *ComReceived) Reset()                    { *m = ComReceived{} }
func (m *ComReceived) String() string            { return proto.CompactTextString(m) }
func (*ComReceived) ProtoMessage()               {}
func (*ComReceived) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ComReceived) GetCommand() *singingcat.Command {
	if m != nil {
		return m.Command
	}
	return nil
}

type UpdateStatus struct {
	ID        uint64                `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Created   uint32                `protobuf:"varint,2,opt,name=Created" json:"Created,omitempty"`
	Status    uint32                `protobuf:"varint,3,opt,name=Status" json:"Status,omitempty"`
	End       uint32                `protobuf:"varint,4,opt,name=End" json:"End,omitempty"`
	LastReply uint32                `protobuf:"varint,5,opt,name=LastReply" json:"LastReply,omitempty"`
	Finished  bool                  `protobuf:"varint,6,opt,name=Finished" json:"Finished,omitempty"`
	Failed    bool                  `protobuf:"varint,7,opt,name=Failed" json:"Failed,omitempty"`
	ErrorMsg  string                `protobuf:"bytes,8,opt,name=ErrorMsg" json:"ErrorMsg,omitempty"`
	TotalSize uint64                `protobuf:"varint,9,opt,name=TotalSize" json:"TotalSize,omitempty"`
	TotalSent uint64                `protobuf:"varint,10,opt,name=TotalSent" json:"TotalSent,omitempty"`
	Module    *singingcat.ModuleRef `protobuf:"bytes,11,opt,name=Module" json:"Module,omitempty"`
	Tracker   *Tracker              `protobuf:"bytes,12,opt,name=Tracker" json:"Tracker,omitempty"`
}

func (m *UpdateStatus) Reset()                    { *m = UpdateStatus{} }
func (m *UpdateStatus) String() string            { return proto.CompactTextString(m) }
func (*UpdateStatus) ProtoMessage()               {}
func (*UpdateStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *UpdateStatus) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UpdateStatus) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *UpdateStatus) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *UpdateStatus) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *UpdateStatus) GetLastReply() uint32 {
	if m != nil {
		return m.LastReply
	}
	return 0
}

func (m *UpdateStatus) GetFinished() bool {
	if m != nil {
		return m.Finished
	}
	return false
}

func (m *UpdateStatus) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

func (m *UpdateStatus) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

func (m *UpdateStatus) GetTotalSize() uint64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *UpdateStatus) GetTotalSent() uint64 {
	if m != nil {
		return m.TotalSent
	}
	return 0
}

func (m *UpdateStatus) GetModule() *singingcat.ModuleRef {
	if m != nil {
		return m.Module
	}
	return nil
}

func (m *UpdateStatus) GetTracker() *Tracker {
	if m != nil {
		return m.Tracker
	}
	return nil
}

type UpdateStatusList struct {
	Status []*UpdateStatus `protobuf:"bytes,1,rep,name=Status" json:"Status,omitempty"`
}

func (m *UpdateStatusList) Reset()                    { *m = UpdateStatusList{} }
func (m *UpdateStatusList) String() string            { return proto.CompactTextString(m) }
func (*UpdateStatusList) ProtoMessage()               {}
func (*UpdateStatusList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *UpdateStatusList) GetStatus() []*UpdateStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type FirmwareInfo struct {
	Module     *singingcat.ModuleRef `protobuf:"bytes,1,opt,name=Module" json:"Module,omitempty"`
	Repository uint64                `protobuf:"varint,2,opt,name=Repository" json:"Repository,omitempty"`
	Version    uint32                `protobuf:"varint,3,opt,name=Version" json:"Version,omitempty"`
}

func (m *FirmwareInfo) Reset()                    { *m = FirmwareInfo{} }
func (m *FirmwareInfo) String() string            { return proto.CompactTextString(m) }
func (*FirmwareInfo) ProtoMessage()               {}
func (*FirmwareInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *FirmwareInfo) GetModule() *singingcat.ModuleRef {
	if m != nil {
		return m.Module
	}
	return nil
}

func (m *FirmwareInfo) GetRepository() uint64 {
	if m != nil {
		return m.Repository
	}
	return 0
}

func (m *FirmwareInfo) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

// a history of upgrades and outcomes for a given module
type HistoryList struct {
	Histories []*History `protobuf:"bytes,1,rep,name=Histories" json:"Histories,omitempty"`
}

func (m *HistoryList) Reset()                    { *m = HistoryList{} }
func (m *HistoryList) String() string            { return proto.CompactTextString(m) }
func (*HistoryList) ProtoMessage()               {}
func (*HistoryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *HistoryList) GetHistories() []*History {
	if m != nil {
		return m.Histories
	}
	return nil
}

// one upgrade
type History struct {
	Update *ActiveUpdate `protobuf:"bytes,1,opt,name=Update" json:"Update,omitempty"`
	Infos  []*UpdateInfo `protobuf:"bytes,2,rep,name=Infos" json:"Infos,omitempty"`
}

func (m *History) Reset()                    { *m = History{} }
func (m *History) String() string            { return proto.CompactTextString(m) }
func (*History) ProtoMessage()               {}
func (*History) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *History) GetUpdate() *ActiveUpdate {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *History) GetInfos() []*UpdateInfo {
	if m != nil {
		return m.Infos
	}
	return nil
}

type UpgradeRepoRequest struct {
	Repository uint32 `protobuf:"varint,1,opt,name=Repository" json:"Repository,omitempty"`
}

func (m *UpgradeRepoRequest) Reset()                    { *m = UpgradeRepoRequest{} }
func (m *UpgradeRepoRequest) String() string            { return proto.CompactTextString(m) }
func (*UpgradeRepoRequest) ProtoMessage()               {}
func (*UpgradeRepoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *UpgradeRepoRequest) GetRepository() uint32 {
	if m != nil {
		return m.Repository
	}
	return 0
}

type UpdateFromRepoRequest struct {
	ModuleID       uint64   `protobuf:"varint,1,opt,name=ModuleID" json:"ModuleID,omitempty"`
	BuildNumber    uint64   `protobuf:"varint,2,opt,name=BuildNumber" json:"BuildNumber,omitempty"`
	Repository     uint64   `protobuf:"varint,3,opt,name=Repository" json:"Repository,omitempty"`
	IsLoader       bool     `protobuf:"varint,4,opt,name=IsLoader" json:"IsLoader,omitempty"`
	Address        uint32   `protobuf:"varint,5,opt,name=Address" json:"Address,omitempty"`
	FilenameInRepo string   `protobuf:"bytes,6,opt,name=FilenameInRepo" json:"FilenameInRepo,omitempty"`
	Prerequisites  []*Match `protobuf:"bytes,7,rep,name=Prerequisites" json:"Prerequisites,omitempty"`
}

func (m *UpdateFromRepoRequest) Reset()                    { *m = UpdateFromRepoRequest{} }
func (m *UpdateFromRepoRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateFromRepoRequest) ProtoMessage()               {}
func (*UpdateFromRepoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *UpdateFromRepoRequest) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *UpdateFromRepoRequest) GetBuildNumber() uint64 {
	if m != nil {
		return m.BuildNumber
	}
	return 0
}

func (m *UpdateFromRepoRequest) GetRepository() uint64 {
	if m != nil {
		return m.Repository
	}
	return 0
}

func (m *UpdateFromRepoRequest) GetIsLoader() bool {
	if m != nil {
		return m.IsLoader
	}
	return false
}

func (m *UpdateFromRepoRequest) GetAddress() uint32 {
	if m != nil {
		return m.Address
	}
	return 0
}

func (m *UpdateFromRepoRequest) GetFilenameInRepo() string {
	if m != nil {
		return m.FilenameInRepo
	}
	return ""
}

func (m *UpdateFromRepoRequest) GetPrerequisites() []*Match {
	if m != nil {
		return m.Prerequisites
	}
	return nil
}

func init() {
	proto.RegisterType((*ActiveUpdate)(nil), "scupdate.ActiveUpdate")
	proto.RegisterType((*Tracker)(nil), "scupdate.Tracker")
	proto.RegisterType((*UpdateInfo)(nil), "scupdate.UpdateInfo")
	proto.RegisterType((*UpdateRequest)(nil), "scupdate.UpdateRequest")
	proto.RegisterType((*BlobUpdateRequest)(nil), "scupdate.BlobUpdateRequest")
	proto.RegisterType((*Match)(nil), "scupdate.Match")
	proto.RegisterType((*UpdateResponse)(nil), "scupdate.UpdateResponse")
	proto.RegisterType((*ComReceived)(nil), "scupdate.ComReceived")
	proto.RegisterType((*UpdateStatus)(nil), "scupdate.UpdateStatus")
	proto.RegisterType((*UpdateStatusList)(nil), "scupdate.UpdateStatusList")
	proto.RegisterType((*FirmwareInfo)(nil), "scupdate.FirmwareInfo")
	proto.RegisterType((*HistoryList)(nil), "scupdate.HistoryList")
	proto.RegisterType((*History)(nil), "scupdate.History")
	proto.RegisterType((*UpgradeRepoRequest)(nil), "scupdate.UpgradeRepoRequest")
	proto.RegisterType((*UpdateFromRepoRequest)(nil), "scupdate.UpdateFromRepoRequest")
	proto.RegisterEnum("scupdate.UpgradeResult", UpgradeResult_name, UpgradeResult_value)
	proto.RegisterEnum("scupdate.UpdateFlags", UpdateFlags_name, UpdateFlags_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SCUpdateService service

type SCUpdateServiceClient interface {
	// called by scserver with updates from module re streams
	StreamCommandReceived(ctx context.Context, in *ComReceived, opts ...grpc.CallOption) (*common.Void, error)
	// DEPRECATED see UpdateModuleFromRepo update a module
	UpdateModule(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error)
	// update a module
	UpdateModuleFromBlob(ctx context.Context, in *BlobUpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error)
	// misnomer, this actually GETS an update status for a module
	UpdateStatus(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*UpdateStatusList, error)
	// called after a statusupdate/firmware information was received
	CheckFirmware(ctx context.Context, in *FirmwareInfo, opts ...grpc.CallOption) (*common.Void, error)
	// abort a current firmware update
	AbortUpdate(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error)
	// list all current updates
	ListUpdates(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*UpdateStatusList, error)
	// list recent update history for a given module
	HistoryForModule(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*HistoryList, error)
	// trigger upgrades for all that are upgradeable (and online atm) (for a given
	// repo)
	UpgradeRepo(ctx context.Context, in *UpgradeRepoRequest, opts ...grpc.CallOption) (*common.Void, error)
	// cancel all active upgrades
	CancelAll(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error)
	// callback for stream setup commands
	SCApplyCallback(ctx context.Context, in *scapply.CallbackResult, opts ...grpc.CallOption) (*common.Void, error)
	// update from any file in any repo with more details
	UpdateModuleFromRepo(ctx context.Context, in *UpdateFromRepoRequest, opts ...grpc.CallOption) (*UpdateResponse, error)
}

type sCUpdateServiceClient struct {
	cc *grpc.ClientConn
}

func NewSCUpdateServiceClient(cc *grpc.ClientConn) SCUpdateServiceClient {
	return &sCUpdateServiceClient{cc}
}

func (c *sCUpdateServiceClient) StreamCommandReceived(ctx context.Context, in *ComReceived, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/StreamCommandReceived", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) UpdateModule(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error) {
	out := new(UpdateResponse)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/UpdateModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) UpdateModuleFromBlob(ctx context.Context, in *BlobUpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error) {
	out := new(UpdateResponse)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/UpdateModuleFromBlob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) UpdateStatus(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*UpdateStatusList, error) {
	out := new(UpdateStatusList)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/UpdateStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) CheckFirmware(ctx context.Context, in *FirmwareInfo, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/CheckFirmware", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) AbortUpdate(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/AbortUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) ListUpdates(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*UpdateStatusList, error) {
	out := new(UpdateStatusList)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/ListUpdates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) HistoryForModule(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*HistoryList, error) {
	out := new(HistoryList)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/HistoryForModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) UpgradeRepo(ctx context.Context, in *UpgradeRepoRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/UpgradeRepo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) CancelAll(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/CancelAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) SCApplyCallback(ctx context.Context, in *scapply.CallbackResult, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/SCApplyCallback", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) UpdateModuleFromRepo(ctx context.Context, in *UpdateFromRepoRequest, opts ...grpc.CallOption) (*UpdateResponse, error) {
	out := new(UpdateResponse)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/UpdateModuleFromRepo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SCUpdateService service

type SCUpdateServiceServer interface {
	// called by scserver with updates from module re streams
	StreamCommandReceived(context.Context, *ComReceived) (*common.Void, error)
	// DEPRECATED see UpdateModuleFromRepo update a module
	UpdateModule(context.Context, *UpdateRequest) (*UpdateResponse, error)
	// update a module
	UpdateModuleFromBlob(context.Context, *BlobUpdateRequest) (*UpdateResponse, error)
	// misnomer, this actually GETS an update status for a module
	UpdateStatus(context.Context, *singingcat.ModuleRef) (*UpdateStatusList, error)
	// called after a statusupdate/firmware information was received
	CheckFirmware(context.Context, *FirmwareInfo) (*common.Void, error)
	// abort a current firmware update
	AbortUpdate(context.Context, *singingcat.ModuleRef) (*common.Void, error)
	// list all current updates
	ListUpdates(context.Context, *common.Void) (*UpdateStatusList, error)
	// list recent update history for a given module
	HistoryForModule(context.Context, *singingcat.ModuleRef) (*HistoryList, error)
	// trigger upgrades for all that are upgradeable (and online atm) (for a given
	// repo)
	UpgradeRepo(context.Context, *UpgradeRepoRequest) (*common.Void, error)
	// cancel all active upgrades
	CancelAll(context.Context, *common.Void) (*common.Void, error)
	// callback for stream setup commands
	SCApplyCallback(context.Context, *scapply.CallbackResult) (*common.Void, error)
	// update from any file in any repo with more details
	UpdateModuleFromRepo(context.Context, *UpdateFromRepoRequest) (*UpdateResponse, error)
}

func RegisterSCUpdateServiceServer(s *grpc.Server, srv SCUpdateServiceServer) {
	s.RegisterService(&_SCUpdateService_serviceDesc, srv)
}

func _SCUpdateService_StreamCommandReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComReceived)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).StreamCommandReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/StreamCommandReceived",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).StreamCommandReceived(ctx, req.(*ComReceived))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_UpdateModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).UpdateModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/UpdateModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).UpdateModule(ctx, req.(*UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_UpdateModuleFromBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).UpdateModuleFromBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/UpdateModuleFromBlob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).UpdateModuleFromBlob(ctx, req.(*BlobUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/UpdateStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).UpdateStatus(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_CheckFirmware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FirmwareInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).CheckFirmware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/CheckFirmware",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).CheckFirmware(ctx, req.(*FirmwareInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_AbortUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).AbortUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/AbortUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).AbortUpdate(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_ListUpdates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).ListUpdates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/ListUpdates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).ListUpdates(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_HistoryForModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).HistoryForModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/HistoryForModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).HistoryForModule(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_UpgradeRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).UpgradeRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/UpgradeRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).UpgradeRepo(ctx, req.(*UpgradeRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_CancelAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).CancelAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/CancelAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).CancelAll(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_SCApplyCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(scapply.CallbackResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).SCApplyCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/SCApplyCallback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).SCApplyCallback(ctx, req.(*scapply.CallbackResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_UpdateModuleFromRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFromRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).UpdateModuleFromRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/UpdateModuleFromRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).UpdateModuleFromRepo(ctx, req.(*UpdateFromRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SCUpdateService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "scupdate.SCUpdateService",
	HandlerType: (*SCUpdateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StreamCommandReceived",
			Handler:    _SCUpdateService_StreamCommandReceived_Handler,
		},
		{
			MethodName: "UpdateModule",
			Handler:    _SCUpdateService_UpdateModule_Handler,
		},
		{
			MethodName: "UpdateModuleFromBlob",
			Handler:    _SCUpdateService_UpdateModuleFromBlob_Handler,
		},
		{
			MethodName: "UpdateStatus",
			Handler:    _SCUpdateService_UpdateStatus_Handler,
		},
		{
			MethodName: "CheckFirmware",
			Handler:    _SCUpdateService_CheckFirmware_Handler,
		},
		{
			MethodName: "AbortUpdate",
			Handler:    _SCUpdateService_AbortUpdate_Handler,
		},
		{
			MethodName: "ListUpdates",
			Handler:    _SCUpdateService_ListUpdates_Handler,
		},
		{
			MethodName: "HistoryForModule",
			Handler:    _SCUpdateService_HistoryForModule_Handler,
		},
		{
			MethodName: "UpgradeRepo",
			Handler:    _SCUpdateService_UpgradeRepo_Handler,
		},
		{
			MethodName: "CancelAll",
			Handler:    _SCUpdateService_CancelAll_Handler,
		},
		{
			MethodName: "SCApplyCallback",
			Handler:    _SCUpdateService_SCApplyCallback_Handler,
		},
		{
			MethodName: "UpdateModuleFromRepo",
			Handler:    _SCUpdateService_UpdateModuleFromRepo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.singingcat.net/apis/scupdate/scupdate.proto",
}

func init() { proto.RegisterFile("golang.singingcat.net/apis/scupdate/scupdate.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1593 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x57, 0xcd, 0x72, 0xdb, 0xc8,
	0x11, 0x36, 0x28, 0xfe, 0x36, 0x29, 0x89, 0x1e, 0x5b, 0x32, 0x44, 0x2b, 0x36, 0x8b, 0x89, 0x1d,
	0x95, 0x12, 0x53, 0x09, 0x63, 0x3b, 0x49, 0x95, 0x2b, 0x15, 0x88, 0x04, 0x6d, 0xa6, 0x28, 0x89,
	0x19, 0x50, 0xbe, 0xaa, 0x20, 0x60, 0x4c, 0xa3, 0x0c, 0x02, 0xf4, 0x60, 0x28, 0x5b, 0x7b, 0xf4,
	0x71, 0x2f, 0x7b, 0xdf, 0xe3, 0x1e, 0xf7, 0xb4, 0xef, 0xb2, 0x0f, 0xb0, 0x57, 0xbf, 0xc3, 0x5e,
	0xb6, 0x66, 0x30, 0xf8, 0xa5, 0x24, 0x7b, 0x4f, 0x40, 0xff, 0xcd, 0xf4, 0x7c, 0xdd, 0xfd, 0x0d,
	0x00, 0xbd, 0x99, 0xef, 0x9a, 0xde, 0xac, 0x1b, 0x38, 0xde, 0xcc, 0xf1, 0x66, 0x96, 0xc9, 0xba,
	0x1e, 0x61, 0x07, 0xe6, 0xc2, 0x09, 0x0e, 0x02, 0x6b, 0xb9, 0xb0, 0x4d, 0x46, 0xe2, 0x97, 0xee,
	0x82, 0xfa, 0xcc, 0x47, 0xd5, 0x48, 0x6e, 0x75, 0x65, 0xb4, 0xe5, 0x7b, 0xd4, 0xb4, 0x3f, 0xf8,
	0xbe, 0x9d, 0x44, 0x5b, 0xfe, 0x7c, 0xee, 0x7b, 0xf2, 0x11, 0x46, 0xb6, 0x9e, 0xde, 0xe0, 0x3f,
	0x73, 0x58, 0x40, 0xe8, 0x05, 0xa1, 0xc9, 0x9b, 0x8c, 0x7a, 0x7e, 0x53, 0x8e, 0xb1, 0x2e, 0xf5,
	0x2a, 0xe3, 0xfe, 0x76, 0xe3, 0xd9, 0xcc, 0xc5, 0xc2, 0xbd, 0x8c, 0x9e, 0x61, 0x44, 0xe7, 0xe7,
	0x02, 0x34, 0x34, 0x8b, 0x39, 0x17, 0xe4, 0x54, 0x1c, 0x10, 0x6d, 0x40, 0x61, 0x34, 0x50, 0x95,
	0xb6, 0xb2, 0x57, 0xc4, 0x85, 0xd1, 0x00, 0xb5, 0xa0, 0x7a, 0xe4, 0xdb, 0x4b, 0x97, 0x8c, 0x06,
	0x6a, 0x41, 0x68, 0x63, 0x19, 0xa9, 0x50, 0xe9, 0x53, 0x62, 0x32, 0x62, 0xab, 0x6b, 0x6d, 0x65,
	0x6f, 0x1d, 0x47, 0x22, 0x6a, 0x43, 0xfd, 0x70, 0xe9, 0xb8, 0xf6, 0xf1, 0x72, 0x7e, 0x4e, 0xa8,
	0x5a, 0x14, 0xd6, 0xb4, 0x0a, 0x3d, 0x00, 0xc0, 0x64, 0xe1, 0x07, 0x0e, 0xf3, 0xe9, 0xa5, 0x5a,
	0x12, 0x2b, 0xa7, 0x34, 0x7c, 0x05, 0x4c, 0xde, 0x2f, 0x49, 0xc0, 0x88, 0x7d, 0x78, 0xa9, 0x96,
	0xdb, 0xca, 0x5e, 0x0d, 0xa7, 0x55, 0x62, 0x77, 0xdf, 0x63, 0xe4, 0x23, 0x53, 0x2b, 0x6d, 0x65,
	0xaf, 0x81, 0x23, 0x11, 0xed, 0x42, 0xad, 0xef, 0xcf, 0x17, 0x2e, 0xe1, 0x99, 0x55, 0xc5, 0xde,
	0x89, 0x02, 0x3d, 0x83, 0xca, 0x4b, 0x87, 0xf1, 0xad, 0xd4, 0x5a, 0x5b, 0xd9, 0xab, 0xf7, 0xee,
	0x77, 0x13, 0xfc, 0x0d, 0x7f, 0x49, 0x2d, 0x92, 0xe4, 0x81, 0x23, 0x5f, 0xb4, 0x0f, 0x4d, 0x83,
	0xd0, 0x0b, 0xc7, 0x22, 0x53, 0xea, 0xcc, 0x66, 0x84, 0x12, 0x5b, 0x85, 0xb6, 0xb2, 0x57, 0xc5,
	0x2b, 0xfa, 0xce, 0xe7, 0x02, 0x54, 0xa6, 0xd4, 0xb4, 0xde, 0x11, 0xba, 0x02, 0xe8, 0x5d, 0x28,
	0x19, 0xcc, 0x64, 0x44, 0xa0, 0xb9, 0x8e, 0x43, 0x81, 0x7b, 0x0d, 0x07, 0x12, 0xc5, 0xc2, 0x30,
	0x0b, 0x7b, 0x31, 0x07, 0xbb, 0x99, 0x2d, 0x99, 0x00, 0xaf, 0xde, 0xdb, 0xee, 0xc6, 0x4d, 0x9b,
	0xb6, 0x1e, 0x3e, 0xfa, 0xfe, 0xd3, 0x4e, 0x79, 0xe9, 0x78, 0xec, 0xf9, 0xd3, 0x1f, 0x3e, 0xed,
	0x6c, 0x9a, 0xc2, 0x26, 0x1d, 0x1d, 0xfb, 0xc7, 0x4f, 0x3b, 0x45, 0x46, 0x97, 0x04, 0x67, 0xbb,
	0x20, 0x85, 0x6d, 0x39, 0x8b, 0xed, 0x36, 0x94, 0x4f, 0x03, 0x42, 0x47, 0x03, 0x01, 0x7a, 0x0d,
	0x4b, 0x29, 0xdd, 0x0b, 0xd5, 0x6c, 0x2f, 0xa8, 0x50, 0x31, 0x98, 0x49, 0xb9, 0xa5, 0x16, 0x5a,
	0xa4, 0xc8, 0xeb, 0x34, 0x36, 0x03, 0x0e, 0xaf, 0x7b, 0x29, 0xb0, 0x5c, 0xc7, 0x89, 0x02, 0xfd,
	0x09, 0xd6, 0x35, 0x8b, 0x2d, 0x4d, 0x57, 0xb3, 0x6d, 0x4a, 0x82, 0x40, 0xad, 0x0b, 0x1c, 0xb2,
	0xca, 0xce, 0x77, 0x6b, 0x00, 0x61, 0xd2, 0x23, 0xef, 0x8d, 0xbf, 0x82, 0xf6, 0x2e, 0xd4, 0x4e,
	0x17, 0x33, 0x6a, 0xda, 0x49, 0xff, 0x26, 0x0a, 0xde, 0x64, 0x43, 0x87, 0x06, 0x6c, 0xc2, 0x4b,
	0xc5, 0x24, 0xfc, 0x69, 0x15, 0x4f, 0x42, 0x88, 0x98, 0x04, 0x0b, 0xdf, 0x0b, 0x88, 0x6c, 0xe5,
	0xac, 0x92, 0x37, 0x33, 0xcf, 0x5b, 0x2e, 0x53, 0x12, 0x2e, 0x29, 0x0d, 0xea, 0x40, 0x23, 0x3c,
	0x97, 0x5c, 0xa4, 0x2c, 0x3c, 0x32, 0x3a, 0x74, 0x00, 0x65, 0x4c, 0x82, 0xa5, 0x1b, 0x76, 0xf3,
	0x46, 0xef, 0x5e, 0x52, 0x4f, 0x99, 0x70, 0x68, 0xc6, 0xd2, 0x8d, 0x1f, 0xcd, 0x70, 0xbe, 0x21,
	0x87, 0x97, 0x8c, 0x04, 0x51, 0x97, 0xc7, 0x0a, 0x6e, 0x1d, 0xf8, 0x9e, 0xb4, 0x86, 0xb8, 0x27,
	0x0a, 0x6e, 0xd5, 0x29, 0xf5, 0x69, 0xdf, 0xb7, 0x49, 0x84, 0x7c, 0xac, 0xe0, 0xe9, 0x0a, 0xe1,
	0x88, 0x04, 0x81, 0x39, 0x23, 0x02, 0xf8, 0x1a, 0xce, 0xe8, 0x78, 0x55, 0x4f, 0x2c, 0x6b, 0xc9,
	0xa7, 0xa0, 0x11, 0x56, 0x55, 0x8a, 0x9d, 0x39, 0xac, 0x87, 0x05, 0x91, 0xc3, 0x9a, 0xe9, 0x65,
	0x25, 0xd7, 0xcb, 0x39, 0xa2, 0x28, 0x7c, 0x89, 0x28, 0xc2, 0x12, 0xa5, 0x34, 0x9d, 0x9f, 0x14,
	0xb8, 0x7d, 0xe8, 0xfa, 0xe7, 0x5f, 0xbf, 0x27, 0x82, 0x22, 0x0f, 0x10, 0x9b, 0x35, 0xb0, 0x78,
	0xe7, 0xfe, 0xa3, 0x60, 0xec, 0x9b, 0x36, 0xa1, 0x62, 0x8f, 0x2a, 0x8e, 0x65, 0x7e, 0xd4, 0xa8,
	0x05, 0xc3, 0xea, 0x47, 0x22, 0x7a, 0x06, 0xeb, 0x13, 0x4a, 0x28, 0x79, 0xbf, 0x74, 0x02, 0x87,
	0x03, 0x5d, 0x6a, 0xaf, 0xed, 0xd5, 0x7b, 0x9b, 0x49, 0xe9, 0x8e, 0x4c, 0x66, 0xbd, 0xc5, 0x59,
	0xaf, 0xce, 0x67, 0x05, 0x4a, 0xc2, 0x80, 0x1e, 0xc3, 0xc6, 0x91, 0xe3, 0x39, 0xf3, 0xe5, 0xfc,
	0x35, 0xa1, 0x81, 0xe3, 0x7b, 0x32, 0xd9, 0x9c, 0x56, 0xf8, 0x99, 0x1f, 0xd3, 0x7e, 0x05, 0xe9,
	0x97, 0xd1, 0x0a, 0x38, 0xcd, 0x80, 0x44, 0xe9, 0xca, 0x86, 0x4e, 0xa9, 0x72, 0x70, 0x16, 0x57,
	0x78, 0xb7, 0x05, 0xd5, 0x63, 0x9f, 0x89, 0xec, 0x44, 0x23, 0x57, 0x71, 0x2c, 0xa3, 0xbf, 0x43,
	0x5d, 0x73, 0x19, 0xa1, 0x9e, 0xc9, 0xa9, 0x42, 0x74, 0xf1, 0x15, 0x87, 0x4d, 0xfb, 0x74, 0xfe,
	0x0a, 0x1b, 0x51, 0x61, 0x64, 0x9f, 0xb7, 0xa0, 0x2a, 0xe7, 0x35, 0xae, 0x4c, 0x24, 0x77, 0x5e,
	0x40, 0xbd, 0xef, 0xcf, 0x31, 0xb1, 0x88, 0x73, 0x41, 0x6c, 0xf4, 0x84, 0xb3, 0xd0, 0x7c, 0x6e,
	0x7a, 0xb6, 0xf0, 0xac, 0xf7, 0xee, 0xa4, 0x6f, 0x36, 0x69, 0xc2, 0x91, 0x0f, 0x67, 0xdd, 0x46,
	0xb8, 0x14, 0xe7, 0xd4, 0x65, 0xb0, 0x42, 0x06, 0x29, 0x8e, 0x2a, 0x64, 0x39, 0x6a, 0x1b, 0xca,
	0x61, 0x8c, 0x84, 0x4c, 0x4a, 0xa8, 0x09, 0x6b, 0xba, 0x67, 0xcb, 0xb2, 0xf3, 0xd7, 0x2c, 0x67,
	0x95, 0xf2, 0x9c, 0xd5, 0x82, 0xea, 0xd0, 0xf1, 0x9c, 0xe0, 0x2d, 0xb1, 0x05, 0x3c, 0x55, 0x1c,
	0xcb, 0x7c, 0x8f, 0xa1, 0xe9, 0xb8, 0xc4, 0x16, 0x03, 0x5e, 0xc5, 0x52, 0xe2, 0x31, 0xe1, 0x64,
	0x05, 0x33, 0x31, 0xc6, 0x35, 0x1c, 0xcb, 0x7c, 0xb7, 0xa9, 0xcf, 0x4c, 0x97, 0xcf, 0xb5, 0x98,
	0xe2, 0x22, 0x4e, 0x14, 0x89, 0x95, 0x78, 0x4c, 0x4c, 0x71, 0x6c, 0x25, 0x1e, 0x43, 0x4f, 0xa0,
	0x1c, 0xb6, 0xbc, 0x98, 0xdf, 0x7a, 0x6f, 0x2b, 0x0d, 0x5e, 0x68, 0xc1, 0xe4, 0x0d, 0x96, 0x4e,
	0xe8, 0x2f, 0xf1, 0x95, 0x25, 0x06, 0xba, 0xde, 0xbb, 0x9d, 0x14, 0x56, 0x1a, 0x70, 0xe4, 0xd1,
	0x39, 0x84, 0x66, 0x1a, 0xe9, 0xb1, 0x13, 0x30, 0xd4, 0x8d, 0x31, 0x54, 0xc4, 0x14, 0x6c, 0xa7,
	0x09, 0x2c, 0xf1, 0x8d, 0xb0, 0xed, 0x7c, 0x80, 0xc6, 0xd0, 0xa1, 0xf3, 0x0f, 0x26, 0x0d, 0xa9,
	0x3b, 0xc9, 0x57, 0xf9, 0x9a, 0x7c, 0xb3, 0x8d, 0x5c, 0x58, 0x69, 0x64, 0x15, 0x2a, 0xd1, 0xac,
	0xc8, 0x8f, 0x13, 0x29, 0x76, 0xfe, 0x03, 0xf5, 0x57, 0x4e, 0xc0, 0x9d, 0x44, 0xde, 0x07, 0x50,
	0x0b, 0x45, 0x87, 0x44, 0xa9, 0xa7, 0x8e, 0x2e, 0x3d, 0x71, 0xe2, 0xd3, 0x21, 0x50, 0x91, 0x5a,
	0x7e, 0x66, 0x79, 0x09, 0x2b, 0x37, 0x5d, 0xc2, 0x58, 0x7a, 0xa1, 0x7d, 0x28, 0xf1, 0xb3, 0x06,
	0x6a, 0x41, 0xec, 0x73, 0x37, 0x0f, 0x11, 0x37, 0xe2, 0xd0, 0xa5, 0xf3, 0x14, 0x50, 0x4c, 0xfc,
	0x0b, 0x3f, 0x22, 0xb6, 0xec, 0xb1, 0x95, 0x15, 0x3a, 0xfc, 0xb6, 0x00, 0x5b, 0xe1, 0x5a, 0x43,
	0xca, 0x47, 0x29, 0x89, 0xfc, 0x9d, 0x34, 0x5c, 0xfc, 0x12, 0x0d, 0xaf, 0xf0, 0x46, 0x4c, 0xa0,
	0xc5, 0xeb, 0x09, 0xb4, 0x94, 0x25, 0xd0, 0xc7, 0xb0, 0x31, 0x74, 0x5c, 0xe2, 0x99, 0x73, 0x32,
	0xf2, 0xc4, 0x27, 0x59, 0xf8, 0xa1, 0x97, 0xd3, 0xae, 0x12, 0x6d, 0xe5, 0x6b, 0x88, 0x76, 0x7f,
	0xc2, 0xaf, 0xa2, 0xd4, 0xdd, 0x89, 0xea, 0x50, 0x99, 0xe8, 0xc7, 0x83, 0xd1, 0xf1, 0xcb, 0xe6,
	0x2d, 0x2e, 0x4c, 0x47, 0x47, 0xfa, 0xc9, 0xe9, 0xb4, 0xa9, 0x70, 0xc1, 0x38, 0xed, 0xf7, 0x75,
	0xc3, 0x68, 0x16, 0x50, 0x03, 0xaa, 0x58, 0xff, 0x9f, 0xde, 0x9f, 0xea, 0x83, 0xe6, 0x1a, 0x02,
	0x28, 0x0f, 0xb5, 0xd1, 0x58, 0x1f, 0x34, 0x8b, 0xfb, 0xbf, 0x28, 0x50, 0x97, 0xf0, 0xba, 0xe6,
	0x2c, 0x40, 0x77, 0x60, 0x73, 0x38, 0xd6, 0x8c, 0x57, 0x67, 0xc3, 0xb1, 0xf6, 0xd2, 0x38, 0x3b,
	0x35, 0xf4, 0xe6, 0x2d, 0xf4, 0x00, 0x5a, 0x69, 0xa5, 0xa1, 0x4f, 0xcf, 0xc6, 0xda, 0x54, 0x37,
	0xa6, 0x67, 0xda, 0x64, 0xd2, 0x54, 0xd0, 0x2e, 0xa8, 0x19, 0xfb, 0xf4, 0x64, 0xc2, 0x23, 0x31,
	0xb7, 0x16, 0xd0, 0x1f, 0x60, 0x27, 0x6b, 0xd5, 0xf0, 0x34, 0x36, 0xaf, 0xa1, 0x0e, 0x3c, 0xb8,
	0x66, 0xf1, 0xc8, 0xa7, 0x88, 0x76, 0x60, 0x2b, 0xed, 0x33, 0xc1, 0xfa, 0x99, 0x8e, 0x35, 0x43,
	0x6f, 0x96, 0xd0, 0x43, 0xb8, 0x9f, 0x36, 0x61, 0x7d, 0x7a, 0x8a, 0x8f, 0x79, 0x5e, 0x67, 0xc6,
	0xf8, 0x64, 0xda, 0x2c, 0xf7, 0x7e, 0x2d, 0xc1, 0xa6, 0xd1, 0x97, 0x13, 0x1b, 0x7e, 0xd8, 0xa2,
	0x17, 0xb0, 0x65, 0x30, 0x4a, 0xcc, 0x79, 0xc4, 0xb9, 0x11, 0x43, 0x6f, 0x25, 0x05, 0x48, 0x11,
	0x77, 0xab, 0xd1, 0x95, 0x3f, 0x41, 0xaf, 0x7d, 0xc7, 0x46, 0x5a, 0x44, 0xcb, 0x72, 0x72, 0xef,
	0xe5, 0xbb, 0x5e, 0x76, 0x68, 0x4b, 0x5d, 0x35, 0xc8, 0x4b, 0xe3, 0x08, 0xee, 0xa6, 0x97, 0xe0,
	0xad, 0x2d, 0xae, 0xed, 0xfb, 0x49, 0xc4, 0xca, 0x37, 0xc0, 0x0d, 0xcb, 0x69, 0xb9, 0x8b, 0xe2,
	0x6a, 0xaa, 0x69, 0xb5, 0xae, 0x66, 0x30, 0xc1, 0x1a, 0xcf, 0x60, 0xbd, 0xff, 0x96, 0x58, 0xef,
	0x22, 0x0a, 0x43, 0xa9, 0xd1, 0x4f, 0xd3, 0x5a, 0x0e, 0x8b, 0x1e, 0xd4, 0xb5, 0x73, 0x9f, 0x32,
	0xc9, 0x07, 0xd7, 0x6c, 0x9c, 0x8d, 0xf9, 0x27, 0xd4, 0xf9, 0x96, 0x61, 0x48, 0x80, 0x32, 0xc6,
	0x1b, 0x73, 0xfc, 0x2f, 0x34, 0x25, 0x51, 0x0d, 0x7d, 0x2a, 0xc1, 0xbf, 0x66, 0xc7, 0xad, 0x15,
	0xc6, 0x13, 0x2b, 0xfc, 0x9b, 0x77, 0x7b, 0xcc, 0x41, 0x68, 0xf7, 0x8a, 0x6f, 0xd2, 0x98, 0x60,
	0x72, 0x59, 0xff, 0x19, 0x6a, 0x7d, 0xd3, 0xb3, 0x88, 0xab, 0xb9, 0x6e, 0x2e, 0xe7, 0xac, 0xe3,
	0xbf, 0x78, 0xbf, 0x69, 0xfc, 0x9f, 0xb4, 0x6f, 0xba, 0xee, 0xb9, 0x69, 0xbd, 0x13, 0x1d, 0x12,
	0xfe, 0xa5, 0x46, 0xaa, 0x70, 0x7e, 0x73, 0x91, 0xff, 0x5f, 0xed, 0x0a, 0x91, 0xe6, 0xc3, 0x3c,
	0x26, 0x39, 0x2a, 0xbc, 0xbe, 0x33, 0x0e, 0x1f, 0xc1, 0x1f, 0x3d, 0xc2, 0xd2, 0x18, 0xc9, 0x5f,
	0x6a, 0xfe, 0x0f, 0x1d, 0x47, 0x9d, 0x97, 0xc5, 0xdf, 0xf3, 0x3f, 0x7e, 0x0b, 0x00, 0x00, 0xff,
	0xff, 0xf1, 0x64, 0xb4, 0x9f, 0x4d, 0x10, 0x00, 0x00,
}
