// Code generated by protoc-gen-go.
// source: golang.singingcat.net/apis/scrouter/scrouter.proto
// DO NOT EDIT!

/*
Package scrouter is a generated protocol buffer package.

It is generated from these files:
	golang.singingcat.net/apis/scrouter/scrouter.proto

It has these top-level messages:
	PeerList
	Peer
	DBPeer
	ModuleState
	NextHop
	NextHopResponse
	DBRoute
	RouteRequest
	RouteResult
	Route
	RouteUpdateFailure
	RouteUpdatePeer
	FullRoute
	PendingChangesList
	RouteList
*/
package scrouter

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import singingcat "golang.singingcat.net/apis/singingcat"
import scweb "golang.singingcat.net/apis/scweb"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// a list of peers
type PeerList struct {
	Peers []*Peer `protobuf:"bytes,1,rep,name=Peers" json:"Peers,omitempty"`
}

func (m *PeerList) Reset()                    { *m = PeerList{} }
func (m *PeerList) String() string            { return proto.CompactTextString(m) }
func (*PeerList) ProtoMessage()               {}
func (*PeerList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PeerList) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

// a peer is a singingcat module in 'range' (aka a neighbour)
type Peer struct {
	Module             *singingcat.ModuleRef `protobuf:"bytes,1,opt,name=Module" json:"Module,omitempty"`
	Device             singingcat.Device     `protobuf:"varint,2,opt,name=Device,enum=singingcat.Device" json:"Device,omitempty"`
	HasCloudConnection bool                  `protobuf:"varint,3,opt,name=HasCloudConnection" json:"HasCloudConnection,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Peer) GetModule() *singingcat.ModuleRef {
	if m != nil {
		return m.Module
	}
	return nil
}

func (m *Peer) GetDevice() singingcat.Device {
	if m != nil {
		return m.Device
	}
	return singingcat.Device_DEVICE_UNSPECIFIED
}

func (m *Peer) GetHasCloudConnection() bool {
	if m != nil {
		return m.HasCloudConnection
	}
	return false
}

type DBPeer struct {
	ID                 uint64            `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ModuleID           uint64            `protobuf:"varint,2,opt,name=ModuleID" json:"ModuleID,omitempty"`
	PeerModuleID       uint64            `protobuf:"varint,3,opt,name=PeerModuleID" json:"PeerModuleID,omitempty"`
	Device             singingcat.Device `protobuf:"varint,4,opt,name=Device,enum=singingcat.Device" json:"Device,omitempty"`
	HasCloudConnection bool              `protobuf:"varint,5,opt,name=HasCloudConnection" json:"HasCloudConnection,omitempty"`
	LastReported       uint32            `protobuf:"varint,6,opt,name=LastReported" json:"LastReported,omitempty"`
}

func (m *DBPeer) Reset()                    { *m = DBPeer{} }
func (m *DBPeer) String() string            { return proto.CompactTextString(m) }
func (*DBPeer) ProtoMessage()               {}
func (*DBPeer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DBPeer) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBPeer) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *DBPeer) GetPeerModuleID() uint64 {
	if m != nil {
		return m.PeerModuleID
	}
	return 0
}

func (m *DBPeer) GetDevice() singingcat.Device {
	if m != nil {
		return m.Device
	}
	return singingcat.Device_DEVICE_UNSPECIFIED
}

func (m *DBPeer) GetHasCloudConnection() bool {
	if m != nil {
		return m.HasCloudConnection
	}
	return false
}

func (m *DBPeer) GetLastReported() uint32 {
	if m != nil {
		return m.LastReported
	}
	return 0
}

type ModuleState struct {
	ID                   uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ModuleID             uint64 `protobuf:"varint,2,opt,name=ModuleID" json:"ModuleID,omitempty"`
	LastPeersRequested   uint32 `protobuf:"varint,3,opt,name=LastPeersRequested" json:"LastPeersRequested,omitempty"`
	LastPeersAckReceived uint32 `protobuf:"varint,4,opt,name=LastPeersAckReceived" json:"LastPeersAckReceived,omitempty"`
	LastComSequence      uint32 `protobuf:"varint,5,opt,name=LastComSequence" json:"LastComSequence,omitempty"`
}

func (m *ModuleState) Reset()                    { *m = ModuleState{} }
func (m *ModuleState) String() string            { return proto.CompactTextString(m) }
func (*ModuleState) ProtoMessage()               {}
func (*ModuleState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ModuleState) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ModuleState) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *ModuleState) GetLastPeersRequested() uint32 {
	if m != nil {
		return m.LastPeersRequested
	}
	return 0
}

func (m *ModuleState) GetLastPeersAckReceived() uint32 {
	if m != nil {
		return m.LastPeersAckReceived
	}
	return 0
}

func (m *ModuleState) GetLastComSequence() uint32 {
	if m != nil {
		return m.LastComSequence
	}
	return 0
}

type NextHop struct {
	ID              uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	TargetModuleID  uint64 `protobuf:"varint,2,opt,name=TargetModuleID" json:"TargetModuleID,omitempty"`
	NextHopModuleID uint64 `protobuf:"varint,3,opt,name=NextHopModuleID" json:"NextHopModuleID,omitempty"`
	Created         uint32 `protobuf:"varint,4,opt,name=Created" json:"Created,omitempty"`
}

func (m *NextHop) Reset()                    { *m = NextHop{} }
func (m *NextHop) String() string            { return proto.CompactTextString(m) }
func (*NextHop) ProtoMessage()               {}
func (*NextHop) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *NextHop) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *NextHop) GetTargetModuleID() uint64 {
	if m != nil {
		return m.TargetModuleID
	}
	return 0
}

func (m *NextHop) GetNextHopModuleID() uint64 {
	if m != nil {
		return m.NextHopModuleID
	}
	return 0
}

func (m *NextHop) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

type NextHopResponse struct {
	ModuleID uint64 `protobuf:"varint,1,opt,name=ModuleID" json:"ModuleID,omitempty"`
	NodeID   uint32 `protobuf:"varint,2,opt,name=NodeID" json:"NodeID,omitempty"`
}

func (m *NextHopResponse) Reset()                    { *m = NextHopResponse{} }
func (m *NextHopResponse) String() string            { return proto.CompactTextString(m) }
func (*NextHopResponse) ProtoMessage()               {}
func (*NextHopResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *NextHopResponse) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *NextHopResponse) GetNodeID() uint32 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

type DBRoute struct {
	ID                   uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ModuleID             uint64 `protobuf:"varint,2,opt,name=ModuleID" json:"ModuleID,omitempty"`
	TargetMatch          uint64 `protobuf:"varint,3,opt,name=TargetMatch" json:"TargetMatch,omitempty"`
	SenderMatch          uint64 `protobuf:"varint,4,opt,name=SenderMatch" json:"SenderMatch,omitempty"`
	NextHop              uint64 `protobuf:"varint,5,opt,name=NextHop" json:"NextHop,omitempty"`
	DeviceMatch          uint32 `protobuf:"varint,6,opt,name=DeviceMatch" json:"DeviceMatch,omitempty"`
	OnDevice             uint32 `protobuf:"varint,7,opt,name=OnDevice" json:"OnDevice,omitempty"`
	LastApplied          uint32 `protobuf:"varint,8,opt,name=LastApplied" json:"LastApplied,omitempty"`
	LastApplyAttempt     uint32 `protobuf:"varint,9,opt,name=LastApplyAttempt" json:"LastApplyAttempt,omitempty"`
	ToBeDeleted          bool   `protobuf:"varint,10,opt,name=ToBeDeleted" json:"ToBeDeleted,omitempty"`
	NextHopImplicitRoute uint64 `protobuf:"varint,11,opt,name=NextHopImplicitRoute" json:"NextHopImplicitRoute,omitempty"`
	ApplyAttempts        uint64 `protobuf:"varint,12,opt,name=ApplyAttempts" json:"ApplyAttempts,omitempty"`
}

func (m *DBRoute) Reset()                    { *m = DBRoute{} }
func (m *DBRoute) String() string            { return proto.CompactTextString(m) }
func (*DBRoute) ProtoMessage()               {}
func (*DBRoute) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DBRoute) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBRoute) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *DBRoute) GetTargetMatch() uint64 {
	if m != nil {
		return m.TargetMatch
	}
	return 0
}

func (m *DBRoute) GetSenderMatch() uint64 {
	if m != nil {
		return m.SenderMatch
	}
	return 0
}

func (m *DBRoute) GetNextHop() uint64 {
	if m != nil {
		return m.NextHop
	}
	return 0
}

func (m *DBRoute) GetDeviceMatch() uint32 {
	if m != nil {
		return m.DeviceMatch
	}
	return 0
}

func (m *DBRoute) GetOnDevice() uint32 {
	if m != nil {
		return m.OnDevice
	}
	return 0
}

func (m *DBRoute) GetLastApplied() uint32 {
	if m != nil {
		return m.LastApplied
	}
	return 0
}

func (m *DBRoute) GetLastApplyAttempt() uint32 {
	if m != nil {
		return m.LastApplyAttempt
	}
	return 0
}

func (m *DBRoute) GetToBeDeleted() bool {
	if m != nil {
		return m.ToBeDeleted
	}
	return false
}

func (m *DBRoute) GetNextHopImplicitRoute() uint64 {
	if m != nil {
		return m.NextHopImplicitRoute
	}
	return 0
}

func (m *DBRoute) GetApplyAttempts() uint64 {
	if m != nil {
		return m.ApplyAttempts
	}
	return 0
}

type RouteRequest struct {
	Module      *singingcat.ModuleRef `protobuf:"bytes,1,opt,name=Module" json:"Module,omitempty"`
	TargetMatch *singingcat.ModuleRef `protobuf:"bytes,2,opt,name=TargetMatch" json:"TargetMatch,omitempty"`
	SenderMatch *singingcat.ModuleRef `protobuf:"bytes,3,opt,name=SenderMatch" json:"SenderMatch,omitempty"`
	NextHop     *singingcat.ModuleRef `protobuf:"bytes,4,opt,name=NextHop" json:"NextHop,omitempty"`
	DeviceMatch singingcat.Device     `protobuf:"varint,5,opt,name=DeviceMatch,enum=singingcat.Device" json:"DeviceMatch,omitempty"`
	OnDevice    singingcat.Device     `protobuf:"varint,6,opt,name=OnDevice,enum=singingcat.Device" json:"OnDevice,omitempty"`
}

func (m *RouteRequest) Reset()                    { *m = RouteRequest{} }
func (m *RouteRequest) String() string            { return proto.CompactTextString(m) }
func (*RouteRequest) ProtoMessage()               {}
func (*RouteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *RouteRequest) GetModule() *singingcat.ModuleRef {
	if m != nil {
		return m.Module
	}
	return nil
}

func (m *RouteRequest) GetTargetMatch() *singingcat.ModuleRef {
	if m != nil {
		return m.TargetMatch
	}
	return nil
}

func (m *RouteRequest) GetSenderMatch() *singingcat.ModuleRef {
	if m != nil {
		return m.SenderMatch
	}
	return nil
}

func (m *RouteRequest) GetNextHop() *singingcat.ModuleRef {
	if m != nil {
		return m.NextHop
	}
	return nil
}

func (m *RouteRequest) GetDeviceMatch() singingcat.Device {
	if m != nil {
		return m.DeviceMatch
	}
	return singingcat.Device_DEVICE_UNSPECIFIED
}

func (m *RouteRequest) GetOnDevice() singingcat.Device {
	if m != nil {
		return m.OnDevice
	}
	return singingcat.Device_DEVICE_UNSPECIFIED
}

type RouteResult struct {
	NextHop      *NextHopResponse `protobuf:"bytes,1,opt,name=NextHop" json:"NextHop,omitempty"`
	Success      bool             `protobuf:"varint,2,opt,name=Success" json:"Success,omitempty"`
	Milliseconds uint64           `protobuf:"varint,3,opt,name=Milliseconds" json:"Milliseconds,omitempty"`
}

func (m *RouteResult) Reset()                    { *m = RouteResult{} }
func (m *RouteResult) String() string            { return proto.CompactTextString(m) }
func (*RouteResult) ProtoMessage()               {}
func (*RouteResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *RouteResult) GetNextHop() *NextHopResponse {
	if m != nil {
		return m.NextHop
	}
	return nil
}

func (m *RouteResult) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *RouteResult) GetMilliseconds() uint64 {
	if m != nil {
		return m.Milliseconds
	}
	return 0
}

type Route struct {
	HostModuleID uint64 `protobuf:"varint,1,opt,name=HostModuleID" json:"HostModuleID,omitempty"`
	NextModuleID uint64 `protobuf:"varint,2,opt,name=NextModuleID" json:"NextModuleID,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Route) GetHostModuleID() uint64 {
	if m != nil {
		return m.HostModuleID
	}
	return 0
}

func (m *Route) GetNextModuleID() uint64 {
	if m != nil {
		return m.NextModuleID
	}
	return 0
}

type RouteUpdateFailure struct {
	Sender          *scweb.Module `protobuf:"bytes,1,opt,name=Sender" json:"Sender,omitempty"`
	ForwardingError uint32        `protobuf:"varint,2,opt,name=ForwardingError" json:"ForwardingError,omitempty"`
	RecipientNode   uint32        `protobuf:"varint,3,opt,name=RecipientNode" json:"RecipientNode,omitempty"`
	RecipientModule *scweb.Module `protobuf:"bytes,4,opt,name=RecipientModule" json:"RecipientModule,omitempty"`
	TargetNode      uint32        `protobuf:"varint,5,opt,name=TargetNode" json:"TargetNode,omitempty"`
	TargetModule    *scweb.Module `protobuf:"bytes,6,opt,name=TargetModule" json:"TargetModule,omitempty"`
	Sequence        uint32        `protobuf:"varint,7,opt,name=Sequence" json:"Sequence,omitempty"`
}

func (m *RouteUpdateFailure) Reset()                    { *m = RouteUpdateFailure{} }
func (m *RouteUpdateFailure) String() string            { return proto.CompactTextString(m) }
func (*RouteUpdateFailure) ProtoMessage()               {}
func (*RouteUpdateFailure) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *RouteUpdateFailure) GetSender() *scweb.Module {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *RouteUpdateFailure) GetForwardingError() uint32 {
	if m != nil {
		return m.ForwardingError
	}
	return 0
}

func (m *RouteUpdateFailure) GetRecipientNode() uint32 {
	if m != nil {
		return m.RecipientNode
	}
	return 0
}

func (m *RouteUpdateFailure) GetRecipientModule() *scweb.Module {
	if m != nil {
		return m.RecipientModule
	}
	return nil
}

func (m *RouteUpdateFailure) GetTargetNode() uint32 {
	if m != nil {
		return m.TargetNode
	}
	return 0
}

func (m *RouteUpdateFailure) GetTargetModule() *scweb.Module {
	if m != nil {
		return m.TargetModule
	}
	return nil
}

func (m *RouteUpdateFailure) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

type RouteUpdatePeer struct {
	Sender *scweb.Module     `protobuf:"bytes,1,opt,name=Sender" json:"Sender,omitempty"`
	Device singingcat.Device `protobuf:"varint,2,opt,name=Device,enum=singingcat.Device" json:"Device,omitempty"`
	Peer   *scweb.Module     `protobuf:"bytes,3,opt,name=Peer" json:"Peer,omitempty"`
	Added  bool              `protobuf:"varint,4,opt,name=Added" json:"Added,omitempty"`
}

func (m *RouteUpdatePeer) Reset()                    { *m = RouteUpdatePeer{} }
func (m *RouteUpdatePeer) String() string            { return proto.CompactTextString(m) }
func (*RouteUpdatePeer) ProtoMessage()               {}
func (*RouteUpdatePeer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *RouteUpdatePeer) GetSender() *scweb.Module {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *RouteUpdatePeer) GetDevice() singingcat.Device {
	if m != nil {
		return m.Device
	}
	return singingcat.Device_DEVICE_UNSPECIFIED
}

func (m *RouteUpdatePeer) GetPeer() *scweb.Module {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *RouteUpdatePeer) GetAdded() bool {
	if m != nil {
		return m.Added
	}
	return false
}

type FullRoute struct {
	Routes []*DBRoute `protobuf:"bytes,1,rep,name=Routes" json:"Routes,omitempty"`
}

func (m *FullRoute) Reset()                    { *m = FullRoute{} }
func (m *FullRoute) String() string            { return proto.CompactTextString(m) }
func (*FullRoute) ProtoMessage()               {}
func (*FullRoute) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *FullRoute) GetRoutes() []*DBRoute {
	if m != nil {
		return m.Routes
	}
	return nil
}

type PendingChangesList struct {
	Routes []*DBRoute `protobuf:"bytes,1,rep,name=Routes" json:"Routes,omitempty"`
}

func (m *PendingChangesList) Reset()                    { *m = PendingChangesList{} }
func (m *PendingChangesList) String() string            { return proto.CompactTextString(m) }
func (*PendingChangesList) ProtoMessage()               {}
func (*PendingChangesList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *PendingChangesList) GetRoutes() []*DBRoute {
	if m != nil {
		return m.Routes
	}
	return nil
}

type RouteList struct {
	Routes []*DBRoute `protobuf:"bytes,1,rep,name=Routes" json:"Routes,omitempty"`
}

func (m *RouteList) Reset()                    { *m = RouteList{} }
func (m *RouteList) String() string            { return proto.CompactTextString(m) }
func (*RouteList) ProtoMessage()               {}
func (*RouteList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *RouteList) GetRoutes() []*DBRoute {
	if m != nil {
		return m.Routes
	}
	return nil
}

func init() {
	proto.RegisterType((*PeerList)(nil), "scrouter.PeerList")
	proto.RegisterType((*Peer)(nil), "scrouter.Peer")
	proto.RegisterType((*DBPeer)(nil), "scrouter.DBPeer")
	proto.RegisterType((*ModuleState)(nil), "scrouter.ModuleState")
	proto.RegisterType((*NextHop)(nil), "scrouter.NextHop")
	proto.RegisterType((*NextHopResponse)(nil), "scrouter.NextHopResponse")
	proto.RegisterType((*DBRoute)(nil), "scrouter.DBRoute")
	proto.RegisterType((*RouteRequest)(nil), "scrouter.RouteRequest")
	proto.RegisterType((*RouteResult)(nil), "scrouter.RouteResult")
	proto.RegisterType((*Route)(nil), "scrouter.Route")
	proto.RegisterType((*RouteUpdateFailure)(nil), "scrouter.RouteUpdateFailure")
	proto.RegisterType((*RouteUpdatePeer)(nil), "scrouter.RouteUpdatePeer")
	proto.RegisterType((*FullRoute)(nil), "scrouter.FullRoute")
	proto.RegisterType((*PendingChangesList)(nil), "scrouter.PendingChangesList")
	proto.RegisterType((*RouteList)(nil), "scrouter.RouteList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SCRouter service

type SCRouterClient interface {
	// trigger a "request peers" from a module
	TriggerRequestPeers(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error)
	// get the peers a module knows of (from our database)
	GetPeers(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*PeerList, error)
	// a command reply received. (called by scserver/scmodcoms)
	CommandReply(ctx context.Context, in *singingcat.Command, opts ...grpc.CallOption) (*common.Void, error)
	// request next hop from server (for scserver to know where to send stuff to)
	GetNextHopFromServer(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*NextHopResponse, error)
	// add route
	AddRoute(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (*common.Void, error)
	// delete route
	DelRoute(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (*common.Void, error)
	// called after scserver used a given route
	RouteUpdate(ctx context.Context, in *RouteResult, opts ...grpc.CallOption) (*common.Void, error)
	// device powered up (called by scmodcomms if a device sends 'powerup')
	DevicePoweredUp(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error)
	// add Next Hop
	AddNextHop(ctx context.Context, in *NextHop, opts ...grpc.CallOption) (*NextHop, error)
	// remove Next Hop
	RemoveNextHop(ctx context.Context, in *NextHop, opts ...grpc.CallOption) (*common.Void, error)
	// get a full route from here to the module (including nexthop)
	GetFullRoute(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*FullRoute, error)
	// get the current list of outstanding changes to modules
	GetPendingChanges(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*PendingChangesList, error)
	// get all current routes to all modules
	GetAllRoutes(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*RouteList, error)
	// scserver says we sent him a next hop that is not or no longer valid. We are expected to calculate an alternative
	InformInvalidNextHop(ctx context.Context, in *NextHopResponse, opts ...grpc.CallOption) (*NextHopResponse, error)
	// calculate routes and return result. Do not apply or modify any routes though
	CalcRoutes(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*RouteList, error)
}

type sCRouterClient struct {
	cc *grpc.ClientConn
}

func NewSCRouterClient(cc *grpc.ClientConn) SCRouterClient {
	return &sCRouterClient{cc}
}

func (c *sCRouterClient) TriggerRequestPeers(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/TriggerRequestPeers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) GetPeers(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*PeerList, error) {
	out := new(PeerList)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/GetPeers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) CommandReply(ctx context.Context, in *singingcat.Command, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/CommandReply", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) GetNextHopFromServer(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*NextHopResponse, error) {
	out := new(NextHopResponse)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/GetNextHopFromServer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) AddRoute(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/AddRoute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) DelRoute(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/DelRoute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) RouteUpdate(ctx context.Context, in *RouteResult, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/RouteUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) DevicePoweredUp(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/DevicePoweredUp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) AddNextHop(ctx context.Context, in *NextHop, opts ...grpc.CallOption) (*NextHop, error) {
	out := new(NextHop)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/AddNextHop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) RemoveNextHop(ctx context.Context, in *NextHop, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/RemoveNextHop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) GetFullRoute(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*FullRoute, error) {
	out := new(FullRoute)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/GetFullRoute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) GetPendingChanges(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*PendingChangesList, error) {
	out := new(PendingChangesList)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/GetPendingChanges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) GetAllRoutes(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*RouteList, error) {
	out := new(RouteList)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/GetAllRoutes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) InformInvalidNextHop(ctx context.Context, in *NextHopResponse, opts ...grpc.CallOption) (*NextHopResponse, error) {
	out := new(NextHopResponse)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/InformInvalidNextHop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) CalcRoutes(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*RouteList, error) {
	out := new(RouteList)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/CalcRoutes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SCRouter service

type SCRouterServer interface {
	// trigger a "request peers" from a module
	TriggerRequestPeers(context.Context, *singingcat.ModuleRef) (*common.Void, error)
	// get the peers a module knows of (from our database)
	GetPeers(context.Context, *singingcat.ModuleRef) (*PeerList, error)
	// a command reply received. (called by scserver/scmodcoms)
	CommandReply(context.Context, *singingcat.Command) (*common.Void, error)
	// request next hop from server (for scserver to know where to send stuff to)
	GetNextHopFromServer(context.Context, *singingcat.ModuleRef) (*NextHopResponse, error)
	// add route
	AddRoute(context.Context, *RouteRequest) (*common.Void, error)
	// delete route
	DelRoute(context.Context, *RouteRequest) (*common.Void, error)
	// called after scserver used a given route
	RouteUpdate(context.Context, *RouteResult) (*common.Void, error)
	// device powered up (called by scmodcomms if a device sends 'powerup')
	DevicePoweredUp(context.Context, *singingcat.ModuleRef) (*common.Void, error)
	// add Next Hop
	AddNextHop(context.Context, *NextHop) (*NextHop, error)
	// remove Next Hop
	RemoveNextHop(context.Context, *NextHop) (*common.Void, error)
	// get a full route from here to the module (including nexthop)
	GetFullRoute(context.Context, *singingcat.ModuleRef) (*FullRoute, error)
	// get the current list of outstanding changes to modules
	GetPendingChanges(context.Context, *common.Void) (*PendingChangesList, error)
	// get all current routes to all modules
	GetAllRoutes(context.Context, *common.Void) (*RouteList, error)
	// scserver says we sent him a next hop that is not or no longer valid. We are expected to calculate an alternative
	InformInvalidNextHop(context.Context, *NextHopResponse) (*NextHopResponse, error)
	// calculate routes and return result. Do not apply or modify any routes though
	CalcRoutes(context.Context, *singingcat.ModuleRef) (*RouteList, error)
}

func RegisterSCRouterServer(s *grpc.Server, srv SCRouterServer) {
	s.RegisterService(&_SCRouter_serviceDesc, srv)
}

func _SCRouter_TriggerRequestPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).TriggerRequestPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/TriggerRequestPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).TriggerRequestPeers(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_GetPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).GetPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/GetPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).GetPeers(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_CommandReply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).CommandReply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/CommandReply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).CommandReply(ctx, req.(*singingcat.Command))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_GetNextHopFromServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).GetNextHopFromServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/GetNextHopFromServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).GetNextHopFromServer(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_AddRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).AddRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/AddRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).AddRoute(ctx, req.(*RouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_DelRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).DelRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/DelRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).DelRoute(ctx, req.(*RouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_RouteUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).RouteUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/RouteUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).RouteUpdate(ctx, req.(*RouteResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_DevicePoweredUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).DevicePoweredUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/DevicePoweredUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).DevicePoweredUp(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_AddNextHop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextHop)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).AddNextHop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/AddNextHop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).AddNextHop(ctx, req.(*NextHop))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_RemoveNextHop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextHop)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).RemoveNextHop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/RemoveNextHop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).RemoveNextHop(ctx, req.(*NextHop))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_GetFullRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).GetFullRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/GetFullRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).GetFullRoute(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_GetPendingChanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).GetPendingChanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/GetPendingChanges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).GetPendingChanges(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_GetAllRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).GetAllRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/GetAllRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).GetAllRoutes(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_InformInvalidNextHop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextHopResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).InformInvalidNextHop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/InformInvalidNextHop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).InformInvalidNextHop(ctx, req.(*NextHopResponse))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_CalcRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).CalcRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/CalcRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).CalcRoutes(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

var _SCRouter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "scrouter.SCRouter",
	HandlerType: (*SCRouterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TriggerRequestPeers",
			Handler:    _SCRouter_TriggerRequestPeers_Handler,
		},
		{
			MethodName: "GetPeers",
			Handler:    _SCRouter_GetPeers_Handler,
		},
		{
			MethodName: "CommandReply",
			Handler:    _SCRouter_CommandReply_Handler,
		},
		{
			MethodName: "GetNextHopFromServer",
			Handler:    _SCRouter_GetNextHopFromServer_Handler,
		},
		{
			MethodName: "AddRoute",
			Handler:    _SCRouter_AddRoute_Handler,
		},
		{
			MethodName: "DelRoute",
			Handler:    _SCRouter_DelRoute_Handler,
		},
		{
			MethodName: "RouteUpdate",
			Handler:    _SCRouter_RouteUpdate_Handler,
		},
		{
			MethodName: "DevicePoweredUp",
			Handler:    _SCRouter_DevicePoweredUp_Handler,
		},
		{
			MethodName: "AddNextHop",
			Handler:    _SCRouter_AddNextHop_Handler,
		},
		{
			MethodName: "RemoveNextHop",
			Handler:    _SCRouter_RemoveNextHop_Handler,
		},
		{
			MethodName: "GetFullRoute",
			Handler:    _SCRouter_GetFullRoute_Handler,
		},
		{
			MethodName: "GetPendingChanges",
			Handler:    _SCRouter_GetPendingChanges_Handler,
		},
		{
			MethodName: "GetAllRoutes",
			Handler:    _SCRouter_GetAllRoutes_Handler,
		},
		{
			MethodName: "InformInvalidNextHop",
			Handler:    _SCRouter_InformInvalidNextHop_Handler,
		},
		{
			MethodName: "CalcRoutes",
			Handler:    _SCRouter_CalcRoutes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.singingcat.net/apis/scrouter/scrouter.proto",
}

func init() { proto.RegisterFile("golang.singingcat.net/apis/scrouter/scrouter.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1205 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x57, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x06, 0x25, 0x59, 0x66, 0x46, 0x92, 0xdd, 0xac, 0xdd, 0x40, 0x16, 0x82, 0x40, 0x25, 0x5c,
	0x40, 0x0d, 0x5a, 0xd9, 0x56, 0x52, 0xb9, 0xc8, 0x25, 0xd0, 0x4f, 0x6c, 0x0b, 0x70, 0x12, 0x83,
	0x4e, 0x7a, 0x67, 0xc8, 0x89, 0x42, 0x94, 0xe2, 0xb2, 0xcb, 0x95, 0xdd, 0xdc, 0x8a, 0xbc, 0x40,
	0xd1, 0x6b, 0x8b, 0xbe, 0x40, 0xaf, 0x7d, 0x87, 0xde, 0xfb, 0x0e, 0x3d, 0xf4, 0x31, 0x8a, 0xfd,
	0x11, 0x45, 0x52, 0x3f, 0x89, 0x2e, 0xf6, 0xee, 0x37, 0x33, 0x3b, 0xbf, 0xfb, 0x71, 0x05, 0x9d,
	0x31, 0x0d, 0x9c, 0x70, 0xdc, 0x8e, 0xfd, 0x70, 0xec, 0x87, 0x63, 0xd7, 0xe1, 0xed, 0x10, 0xf9,
	0x91, 0x13, 0xf9, 0xf1, 0x51, 0xec, 0x32, 0x3a, 0xe5, 0xc8, 0x92, 0x45, 0x3b, 0x62, 0x94, 0x53,
	0x62, 0xce, 0xf6, 0x8d, 0xb6, 0xb6, 0x76, 0x69, 0xc8, 0x1c, 0xef, 0x96, 0x52, 0x6f, 0x6e, 0xed,
	0xd2, 0xc9, 0x84, 0x86, 0xfa, 0x9f, 0xb2, 0x6c, 0x74, 0xd7, 0x79, 0x4b, 0xb0, 0xd4, 0x52, 0xdb,
	0x7d, 0xbd, 0x36, 0xca, 0x5b, 0x7c, 0xa3, 0xfe, 0x2a, 0x6d, 0xeb, 0x18, 0xcc, 0x2b, 0x44, 0x76,
	0xe9, 0xc7, 0x9c, 0x1c, 0xc2, 0x96, 0x58, 0xc7, 0x75, 0xa3, 0x59, 0x6c, 0x55, 0x3a, 0x3b, 0xed,
	0x24, 0x17, 0x01, 0xdb, 0x4a, 0x68, 0xfd, 0x6a, 0x40, 0x49, 0xac, 0xc8, 0x37, 0x50, 0x7e, 0x4e,
	0xbd, 0x69, 0x80, 0x75, 0xa3, 0x69, 0xb4, 0x2a, 0x9d, 0xcf, 0xd3, 0x2e, 0x95, 0xc4, 0xc6, 0xb7,
	0xb6, 0x56, 0x22, 0x0f, 0xa1, 0x3c, 0xc4, 0x1b, 0xdf, 0xc5, 0x7a, 0xa1, 0x69, 0xb4, 0x76, 0x3a,
	0x24, 0xad, 0xae, 0x24, 0xb6, 0xd6, 0x20, 0x6d, 0x20, 0x17, 0x4e, 0x3c, 0x08, 0xe8, 0xd4, 0x1b,
	0xd0, 0x30, 0x44, 0x97, 0xfb, 0x34, 0xac, 0x17, 0x9b, 0x46, 0xcb, 0xb4, 0x97, 0x48, 0xac, 0x7f,
	0x0d, 0x28, 0x0f, 0xfb, 0x32, 0xaa, 0x1d, 0x28, 0x8c, 0x86, 0x32, 0xa2, 0x92, 0x5d, 0x18, 0x0d,
	0x49, 0x03, 0x4c, 0x15, 0xc0, 0x68, 0x28, 0x1d, 0x97, 0xec, 0x64, 0x4f, 0x2c, 0xa8, 0x0a, 0x9b,
	0x44, 0x5e, 0x94, 0xf2, 0x0c, 0x46, 0xba, 0x49, 0xd8, 0xa5, 0x55, 0x61, 0xf7, 0xe1, 0xb7, 0x0f,
	0x07, 0xe5, 0xa9, 0x1f, 0xf2, 0xee, 0xe3, 0x8f, 0xa4, 0xb0, 0xb5, 0x2a, 0x05, 0x11, 0xcb, 0xa5,
	0x13, 0x73, 0x1b, 0x23, 0xca, 0x38, 0x7a, 0xf5, 0x72, 0xd3, 0x68, 0xd5, 0xec, 0x0c, 0x66, 0xfd,
	0x63, 0x40, 0x45, 0x05, 0x76, 0xcd, 0x1d, 0x8e, 0x0b, 0xb9, 0x1e, 0xe6, 0x73, 0xed, 0x9b, 0x7f,
	0x7e, 0x38, 0x28, 0x71, 0x36, 0xc5, 0x54, 0xd6, 0x6d, 0x20, 0xe2, 0x54, 0xd9, 0x4d, 0x1b, 0x7f,
	0x9c, 0x62, 0x2c, 0xfc, 0x15, 0xa5, 0xbf, 0x25, 0x12, 0xd2, 0x81, 0xfd, 0x04, 0xed, 0xb9, 0x3f,
	0xd8, 0xe8, 0xa2, 0x7f, 0x83, 0x9e, 0xac, 0x47, 0xcd, 0x5e, 0x2a, 0x23, 0x2d, 0xd8, 0x15, 0xf8,
	0x80, 0x4e, 0xae, 0xc5, 0x39, 0xa1, 0x8b, 0x32, 0xf5, 0x9a, 0x9d, 0x87, 0xad, 0x5f, 0x0c, 0xd8,
	0x7e, 0x81, 0x3f, 0xf1, 0x0b, 0x1a, 0x2d, 0xe4, 0x73, 0x0c, 0x3b, 0xaf, 0x1c, 0x36, 0x46, 0xbe,
	0x32, 0xab, 0x9c, 0x5c, 0xf8, 0xd5, 0x87, 0xe5, 0x9a, 0x9a, 0x87, 0x49, 0x1d, 0xb6, 0x07, 0x0c,
	0x1d, 0x9e, 0x24, 0x32, 0xdb, 0x5a, 0xcf, 0x92, 0x33, 0x6c, 0x8c, 0x23, 0x1a, 0xc6, 0x98, 0x19,
	0x22, 0x23, 0x37, 0x44, 0xf7, 0xa0, 0xfc, 0x82, 0x7a, 0xb3, 0xe0, 0x6a, 0xb6, 0xde, 0x59, 0xbf,
	0x17, 0x61, 0x7b, 0xd8, 0xb7, 0xc5, 0x05, 0xda, 0x68, 0x28, 0x9b, 0x50, 0xd1, 0x49, 0x39, 0xdc,
	0x7d, 0xa7, 0xc3, 0x4f, 0x43, 0x42, 0xe3, 0x1a, 0x43, 0x0f, 0x99, 0xd2, 0x28, 0x29, 0x8d, 0x14,
	0x24, 0x92, 0xd3, 0x29, 0xc8, 0xb2, 0x97, 0xec, 0xa4, 0xc4, 0x4d, 0xa8, 0xa8, 0x01, 0x55, 0xb6,
	0x6a, 0xca, 0xd2, 0x90, 0x88, 0xed, 0x65, 0xa8, 0x47, 0x7e, 0x5b, 0x8a, 0x93, 0xbd, 0xb0, 0x16,
	0xfd, 0xeb, 0x45, 0x51, 0xe0, 0xa3, 0x57, 0x37, 0x95, 0x75, 0x0a, 0x22, 0x0f, 0xe1, 0xb3, 0xd9,
	0xf6, 0x7d, 0x8f, 0x73, 0x9c, 0x44, 0xbc, 0x7e, 0x47, 0xaa, 0x2d, 0xe0, 0x32, 0x53, 0xda, 0xc7,
	0x21, 0x06, 0x28, 0xda, 0x00, 0xf2, 0x6e, 0xa4, 0x21, 0x31, 0x7a, 0x3a, 0xf0, 0xd1, 0x24, 0x0a,
	0x7c, 0xd7, 0xe7, 0xb2, 0x9e, 0xf5, 0x8a, 0x4c, 0x6a, 0xa9, 0x8c, 0x1c, 0x42, 0x2d, 0xed, 0x25,
	0xae, 0x57, 0xa5, 0x72, 0x16, 0xb4, 0xfe, 0x2e, 0x40, 0x55, 0xea, 0xeb, 0x39, 0xdf, 0x94, 0xcd,
	0x4e, 0xb3, 0x5d, 0x2a, 0xac, 0xb3, 0xc9, 0x34, 0xef, 0x34, 0xdb, 0xbc, 0xe2, 0x5a, 0xc3, 0x74,
	0x4f, 0x8f, 0xe6, 0x3d, 0x2d, 0xad, 0x33, 0x4a, 0x5a, 0xfd, 0x38, 0xdb, 0xea, 0xad, 0x95, 0xac,
	0x9b, 0x69, 0x7f, 0x3b, 0xd5, 0xfe, 0xf2, 0x4a, 0x93, 0x44, 0xc7, 0xfa, 0xd9, 0x80, 0x8a, 0x2e,
	0x64, 0x3c, 0x0d, 0x38, 0x79, 0x34, 0x0f, 0x53, 0x15, 0xf2, 0x60, 0xfe, 0x19, 0xc9, 0x5d, 0xab,
	0x79, 0xa8, 0x75, 0xd8, 0xbe, 0x9e, 0xba, 0x2e, 0xc6, 0xb1, 0xac, 0xa4, 0x69, 0xcf, 0xb6, 0x82,
	0x16, 0x9f, 0xfb, 0x41, 0xe0, 0xc7, 0xe8, 0xd2, 0xd0, 0x8b, 0x67, 0x14, 0x9d, 0xc6, 0xac, 0x97,
	0xb0, 0xa5, 0x5a, 0x6f, 0x41, 0xf5, 0x82, 0xc6, 0x3c, 0x77, 0x55, 0x33, 0x98, 0xd0, 0x11, 0x5e,
	0x73, 0xd7, 0x2f, 0x83, 0x59, 0x7f, 0x15, 0x80, 0xc8, 0x13, 0x5f, 0x47, 0x9e, 0xc3, 0xf1, 0xcc,
	0xf1, 0x83, 0x29, 0x43, 0xf2, 0x25, 0x94, 0x55, 0x43, 0x74, 0x66, 0xb5, 0xb6, 0xfa, 0x92, 0xea,
	0xda, 0x6b, 0xa1, 0xe0, 0xa0, 0x33, 0xca, 0x6e, 0x1d, 0xe6, 0xf9, 0xe1, 0xf8, 0x19, 0x63, 0x94,
	0x69, 0x66, 0xc8, 0xc3, 0x62, 0x54, 0x6d, 0x74, 0xfd, 0xc8, 0xc7, 0x90, 0x0b, 0xd6, 0xd0, 0x24,
	0x9c, 0x05, 0xc9, 0x29, 0xec, 0x26, 0x80, 0x1e, 0xd1, 0xd2, 0x32, 0xff, 0x79, 0x2d, 0xf2, 0x00,
	0x40, 0x4d, 0x9e, 0x3c, 0x5b, 0xf1, 0x6f, 0x0a, 0x21, 0x27, 0x50, 0x4d, 0xd3, 0xa7, 0x6c, 0xf7,
	0xc2, 0xa9, 0x19, 0x15, 0x41, 0x0e, 0x09, 0xa1, 0x6b, 0x72, 0x48, 0x98, 0xfc, 0x0f, 0x03, 0x76,
	0x53, 0x55, 0x93, 0x5f, 0xe3, 0x4f, 0x2c, 0xd9, 0x26, 0x6f, 0x83, 0x2f, 0xd4, 0xf3, 0x43, 0xdf,
	0x9c, 0xdc, 0x81, 0xea, 0x65, 0xb2, 0x0f, 0x5b, 0x3d, 0xcf, 0xd3, 0xcc, 0x6e, 0xda, 0x6a, 0x63,
	0x75, 0xe1, 0xce, 0xd9, 0x34, 0x08, 0xd4, 0xa8, 0x7c, 0x05, 0x65, 0xb9, 0x98, 0x3d, 0x76, 0xee,
	0xce, 0xa7, 0x54, 0x93, 0xb6, 0xad, 0x15, 0xac, 0xa7, 0x40, 0xae, 0x30, 0x14, 0x5d, 0x1b, 0xbc,
	0x73, 0xc2, 0x31, 0xc6, 0xf2, 0xb1, 0xb4, 0xc1, 0x01, 0x5d, 0xb8, 0x23, 0x57, 0x1b, 0xda, 0x75,
	0xfe, 0x2b, 0x83, 0x79, 0x3d, 0x90, 0x1b, 0x46, 0x9e, 0xc0, 0xde, 0x2b, 0xe6, 0x8f, 0xc7, 0xc8,
	0x34, 0x63, 0xc9, 0x6f, 0x2e, 0x59, 0x4e, 0x02, 0x8d, 0x6a, 0x5b, 0xbf, 0x25, 0xbf, 0xa7, 0xbe,
	0x47, 0xbe, 0x05, 0xf3, 0x1c, 0xd7, 0x1b, 0x90, 0xec, 0x63, 0x4f, 0x86, 0x7a, 0x02, 0xd5, 0x01,
	0x9d, 0x4c, 0x9c, 0xd0, 0xb3, 0x31, 0x0a, 0xde, 0x93, 0xbd, 0xb4, 0xa9, 0x96, 0xe4, 0x3c, 0x5d,
	0xc0, 0xfe, 0x39, 0x72, 0x7d, 0xad, 0xcf, 0x98, 0xf8, 0xce, 0xb3, 0x1b, 0x64, 0xab, 0xbc, 0xae,
	0xe6, 0x06, 0x72, 0x0c, 0x66, 0xcf, 0xf3, 0x54, 0xb3, 0xee, 0xcd, 0xd5, 0xd2, 0x9c, 0x9d, 0xf3,
	0x7d, 0x0c, 0xe6, 0x10, 0x83, 0x4d, 0x2c, 0x3a, 0x9a, 0xba, 0xd4, 0xc0, 0x8a, 0x20, 0x73, 0x46,
	0x82, 0xd1, 0x72, 0x36, 0x5d, 0xd8, 0x55, 0x83, 0x78, 0x45, 0x6f, 0x91, 0xa1, 0xf7, 0x3a, 0xfa,
	0xb4, 0x1e, 0x74, 0x00, 0x7a, 0x9e, 0x37, 0x23, 0xbc, 0xbb, 0x0b, 0x89, 0x37, 0x16, 0x21, 0x72,
	0x2c, 0xf8, 0x61, 0x42, 0x6f, 0x70, 0x8d, 0x59, 0xd6, 0xcb, 0x13, 0xa8, 0x9e, 0x23, 0x9f, 0x8f,
	0xf9, 0x8a, 0xd0, 0xf6, 0xe6, 0xe7, 0xcc, 0x75, 0x9f, 0xc2, 0x5d, 0x39, 0x25, 0xe9, 0x51, 0x27,
	0x99, 0xe3, 0x1b, 0xf7, 0xd3, 0x53, 0xb2, 0x70, 0x25, 0x4e, 0xa4, 0xf3, 0x9e, 0x3e, 0x2f, 0x6f,
	0xbb, 0x97, 0xab, 0xae, 0x34, 0xb9, 0x84, 0xfd, 0x51, 0xf8, 0x96, 0xb2, 0xc9, 0x28, 0xbc, 0x71,
	0x02, 0x3f, 0xa9, 0xcf, 0xea, 0xc1, 0x58, 0x37, 0x33, 0xdf, 0x01, 0x0c, 0x9c, 0xc0, 0xd5, 0xee,
	0x3f, 0x9e, 0x7b, 0x12, 0x47, 0xff, 0x01, 0xdc, 0x0f, 0x91, 0xa7, 0x0d, 0xc4, 0xef, 0xa5, 0x44,
	0xf3, 0x4d, 0x59, 0xfe, 0x5a, 0x7a, 0xf4, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xce, 0x0f, 0x20,
	0x25, 0x03, 0x0e, 0x00, 0x00,
}
