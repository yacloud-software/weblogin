// Code generated by protoc-gen-go.
// source: golang.yacloud.eu/apis/uiobjects/uiobjects.proto
// DO NOT EDIT!

/*
Package uiobjects is a generated protocol buffer package.

It is generated from these files:
	golang.yacloud.eu/apis/uiobjects/uiobjects.proto

It has these top-level messages:
	Project
	Component
	Client
	Contract
	SLO
	SLA
	SRETeam
	DevTeam
	ProductTeam
	Employee
	DeliveryRole
	DeliveryTeam
	AuditTrail
	PerformanceReport
	API
	VersionedComponent
	Experiment
	RequestTrace
	TraceEntry
	LegacyBackend
	WebRoute
	User
	GitRepository
	GitHub
	Build
	Distribution
	Cost
	Budget
	ProductDescription
	Income
	BillingDescription
	SomeoneElsesComponent
	SomeoneElsesLibrary
	Permission
	MobileApp
	Hardware
	Firmware
	FirmwareHardwareCompatibility
	HardwareInTheWild
	WebSite
	Usage
	Report
	Alert
	Prober
	Dashboard
	SoftwareLibrary
*/
package uiobjects

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//
// We set out to solve something the world does not yet have,
// for example, "A Good Ticketing System"
type Project struct {
}

func (m *Project) Reset()                    { *m = Project{} }
func (m *Project) String() string            { return proto.CompactTextString(m) }
func (*Project) ProtoMessage()               {}
func (*Project) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

//
// a component maybe "github integration" as part of my new ticketing system
// or it might be much smaller, for example "is-it-a-bankholiday-service"
type Component struct {
}

func (m *Component) Reset()                    { *m = Component{} }
func (m *Component) String() string            { return proto.CompactTextString(m) }
func (*Component) ProtoMessage()               {}
func (*Component) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

//
// see "business objects" book and normalise this properly
type Client struct {
	SomeGoodNameForClients string `protobuf:"bytes,1,opt,name=SomeGoodNameForClients" json:"SomeGoodNameForClients,omitempty"`
}

func (m *Client) Reset()                    { *m = Client{} }
func (m *Client) String() string            { return proto.CompactTextString(m) }
func (*Client) ProtoMessage()               {}
func (*Client) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Client) GetSomeGoodNameForClients() string {
	if m != nil {
		return m.SomeGoodNameForClients
	}
	return ""
}

type Contract struct {
	Client *Client `protobuf:"bytes,1,opt,name=Client" json:"Client,omitempty"`
	SLAs   []*SLA  `protobuf:"bytes,2,rep,name=SLAs" json:"SLAs,omitempty"`
}

func (m *Contract) Reset()                    { *m = Contract{} }
func (m *Contract) String() string            { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()               {}
func (*Contract) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Contract) GetClient() *Client {
	if m != nil {
		return m.Client
	}
	return nil
}

func (m *Contract) GetSLAs() []*SLA {
	if m != nil {
		return m.SLAs
	}
	return nil
}

//
// set by product team, agreed by SRE & Dev, verified by project leader
type SLO struct {
	ComputerParseableDefinition string     `protobuf:"bytes,1,opt,name=ComputerParseableDefinition" json:"ComputerParseableDefinition,omitempty"`
	Component                   *Component `protobuf:"bytes,2,opt,name=Component" json:"Component,omitempty"`
}

func (m *SLO) Reset()                    { *m = SLO{} }
func (m *SLO) String() string            { return proto.CompactTextString(m) }
func (*SLO) ProtoMessage()               {}
func (*SLO) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SLO) GetComputerParseableDefinition() string {
	if m != nil {
		return m.ComputerParseableDefinition
	}
	return ""
}

func (m *SLO) GetComponent() *Component {
	if m != nil {
		return m.Component
	}
	return nil
}

// with clients. perhaps clients also have SLAs on components
type SLA struct {
	ComputerParseableDefinition string   `protobuf:"bytes,1,opt,name=ComputerParseableDefinition" json:"ComputerParseableDefinition,omitempty"`
	Project                     *Project `protobuf:"bytes,2,opt,name=Project" json:"Project,omitempty"`
	BackingSLOs                 []*SLO   `protobuf:"bytes,3,rep,name=BackingSLOs" json:"BackingSLOs,omitempty"`
}

func (m *SLA) Reset()                    { *m = SLA{} }
func (m *SLA) String() string            { return proto.CompactTextString(m) }
func (*SLA) ProtoMessage()               {}
func (*SLA) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SLA) GetComputerParseableDefinition() string {
	if m != nil {
		return m.ComputerParseableDefinition
	}
	return ""
}

func (m *SLA) GetProject() *Project {
	if m != nil {
		return m.Project
	}
	return nil
}

func (m *SLA) GetBackingSLOs() []*SLO {
	if m != nil {
		return m.BackingSLOs
	}
	return nil
}

type SRETeam struct {
	Employees []*Employee `protobuf:"bytes,1,rep,name=Employees" json:"Employees,omitempty"`
}

func (m *SRETeam) Reset()                    { *m = SRETeam{} }
func (m *SRETeam) String() string            { return proto.CompactTextString(m) }
func (*SRETeam) ProtoMessage()               {}
func (*SRETeam) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SRETeam) GetEmployees() []*Employee {
	if m != nil {
		return m.Employees
	}
	return nil
}

type DevTeam struct {
	Employees []*Employee `protobuf:"bytes,1,rep,name=Employees" json:"Employees,omitempty"`
}

func (m *DevTeam) Reset()                    { *m = DevTeam{} }
func (m *DevTeam) String() string            { return proto.CompactTextString(m) }
func (*DevTeam) ProtoMessage()               {}
func (*DevTeam) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *DevTeam) GetEmployees() []*Employee {
	if m != nil {
		return m.Employees
	}
	return nil
}

type ProductTeam struct {
	Employees []*Employee `protobuf:"bytes,1,rep,name=Employees" json:"Employees,omitempty"`
}

func (m *ProductTeam) Reset()                    { *m = ProductTeam{} }
func (m *ProductTeam) String() string            { return proto.CompactTextString(m) }
func (*ProductTeam) ProtoMessage()               {}
func (*ProductTeam) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ProductTeam) GetEmployees() []*Employee {
	if m != nil {
		return m.Employees
	}
	return nil
}

// should be a role, a candidate or a freelancer or so
type Employee struct {
	ToBeHired bool `protobuf:"varint,1,opt,name=ToBeHired" json:"ToBeHired,omitempty"`
}

func (m *Employee) Reset()                    { *m = Employee{} }
func (m *Employee) String() string            { return proto.CompactTextString(m) }
func (*Employee) ProtoMessage()               {}
func (*Employee) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Employee) GetToBeHired() bool {
	if m != nil {
		return m.ToBeHired
	}
	return false
}

//
// someone delivering something technical.
// probably missing plenty, like Client, UX, Finance, etc..
type DeliveryRole struct {
	SRETeam     *SRETeam     `protobuf:"bytes,1,opt,name=SRETeam" json:"SRETeam,omitempty"`
	DevTeam     *DevTeam     `protobuf:"bytes,2,opt,name=DevTeam" json:"DevTeam,omitempty"`
	ProductTeam *ProductTeam `protobuf:"bytes,3,opt,name=ProductTeam" json:"ProductTeam,omitempty"`
	ProjectLead *Employee    `protobuf:"bytes,4,opt,name=ProjectLead" json:"ProjectLead,omitempty"`
}

func (m *DeliveryRole) Reset()                    { *m = DeliveryRole{} }
func (m *DeliveryRole) String() string            { return proto.CompactTextString(m) }
func (*DeliveryRole) ProtoMessage()               {}
func (*DeliveryRole) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DeliveryRole) GetSRETeam() *SRETeam {
	if m != nil {
		return m.SRETeam
	}
	return nil
}

func (m *DeliveryRole) GetDevTeam() *DevTeam {
	if m != nil {
		return m.DevTeam
	}
	return nil
}

func (m *DeliveryRole) GetProductTeam() *ProductTeam {
	if m != nil {
		return m.ProductTeam
	}
	return nil
}

func (m *DeliveryRole) GetProjectLead() *Employee {
	if m != nil {
		return m.ProjectLead
	}
	return nil
}

type DeliveryTeam struct {
	Roles []*DeliveryRole `protobuf:"bytes,1,rep,name=Roles" json:"Roles,omitempty"`
}

func (m *DeliveryTeam) Reset()                    { *m = DeliveryTeam{} }
func (m *DeliveryTeam) String() string            { return proto.CompactTextString(m) }
func (*DeliveryTeam) ProtoMessage()               {}
func (*DeliveryTeam) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *DeliveryTeam) GetRoles() []*DeliveryRole {
	if m != nil {
		return m.Roles
	}
	return nil
}

//
// what did users do, which objects did they change
type AuditTrail struct {
}

func (m *AuditTrail) Reset()                    { *m = AuditTrail{} }
func (m *AuditTrail) String() string            { return proto.CompactTextString(m) }
func (*AuditTrail) ProtoMessage()               {}
func (*AuditTrail) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

//
// by client / by time / by contract / by commit / by Experiment
type PerformanceReport struct {
}

func (m *PerformanceReport) Reset()                    { *m = PerformanceReport{} }
func (m *PerformanceReport) String() string            { return proto.CompactTextString(m) }
func (*PerformanceReport) ProtoMessage()               {}
func (*PerformanceReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

//
// clients tend to use the historical method of building APIs,
// like having one big definition of an API. so we got to reflect
// that "thinking" somewhere.
// this should be derived (not manually managed)
type API struct {
}

func (m *API) Reset()                    { *m = API{} }
func (m *API) String() string            { return proto.CompactTextString(m) }
func (*API) ProtoMessage()               {}
func (*API) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type VersionedComponent struct {
	Version   uint64     `protobuf:"varint,1,opt,name=Version" json:"Version,omitempty"`
	Component *Component `protobuf:"bytes,2,opt,name=Component" json:"Component,omitempty"`
}

func (m *VersionedComponent) Reset()                    { *m = VersionedComponent{} }
func (m *VersionedComponent) String() string            { return proto.CompactTextString(m) }
func (*VersionedComponent) ProtoMessage()               {}
func (*VersionedComponent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *VersionedComponent) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *VersionedComponent) GetComponent() *Component {
	if m != nil {
		return m.Component
	}
	return nil
}

type Experiment struct {
	Components []*VersionedComponent `protobuf:"bytes,1,rep,name=Components" json:"Components,omitempty"`
	Result     *PerformanceReport    `protobuf:"bytes,2,opt,name=Result" json:"Result,omitempty"`
}

func (m *Experiment) Reset()                    { *m = Experiment{} }
func (m *Experiment) String() string            { return proto.CompactTextString(m) }
func (*Experiment) ProtoMessage()               {}
func (*Experiment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Experiment) GetComponents() []*VersionedComponent {
	if m != nil {
		return m.Components
	}
	return nil
}

func (m *Experiment) GetResult() *PerformanceReport {
	if m != nil {
		return m.Result
	}
	return nil
}

type RequestTrace struct {
	// when did it start
	Timestamp uint32 `protobuf:"varint,1,opt,name=Timestamp" json:"Timestamp,omitempty"`
	// which user requested stuff
	User *User `protobuf:"bytes,2,opt,name=User" json:"User,omitempty"`
	//
	// the requestid (which, for example, we return in a header, or
	// we in an errormessage on an API. This makes support way easier.
	// The RequestID is generated by yacloud (it might spawn multiple
	// external 3rd party components)
	RequestID uint64 `protobuf:"varint,3,opt,name=RequestID" json:"RequestID,omitempty"`
	// the entries
	TraceEntry []*TraceEntry `protobuf:"bytes,4,rep,name=TraceEntry" json:"TraceEntry,omitempty"`
}

func (m *RequestTrace) Reset()                    { *m = RequestTrace{} }
func (m *RequestTrace) String() string            { return proto.CompactTextString(m) }
func (*RequestTrace) ProtoMessage()               {}
func (*RequestTrace) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *RequestTrace) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *RequestTrace) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *RequestTrace) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *RequestTrace) GetTraceEntry() []*TraceEntry {
	if m != nil {
		return m.TraceEntry
	}
	return nil
}

type TraceEntry struct {
	Service   string `protobuf:"bytes,1,opt,name=Service" json:"Service,omitempty"`
	Method    string `protobuf:"bytes,2,opt,name=Method" json:"Method,omitempty"`
	Timestamp uint32 `protobuf:"varint,3,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Result    string `protobuf:"bytes,4,opt,name=Result" json:"Result,omitempty"`
}

func (m *TraceEntry) Reset()                    { *m = TraceEntry{} }
func (m *TraceEntry) String() string            { return proto.CompactTextString(m) }
func (*TraceEntry) ProtoMessage()               {}
func (*TraceEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *TraceEntry) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *TraceEntry) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *TraceEntry) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TraceEntry) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

//
// legacy backends, e.g. non-microservices or things serving html
// only (no apis) or so are represented here
// Examples are "lamp stack/symfony" or "ruby-on-rails" or "django" or some "IIS NT4.0 server"
type LegacyBackend struct {
	Name        string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Host        string `protobuf:"bytes,2,opt,name=Host" json:"Host,omitempty"`
	Port        uint32 `protobuf:"varint,3,opt,name=Port" json:"Port,omitempty"`
	RemoteUser  string `protobuf:"bytes,4,opt,name=RemoteUser" json:"RemoteUser,omitempty"`
	BearerToken string `protobuf:"bytes,5,opt,name=BearerToken" json:"BearerToken,omitempty"`
	//
	// does it send dodgy redirects? capture them and rewrite them?
	// does it want https or http traffic?
	// does it need some rate limiting?
	// does it need a user-create-on-the-fly method?
	// and more and more. See h2gproxy service for some ideas
	ThousandOptionsToHandleLegacyService []bool `protobuf:"varint,6,rep,packed,name=ThousandOptionsToHandleLegacyService" json:"ThousandOptionsToHandleLegacyService,omitempty"`
}

func (m *LegacyBackend) Reset()                    { *m = LegacyBackend{} }
func (m *LegacyBackend) String() string            { return proto.CompactTextString(m) }
func (*LegacyBackend) ProtoMessage()               {}
func (*LegacyBackend) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *LegacyBackend) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LegacyBackend) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *LegacyBackend) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *LegacyBackend) GetRemoteUser() string {
	if m != nil {
		return m.RemoteUser
	}
	return ""
}

func (m *LegacyBackend) GetBearerToken() string {
	if m != nil {
		return m.BearerToken
	}
	return ""
}

func (m *LegacyBackend) GetThousandOptionsToHandleLegacyService() []bool {
	if m != nil {
		return m.ThousandOptionsToHandleLegacyService
	}
	return nil
}

//
// this defines which url goes where.
// it is somewhat contentious. naming is hard and it is mostly based on opinion,
// yet often people claim to know "best practices". Thus this must have good, working generated defaults, and be fully customisable.
// For example, we can use the name of a legacyservice as basis to form a default path: "LegacyService.Name == ticket_system -> WebRoute.Path == /ticketsystem/"
type WebRoute struct {
	Host          []string       `protobuf:"bytes,1,rep,name=Host" json:"Host,omitempty"`
	Paths         []string       `protobuf:"bytes,2,rep,name=Paths" json:"Paths,omitempty"`
	LegacyBackend *LegacyBackend `protobuf:"bytes,3,opt,name=LegacyBackend" json:"LegacyBackend,omitempty"`
	Component     *Component     `protobuf:"bytes,4,opt,name=Component" json:"Component,omitempty"`
}

func (m *WebRoute) Reset()                    { *m = WebRoute{} }
func (m *WebRoute) String() string            { return proto.CompactTextString(m) }
func (*WebRoute) ProtoMessage()               {}
func (*WebRoute) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *WebRoute) GetHost() []string {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *WebRoute) GetPaths() []string {
	if m != nil {
		return m.Paths
	}
	return nil
}

func (m *WebRoute) GetLegacyBackend() *LegacyBackend {
	if m != nil {
		return m.LegacyBackend
	}
	return nil
}

func (m *WebRoute) GetComponent() *Component {
	if m != nil {
		return m.Component
	}
	return nil
}

//
// this user account is provided by yacloud
type User struct {
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

//
// we somehow need to represent this so that we can muck about with settings
// of it. Perhaps not? probably derived from components.
// does this need permissions? one repository may contain multiple sources in multiple languages
type GitRepository struct {
	Component *Component `protobuf:"bytes,1,opt,name=Component" json:"Component,omitempty"`
	// parse and build java
	Java bool `protobuf:"varint,2,opt,name=Java" json:"Java,omitempty"`
	// parse and build Go
	Go bool `protobuf:"varint,3,opt,name=Go" json:"Go,omitempty"`
	// parse and build Protos
	Protos bool `protobuf:"varint,4,opt,name=Protos" json:"Protos,omitempty"`
	// parse and build electronic Designs made by Kicad
	Kicad bool `protobuf:"varint,5,opt,name=Kicad" json:"Kicad,omitempty"`
	// send upstream to github on change:
	Github *GitHub `protobuf:"bytes,6,opt,name=Github" json:"Github,omitempty"`
}

func (m *GitRepository) Reset()                    { *m = GitRepository{} }
func (m *GitRepository) String() string            { return proto.CompactTextString(m) }
func (*GitRepository) ProtoMessage()               {}
func (*GitRepository) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *GitRepository) GetComponent() *Component {
	if m != nil {
		return m.Component
	}
	return nil
}

func (m *GitRepository) GetJava() bool {
	if m != nil {
		return m.Java
	}
	return false
}

func (m *GitRepository) GetGo() bool {
	if m != nil {
		return m.Go
	}
	return false
}

func (m *GitRepository) GetProtos() bool {
	if m != nil {
		return m.Protos
	}
	return false
}

func (m *GitRepository) GetKicad() bool {
	if m != nil {
		return m.Kicad
	}
	return false
}

func (m *GitRepository) GetGithub() *GitHub {
	if m != nil {
		return m.Github
	}
	return nil
}

// *
// people might use github as well as our git repos.
// it is also useful to define it if we are receiving updates from github.
type GitHub struct {
	Githubstuff string `protobuf:"bytes,1,opt,name=Githubstuff" json:"Githubstuff,omitempty"`
}

func (m *GitHub) Reset()                    { *m = GitHub{} }
func (m *GitHub) String() string            { return proto.CompactTextString(m) }
func (*GitHub) ProtoMessage()               {}
func (*GitHub) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *GitHub) GetGithubstuff() string {
	if m != nil {
		return m.Githubstuff
	}
	return ""
}

//
// This is basically directly after the compiler step, self contained.
// a "build" can probably be somewhat executed by itself for limited testing.
// It might also be something that is not deployable but useful to build, like
// documentation, firmware, or so
type Build struct {
	Version   uint64         `protobuf:"varint,1,opt,name=Version" json:"Version,omitempty"`
	Repo      *GitRepository `protobuf:"bytes,2,opt,name=Repo" json:"Repo,omitempty"`
	Timestamp uint32         `protobuf:"varint,3,opt,name=Timestamp" json:"Timestamp,omitempty"`
}

func (m *Build) Reset()                    { *m = Build{} }
func (m *Build) String() string            { return proto.CompactTextString(m) }
func (*Build) ProtoMessage()               {}
func (*Build) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *Build) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Build) GetRepo() *GitRepository {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *Build) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

//
// this is deployable. It might be multiple builds, for example we might
// need the compiled outputs from multiple builds to start up something useful.
// Good architechture probably leads to 1 Build == 1 Distribution.
// So this is propably more a 'wrapper' to wrap a raw comiled "thing" into something a bit more useful.
type Distribution struct {
	Builds              []*Build `protobuf:"bytes,1,rep,name=Builds" json:"Builds,omitempty"`
	AvailableAsTar      bool     `protobuf:"varint,2,opt,name=AvailableAsTar" json:"AvailableAsTar,omitempty"`
	AvailableAsZip      bool     `protobuf:"varint,3,opt,name=AvailableAsZip" json:"AvailableAsZip,omitempty"`
	AvailableAsJar      bool     `protobuf:"varint,4,opt,name=AvailableAsJar" json:"AvailableAsJar,omitempty"`
	AvailableAsDocker   bool     `protobuf:"varint,5,opt,name=AvailableAsDocker" json:"AvailableAsDocker,omitempty"`
	AvailableAsKVMImage bool     `protobuf:"varint,6,opt,name=AvailableAsKVMImage" json:"AvailableAsKVMImage,omitempty"`
}

func (m *Distribution) Reset()                    { *m = Distribution{} }
func (m *Distribution) String() string            { return proto.CompactTextString(m) }
func (*Distribution) ProtoMessage()               {}
func (*Distribution) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *Distribution) GetBuilds() []*Build {
	if m != nil {
		return m.Builds
	}
	return nil
}

func (m *Distribution) GetAvailableAsTar() bool {
	if m != nil {
		return m.AvailableAsTar
	}
	return false
}

func (m *Distribution) GetAvailableAsZip() bool {
	if m != nil {
		return m.AvailableAsZip
	}
	return false
}

func (m *Distribution) GetAvailableAsJar() bool {
	if m != nil {
		return m.AvailableAsJar
	}
	return false
}

func (m *Distribution) GetAvailableAsDocker() bool {
	if m != nil {
		return m.AvailableAsDocker
	}
	return false
}

func (m *Distribution) GetAvailableAsKVMImage() bool {
	if m != nil {
		return m.AvailableAsKVMImage
	}
	return false
}

//
// Tracking Cost transparently is really important, yet quite difficult to do well. Either way it is very important
type Cost struct {
}

func (m *Cost) Reset()                    { *m = Cost{} }
func (m *Cost) String() string            { return proto.CompactTextString(m) }
func (*Cost) ProtoMessage()               {}
func (*Cost) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

//
// it's nice to be able track the ideas against something quantifyable
// throughou the project (PRINCE2-Style ;) )
type Budget struct {
}

func (m *Budget) Reset()                    { *m = Budget{} }
func (m *Budget) String() string            { return proto.CompactTextString(m) }
func (*Budget) ProtoMessage()               {}
func (*Budget) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

//
// really what I want is whole workflow here to moderate the negotations
// between cost/product/ux/engineering and operations to come up with
// a good and realistic balance here.
type ProductDescription struct {
	TextsUsecasesWhatever string              `protobuf:"bytes,1,opt,name=TextsUsecasesWhatever" json:"TextsUsecasesWhatever,omitempty"`
	SLOs                  []*SLO              `protobuf:"bytes,2,rep,name=SLOs" json:"SLOs,omitempty"`
	HowToBill             *BillingDescription `protobuf:"bytes,3,opt,name=HowToBill" json:"HowToBill,omitempty"`
}

func (m *ProductDescription) Reset()                    { *m = ProductDescription{} }
func (m *ProductDescription) String() string            { return proto.CompactTextString(m) }
func (*ProductDescription) ProtoMessage()               {}
func (*ProductDescription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *ProductDescription) GetTextsUsecasesWhatever() string {
	if m != nil {
		return m.TextsUsecasesWhatever
	}
	return ""
}

func (m *ProductDescription) GetSLOs() []*SLO {
	if m != nil {
		return m.SLOs
	}
	return nil
}

func (m *ProductDescription) GetHowToBill() *BillingDescription {
	if m != nil {
		return m.HowToBill
	}
	return nil
}

//
// Income comes from say usage payments.
type Income struct {
	BitCoin float32             `protobuf:"fixed32,1,opt,name=BitCoin" json:"BitCoin,omitempty"`
	Source  *BillingDescription `protobuf:"bytes,2,opt,name=Source" json:"Source,omitempty"`
	Payee   *User               `protobuf:"bytes,3,opt,name=Payee" json:"Payee,omitempty"`
}

func (m *Income) Reset()                    { *m = Income{} }
func (m *Income) String() string            { return proto.CompactTextString(m) }
func (*Income) ProtoMessage()               {}
func (*Income) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *Income) GetBitCoin() float32 {
	if m != nil {
		return m.BitCoin
	}
	return 0
}

func (m *Income) GetSource() *BillingDescription {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Income) GetPayee() *User {
	if m != nil {
		return m.Payee
	}
	return nil
}

//
// we define it and it happens :)
// yacloud offers billing-as-a-service, just submit this and yacloud
// takes care of getting the users agreement, credit card details etc
type BillingDescription struct {
	Definition string `protobuf:"bytes,1,opt,name=Definition" json:"Definition,omitempty"`
}

func (m *BillingDescription) Reset()                    { *m = BillingDescription{} }
func (m *BillingDescription) String() string            { return proto.CompactTextString(m) }
func (*BillingDescription) ProtoMessage()               {}
func (*BillingDescription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *BillingDescription) GetDefinition() string {
	if m != nil {
		return m.Definition
	}
	return ""
}

//
// 3rd party projects/components I want to use.
// Examples are:
// databases (behind an API)
// object stores
// Tensorflow
// OtherAI
// Blockchain something something
// Queues
// Send-an-Email-Service
// Send-an-SMS-Service
// Send-a-complaint-to-the-prime-minister-service
type SomeoneElsesComponent struct {
	//
	// if true, First time a user uses one of my components and indirectly triggers
	// somoneelsescomponent the cost of that is (accountingwise) allocated to the users'
	// bill.
	AccountUserDirectly bool `protobuf:"varint,1,opt,name=AccountUserDirectly" json:"AccountUserDirectly,omitempty"`
	//
	// we might list this component on our invoice to the user or hide it in our price,
	// depends on our business model
	ProxyInvoice bool `protobuf:"varint,2,opt,name=ProxyInvoice" json:"ProxyInvoice,omitempty"`
}

func (m *SomeoneElsesComponent) Reset()                    { *m = SomeoneElsesComponent{} }
func (m *SomeoneElsesComponent) String() string            { return proto.CompactTextString(m) }
func (*SomeoneElsesComponent) ProtoMessage()               {}
func (*SomeoneElsesComponent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *SomeoneElsesComponent) GetAccountUserDirectly() bool {
	if m != nil {
		return m.AccountUserDirectly
	}
	return false
}

func (m *SomeoneElsesComponent) GetProxyInvoice() bool {
	if m != nil {
		return m.ProxyInvoice
	}
	return false
}

//
// we also have some legacy software which is not yet available as a service.
// such software is typically added as a library. If so I want to know which
// and which license it is. I like the yacloud to manage that, its dependencies
// and availability for me please.
type SomeoneElsesLibrary struct {
	Name    string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	License string `protobuf:"bytes,2,opt,name=License" json:"License,omitempty"`
}

func (m *SomeoneElsesLibrary) Reset()                    { *m = SomeoneElsesLibrary{} }
func (m *SomeoneElsesLibrary) String() string            { return proto.CompactTextString(m) }
func (*SomeoneElsesLibrary) ProtoMessage()               {}
func (*SomeoneElsesLibrary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *SomeoneElsesLibrary) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SomeoneElsesLibrary) GetLicense() string {
	if m != nil {
		return m.License
	}
	return ""
}

//
// god knows how this works. But I do need to manage shed loads of permissions:
// developers' access to repositories, access to my website etc.., access to invoices,
// permissions to certain builds to suppliers,
type Permission struct {
}

func (m *Permission) Reset()                    { *m = Permission{} }
func (m *Permission) String() string            { return proto.CompactTextString(m) }
func (*Permission) ProtoMessage()               {}
func (*Permission) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

//
// it is something that people do. It needs to be somewhere in here. It might be linked to a
// project but it might equally well be a project in its own right. There is a lot we can help here with:
// 1. provide authenticated/secure/rpc between backend & mobileapp
// 2. pairing (e.g. user on mobileapp to backend link)
// 3. messaging/notification
// 4. deployment to app-store/playstore
// 5. reports which versions are 'out there in the wild'
// The above could be almost entirely automatically provided w/o developers doing stuff
type MobileApp struct {
}

func (m *MobileApp) Reset()                    { *m = MobileApp{} }
func (m *MobileApp) String() string            { return proto.CompactTextString(m) }
func (*MobileApp) ProtoMessage()               {}
func (*MobileApp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

//
// some bit that we are building. It probably links into our backend somehow, so it needs
// to be manageble. It also has builds and so on
type Hardware struct {
	Blueprints []*Build `protobuf:"bytes,1,rep,name=Blueprints" json:"Blueprints,omitempty"`
}

func (m *Hardware) Reset()                    { *m = Hardware{} }
func (m *Hardware) String() string            { return proto.CompactTextString(m) }
func (*Hardware) ProtoMessage()               {}
func (*Hardware) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *Hardware) GetBlueprints() []*Build {
	if m != nil {
		return m.Blueprints
	}
	return nil
}

//
// some software :)
type Firmware struct {
	Name  string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Build *Build `protobuf:"bytes,2,opt,name=Build" json:"Build,omitempty"`
}

func (m *Firmware) Reset()                    { *m = Firmware{} }
func (m *Firmware) String() string            { return proto.CompactTextString(m) }
func (*Firmware) ProtoMessage()               {}
func (*Firmware) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *Firmware) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Firmware) GetBuild() *Build {
	if m != nil {
		return m.Build
	}
	return nil
}

//
// we track which firmware is compatible with which hardware
type FirmwareHardwareCompatibility struct {
	Hardware           *Build   `protobuf:"bytes,1,opt,name=Hardware" json:"Hardware,omitempty"`
	CompatibleFirmware []*Build `protobuf:"bytes,2,rep,name=CompatibleFirmware" json:"CompatibleFirmware,omitempty"`
}

func (m *FirmwareHardwareCompatibility) Reset()                    { *m = FirmwareHardwareCompatibility{} }
func (m *FirmwareHardwareCompatibility) String() string            { return proto.CompactTextString(m) }
func (*FirmwareHardwareCompatibility) ProtoMessage()               {}
func (*FirmwareHardwareCompatibility) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *FirmwareHardwareCompatibility) GetHardware() *Build {
	if m != nil {
		return m.Hardware
	}
	return nil
}

func (m *FirmwareHardwareCompatibility) GetCompatibleFirmware() []*Build {
	if m != nil {
		return m.CompatibleFirmware
	}
	return nil
}

//
// list of hardware we got
type HardwareInTheWild struct {
	LegalOwner   *User  `protobuf:"bytes,1,opt,name=LegalOwner" json:"LegalOwner,omitempty"`
	SerialNumber string `protobuf:"bytes,2,opt,name=SerialNumber" json:"SerialNumber,omitempty"`
	// firmware bits installed
	Firmware []*Build `protobuf:"bytes,3,rep,name=Firmware" json:"Firmware,omitempty"`
}

func (m *HardwareInTheWild) Reset()                    { *m = HardwareInTheWild{} }
func (m *HardwareInTheWild) String() string            { return proto.CompactTextString(m) }
func (*HardwareInTheWild) ProtoMessage()               {}
func (*HardwareInTheWild) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *HardwareInTheWild) GetLegalOwner() *User {
	if m != nil {
		return m.LegalOwner
	}
	return nil
}

func (m *HardwareInTheWild) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *HardwareInTheWild) GetFirmware() []*Build {
	if m != nil {
		return m.Firmware
	}
	return nil
}

//
// This might just be a component. But it is also what people think about when they say "Project".
// If it's shiny it is good. So it deserves its own mention
type WebSite struct {
}

func (m *WebSite) Reset()                    { *m = WebSite{} }
func (m *WebSite) String() string            { return proto.CompactTextString(m) }
func (*WebSite) ProtoMessage()               {}
func (*WebSite) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

//
// I want to know how much money we make from a user and how much they cost us in therms of resources etc
type Usage struct {
	StartTimestamp uint32 `protobuf:"varint,1,opt,name=StartTimestamp" json:"StartTimestamp,omitempty"`
	EndTimestamp   uint32 `protobuf:"varint,2,opt,name=EndTimestamp" json:"EndTimestamp,omitempty"`
	User           *User  `protobuf:"bytes,3,opt,name=User" json:"User,omitempty"`
	APICalls       string `protobuf:"bytes,4,opt,name=APICalls" json:"APICalls,omitempty"`
	Others         string `protobuf:"bytes,5,opt,name=Others" json:"Others,omitempty"`
	Utilisation    string `protobuf:"bytes,6,opt,name=Utilisation" json:"Utilisation,omitempty"`
}

func (m *Usage) Reset()                    { *m = Usage{} }
func (m *Usage) String() string            { return proto.CompactTextString(m) }
func (*Usage) ProtoMessage()               {}
func (*Usage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *Usage) GetStartTimestamp() uint32 {
	if m != nil {
		return m.StartTimestamp
	}
	return 0
}

func (m *Usage) GetEndTimestamp() uint32 {
	if m != nil {
		return m.EndTimestamp
	}
	return 0
}

func (m *Usage) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Usage) GetAPICalls() string {
	if m != nil {
		return m.APICalls
	}
	return ""
}

func (m *Usage) GetOthers() string {
	if m != nil {
		return m.Others
	}
	return ""
}

func (m *Usage) GetUtilisation() string {
	if m != nil {
		return m.Utilisation
	}
	return ""
}

//
// I want pretty shiny online reports AND granular access to the data below.
// I am a geek but my colleagues usually are not as excited about data as I am :)
type Report struct {
	//
	// example data. not yet sure what it all needs to contain.
	// This is an interesting section because it has the potential to solve a lot of problems.
	// Example Questions I need the yacloud to answer "automagically":
	// which users are using which APIs in the past 3 months
	// what are my api usage patterns (drilldown into per-user level)
	// how much does a component cost me to operate?
	// how much does it cost me to provide services to a given user?
	// how much money do I make from a given user?
	// who contributes how much code?
	// do people work on weekends/out-of-hours? (IMHO this is an "alarm condition")
	// SLOs,
	// SLAs,
	// financials
	// usage,
	// consumption,
	// utilisation,
	// rate of commits
	// and all of the above by user are all potential candidates
	SomeData []uint64 `protobuf:"varint,1,rep,packed,name=SomeData" json:"SomeData,omitempty"`
}

func (m *Report) Reset()                    { *m = Report{} }
func (m *Report) String() string            { return proto.CompactTextString(m) }
func (*Report) ProtoMessage()               {}
func (*Report) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *Report) GetSomeData() []uint64 {
	if m != nil {
		return m.SomeData
	}
	return nil
}

//
// if I have data I want alerts. This is closely releated to reports. Anything I report
// on, I can Alert on. vice-versa: if i can alert on it, I can report on it.
// Essentially an Alert is a definition of a report outside some defined bounds.
// I like most (~90%) to be automatically generated and maintained on other information we have.
// for example, if the product team says "these are the SLOs" then we can immediately set up alarms on those.
// if usage or response patterns change significantly and quickly, maybe that is worth an alert too?
type Alert struct {
}

func (m *Alert) Reset()                    { *m = Alert{} }
func (m *Alert) String() string            { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()               {}
func (*Alert) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

//
// Most probers can probably be automatically generated, but some framework/guidelines how to write
// custom ones is useful. The output of probers feeds into reports/alerts.
// Probers can also be used to verify "new code". It replaces the "old-style" of testing in an isolated
// environment. In this scenario, _everything_ gets send to "production" (afterall we only got one "internet").
// then some traffic is sent to the "new code", initially it is probably a good idea to only send "prober traffic" to the new code. Once the probers are happy, maybe start sending some client traffic and ramp it up.
// This is useful for managers and senior engineers - it reasonably accurately predicts how a given update will
// affect the service to users (as opposed to say "unit" tests or tests in a test environment which say, just that:
// how does a unit behave or how does it behave in a test environemnt, but usually bear little information on live behaviour)
type Prober struct {
}

func (m *Prober) Reset()                    { *m = Prober{} }
func (m *Prober) String() string            { return proto.CompactTextString(m) }
func (*Prober) ProtoMessage()               {}
func (*Prober) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

//
// pretty much the same as reports and alerts but realtime and somewhat customisable.
// Grafana+Prometheus do a good job :) Jaeger should also be
// automagically integrated (https://www.jaegertracing.io/)
// It's important to note that almost all the metrics are automatically collected.
// Developers may (and should) expose additional one on the software they write.
// These metrics will be shown automatically in here (and in reports)
type Dashboard struct {
}

func (m *Dashboard) Reset()                    { *m = Dashboard{} }
func (m *Dashboard) String() string            { return proto.CompactTextString(m) }
func (*Dashboard) ProtoMessage()               {}
func (*Dashboard) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

//
// This is some artefact which comes out of the build pipeline. This can be, for example,
// a jar file that is to be published with a pom for maven/gradle. Or a golang module, or
// a ruby gem (yak) or a C .so or .dll or so.
// The yacloud should do The Right Thing automatically, like publishing it in a maven-compatible format if user says so.
// Either way it is something other people can use. Maybe only employees or teams can use it.
// Permissions are important here too.
type SoftwareLibrary struct {
}

func (m *SoftwareLibrary) Reset()                    { *m = SoftwareLibrary{} }
func (m *SoftwareLibrary) String() string            { return proto.CompactTextString(m) }
func (*SoftwareLibrary) ProtoMessage()               {}
func (*SoftwareLibrary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func init() {
	proto.RegisterType((*Project)(nil), "uiobjects.Project")
	proto.RegisterType((*Component)(nil), "uiobjects.Component")
	proto.RegisterType((*Client)(nil), "uiobjects.Client")
	proto.RegisterType((*Contract)(nil), "uiobjects.Contract")
	proto.RegisterType((*SLO)(nil), "uiobjects.SLO")
	proto.RegisterType((*SLA)(nil), "uiobjects.SLA")
	proto.RegisterType((*SRETeam)(nil), "uiobjects.SRETeam")
	proto.RegisterType((*DevTeam)(nil), "uiobjects.DevTeam")
	proto.RegisterType((*ProductTeam)(nil), "uiobjects.ProductTeam")
	proto.RegisterType((*Employee)(nil), "uiobjects.Employee")
	proto.RegisterType((*DeliveryRole)(nil), "uiobjects.DeliveryRole")
	proto.RegisterType((*DeliveryTeam)(nil), "uiobjects.DeliveryTeam")
	proto.RegisterType((*AuditTrail)(nil), "uiobjects.AuditTrail")
	proto.RegisterType((*PerformanceReport)(nil), "uiobjects.PerformanceReport")
	proto.RegisterType((*API)(nil), "uiobjects.API")
	proto.RegisterType((*VersionedComponent)(nil), "uiobjects.VersionedComponent")
	proto.RegisterType((*Experiment)(nil), "uiobjects.Experiment")
	proto.RegisterType((*RequestTrace)(nil), "uiobjects.RequestTrace")
	proto.RegisterType((*TraceEntry)(nil), "uiobjects.TraceEntry")
	proto.RegisterType((*LegacyBackend)(nil), "uiobjects.LegacyBackend")
	proto.RegisterType((*WebRoute)(nil), "uiobjects.WebRoute")
	proto.RegisterType((*User)(nil), "uiobjects.User")
	proto.RegisterType((*GitRepository)(nil), "uiobjects.GitRepository")
	proto.RegisterType((*GitHub)(nil), "uiobjects.GitHub")
	proto.RegisterType((*Build)(nil), "uiobjects.Build")
	proto.RegisterType((*Distribution)(nil), "uiobjects.Distribution")
	proto.RegisterType((*Cost)(nil), "uiobjects.Cost")
	proto.RegisterType((*Budget)(nil), "uiobjects.Budget")
	proto.RegisterType((*ProductDescription)(nil), "uiobjects.ProductDescription")
	proto.RegisterType((*Income)(nil), "uiobjects.Income")
	proto.RegisterType((*BillingDescription)(nil), "uiobjects.BillingDescription")
	proto.RegisterType((*SomeoneElsesComponent)(nil), "uiobjects.SomeoneElsesComponent")
	proto.RegisterType((*SomeoneElsesLibrary)(nil), "uiobjects.SomeoneElsesLibrary")
	proto.RegisterType((*Permission)(nil), "uiobjects.Permission")
	proto.RegisterType((*MobileApp)(nil), "uiobjects.MobileApp")
	proto.RegisterType((*Hardware)(nil), "uiobjects.Hardware")
	proto.RegisterType((*Firmware)(nil), "uiobjects.Firmware")
	proto.RegisterType((*FirmwareHardwareCompatibility)(nil), "uiobjects.FirmwareHardwareCompatibility")
	proto.RegisterType((*HardwareInTheWild)(nil), "uiobjects.HardwareInTheWild")
	proto.RegisterType((*WebSite)(nil), "uiobjects.WebSite")
	proto.RegisterType((*Usage)(nil), "uiobjects.Usage")
	proto.RegisterType((*Report)(nil), "uiobjects.Report")
	proto.RegisterType((*Alert)(nil), "uiobjects.Alert")
	proto.RegisterType((*Prober)(nil), "uiobjects.Prober")
	proto.RegisterType((*Dashboard)(nil), "uiobjects.Dashboard")
	proto.RegisterType((*SoftwareLibrary)(nil), "uiobjects.SoftwareLibrary")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for UIObjects service

type UIObjectsClient interface {
	CreateProject(ctx context.Context, in *Project, opts ...grpc.CallOption) (*Project, error)
}

type uIObjectsClient struct {
	cc *grpc.ClientConn
}

func NewUIObjectsClient(cc *grpc.ClientConn) UIObjectsClient {
	return &uIObjectsClient{cc}
}

func (c *uIObjectsClient) CreateProject(ctx context.Context, in *Project, opts ...grpc.CallOption) (*Project, error) {
	out := new(Project)
	err := grpc.Invoke(ctx, "/uiobjects.UIObjects/CreateProject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UIObjects service

type UIObjectsServer interface {
	CreateProject(context.Context, *Project) (*Project, error)
}

func RegisterUIObjectsServer(s *grpc.Server, srv UIObjectsServer) {
	s.RegisterService(&_UIObjects_serviceDesc, srv)
}

func _UIObjects_CreateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Project)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UIObjectsServer).CreateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/uiobjects.UIObjects/CreateProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UIObjectsServer).CreateProject(ctx, req.(*Project))
	}
	return interceptor(ctx, in, info, handler)
}

var _UIObjects_serviceDesc = grpc.ServiceDesc{
	ServiceName: "uiobjects.UIObjects",
	HandlerType: (*UIObjectsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProject",
			Handler:    _UIObjects_CreateProject_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.yacloud.eu/apis/uiobjects/uiobjects.proto",
}

func init() { proto.RegisterFile("golang.yacloud.eu/apis/uiobjects/uiobjects.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1581 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x57, 0xdd, 0x72, 0x1b, 0x49,
	0x15, 0x2e, 0x59, 0xb2, 0x2c, 0x1d, 0x3b, 0x59, 0xdc, 0xd9, 0x04, 0xd5, 0xee, 0x86, 0x4a, 0x35,
	0xcb, 0x96, 0xa1, 0x4c, 0x12, 0x42, 0x02, 0x54, 0xb1, 0x4b, 0x45, 0xb6, 0x1c, 0x5b, 0xbb, 0xca,
	0x4a, 0xd5, 0x92, 0x37, 0x05, 0x77, 0x3d, 0x33, 0xc7, 0x52, 0x93, 0x99, 0x69, 0xd1, 0xdd, 0xe3,
	0x44, 0xc5, 0x0d, 0x3c, 0x01, 0x5c, 0xf1, 0x08, 0x40, 0x15, 0x2f, 0xc1, 0x13, 0xf0, 0x02, 0x5c,
	0xf1, 0x26, 0x54, 0xf7, 0xf4, 0x68, 0x46, 0x3f, 0x6b, 0x52, 0x29, 0xee, 0xa6, 0xcf, 0x39, 0x7d,
	0x7e, 0xbe, 0xf3, 0xd3, 0x67, 0xe0, 0xf1, 0x54, 0xc6, 0x3c, 0x9d, 0x3e, 0x5c, 0xf0, 0x30, 0x96,
	0x59, 0xf4, 0x10, 0xb3, 0x47, 0x7c, 0x2e, 0xf4, 0xa3, 0x4c, 0xc8, 0xe0, 0xb7, 0x18, 0x9a, 0xca,
	0xd7, 0xc3, 0xb9, 0x92, 0x46, 0x92, 0xf6, 0x92, 0x40, 0xdb, 0xb0, 0x37, 0x52, 0xd2, 0x7e, 0xd3,
	0x7d, 0x68, 0x9f, 0xca, 0x64, 0x2e, 0x53, 0x4c, 0x0d, 0x7d, 0x0e, 0xcd, 0xd3, 0x58, 0x60, 0x6a,
	0xc8, 0xcf, 0xe0, 0xde, 0x58, 0x26, 0x78, 0x2e, 0x65, 0xf4, 0x35, 0x4f, 0xf0, 0x85, 0x54, 0x39,
	0x43, 0x77, 0x6a, 0x0f, 0x6a, 0x47, 0x6d, 0xf6, 0x2d, 0x5c, 0xfa, 0x6b, 0x68, 0x9d, 0xca, 0xd4,
	0x28, 0x1e, 0x1a, 0xf2, 0xc3, 0x42, 0x9b, 0xbb, 0xb3, 0xff, 0xe4, 0xf0, 0x61, 0xe9, 0x52, 0xce,
	0x60, 0x85, 0x39, 0x0a, 0x8d, 0xf1, 0xa0, 0xab, 0x3b, 0x3b, 0x0f, 0xea, 0x47, 0xfb, 0x4f, 0x6e,
	0x57, 0x04, 0xc7, 0x83, 0x2e, 0x73, 0x3c, 0xfa, 0x7b, 0xa8, 0x8f, 0x07, 0x43, 0xf2, 0x1c, 0x3e,
	0xb6, 0x0e, 0x67, 0x06, 0xd5, 0x88, 0x2b, 0x8d, 0x3c, 0x88, 0xb1, 0x87, 0x57, 0x22, 0x15, 0x46,
	0xc8, 0xd4, 0xbb, 0x77, 0x93, 0x08, 0x79, 0x52, 0x09, 0xb9, 0xb3, 0xe3, 0x5c, 0xfb, 0xb0, 0xea,
	0x5a, 0xc1, 0x63, 0x15, 0x64, 0xfe, 0x56, 0xb3, 0xd6, 0xbb, 0xff, 0x07, 0xeb, 0xc7, 0x4b, 0xec,
	0xbd, 0x6d, 0x52, 0xb1, 0xed, 0x39, 0xac, 0x10, 0x21, 0x8f, 0x61, 0xff, 0x84, 0x87, 0xaf, 0x45,
	0x3a, 0x1d, 0x0f, 0x86, 0xba, 0x53, 0xdf, 0x82, 0xcf, 0x90, 0x55, 0x45, 0xe8, 0xe7, 0xb0, 0x37,
	0x66, 0x67, 0x13, 0xe4, 0x09, 0xf9, 0x09, 0xb4, 0xcf, 0x92, 0x79, 0x2c, 0x17, 0x88, 0x36, 0x6f,
	0xf6, 0xea, 0x9d, 0xca, 0xd5, 0x82, 0xc7, 0x4a, 0x29, 0x7b, 0xbb, 0x87, 0xd7, 0xef, 0x7b, 0xfb,
	0x39, 0xec, 0x8f, 0x94, 0x8c, 0xb2, 0xd0, 0xbc, 0xaf, 0x86, 0x23, 0x68, 0x15, 0x07, 0xf2, 0x09,
	0xb4, 0x27, 0xf2, 0x04, 0x2f, 0x84, 0xc2, 0xc8, 0x21, 0xdb, 0x62, 0x25, 0x81, 0xfe, 0xbb, 0x06,
	0x07, 0x3d, 0x8c, 0xc5, 0x35, 0xaa, 0x05, 0x93, 0x31, 0x5a, 0x60, 0x7d, 0xe0, 0xbe, 0xde, 0xaa,
	0xc0, 0x7a, 0x0e, 0x5b, 0x62, 0x73, 0xbc, 0x0c, 0x74, 0x4b, 0x1a, 0x3c, 0x87, 0x2d, 0xb1, 0xf8,
	0xc5, 0x4a, 0x60, 0x9d, 0xba, 0xbb, 0x71, 0x6f, 0x35, 0x71, 0x05, 0x97, 0xad, 0x60, 0xf0, 0xcc,
	0xdd, 0xb4, 0x42, 0x03, 0xe4, 0x51, 0xa7, 0xe1, 0x6e, 0x6e, 0x45, 0xa1, 0x2a, 0x47, 0xbf, 0x28,
	0x83, 0x73, 0x6a, 0x7e, 0x0c, 0xbb, 0x36, 0xc8, 0x02, 0xc6, 0xef, 0xae, 0x38, 0x5b, 0x82, 0xc0,
	0x72, 0x29, 0x7a, 0x00, 0xd0, 0xcd, 0x22, 0x61, 0x26, 0x8a, 0x8b, 0x98, 0xde, 0x81, 0xc3, 0x11,
	0xaa, 0x2b, 0xa9, 0x12, 0x9e, 0x86, 0xc8, 0x70, 0x2e, 0x95, 0xa1, 0xbb, 0x50, 0xef, 0x8e, 0xfa,
	0x34, 0x00, 0xf2, 0x0d, 0x2a, 0x2d, 0x64, 0x8a, 0xd1, 0xb2, 0xdc, 0x49, 0x07, 0xf6, 0x3c, 0xd5,
	0x61, 0xd9, 0x60, 0xc5, 0xf1, 0xbd, 0x9a, 0xe7, 0x8f, 0x35, 0x80, 0xb3, 0xb7, 0x73, 0x54, 0x22,
	0xb1, 0xca, 0xbf, 0x00, 0x58, 0xf2, 0x8a, 0x80, 0xee, 0x57, 0x74, 0x6c, 0xfa, 0xc3, 0x2a, 0x17,
	0xc8, 0x53, 0x68, 0x32, 0xd4, 0x59, 0x5c, 0x98, 0xff, 0xa4, 0x9a, 0x86, 0xf5, 0x30, 0x99, 0x97,
	0xa5, 0x7f, 0xad, 0xc1, 0x01, 0xc3, 0xdf, 0x65, 0xa8, 0x2d, 0x28, 0x61, 0x5e, 0x5d, 0x22, 0x41,
	0x6d, 0x78, 0x32, 0x77, 0x41, 0xde, 0x62, 0x25, 0x81, 0x7c, 0x1f, 0x1a, 0x97, 0x1a, 0x95, 0x37,
	0xf1, 0x41, 0xc5, 0x84, 0x25, 0x33, 0xc7, 0xb4, 0x2a, 0xbc, 0xca, 0x7e, 0xcf, 0xd5, 0x44, 0x83,
	0x95, 0x04, 0xf2, 0x0c, 0xc0, 0x59, 0x3a, 0x4b, 0x8d, 0x5a, 0x74, 0x1a, 0x2e, 0xcc, 0xbb, 0x15,
	0x45, 0x25, 0x93, 0x55, 0x04, 0xa9, 0xa9, 0x5e, 0xb3, 0x89, 0x18, 0xa3, 0xba, 0x16, 0x21, 0xfa,
	0xd9, 0x52, 0x1c, 0xc9, 0x3d, 0x68, 0xbe, 0x44, 0x33, 0x93, 0x91, 0xf3, 0xb1, 0xcd, 0xfc, 0x69,
	0x35, 0xae, 0xfa, 0x7a, 0x5c, 0xf7, 0x96, 0xe0, 0x35, 0xf2, 0x5b, 0x1e, 0x9e, 0xff, 0xd4, 0xe0,
	0xd6, 0x00, 0xa7, 0x3c, 0x5c, 0xd8, 0x59, 0x82, 0x69, 0x44, 0x08, 0x34, 0xec, 0x6c, 0xf7, 0x66,
	0xdd, 0xb7, 0xa5, 0x5d, 0x48, 0x6d, 0xbc, 0x45, 0xf7, 0x6d, 0x69, 0x23, 0xa9, 0x8c, 0x37, 0xe5,
	0xbe, 0xc9, 0xf7, 0x00, 0x18, 0x26, 0xd2, 0xa0, 0xc3, 0x30, 0xb7, 0x54, 0xa1, 0x90, 0x07, 0xb0,
	0x7f, 0x82, 0x5c, 0xa1, 0x9a, 0xc8, 0xd7, 0x98, 0x76, 0x76, 0x9d, 0x40, 0x95, 0x44, 0x18, 0x7c,
	0x3a, 0x99, 0xc9, 0x4c, 0xf3, 0x34, 0x1a, 0xce, 0xed, 0xdc, 0xd4, 0x13, 0x79, 0xc1, 0xd3, 0x28,
	0xc6, 0xdc, 0xcb, 0x02, 0x94, 0xe6, 0x83, 0xfa, 0x51, 0x8b, 0xbd, 0x93, 0x2c, 0xfd, 0x7b, 0x0d,
	0x5a, 0xaf, 0x30, 0x60, 0x32, 0x33, 0x65, 0x28, 0xb6, 0xfc, 0x8a, 0x50, 0x3e, 0x84, 0xdd, 0x11,
	0x37, 0xb3, 0xfc, 0x19, 0x6a, 0xb3, 0xfc, 0x40, 0x7e, 0xb5, 0x86, 0x8c, 0xef, 0xfe, 0x4e, 0x25,
	0x95, 0x2b, 0x7c, 0xb6, 0x06, 0xe4, 0x4a, 0xc7, 0x34, 0xde, 0xad, 0x63, 0x9a, 0x79, 0xf9, 0xd1,
	0x7f, 0xd6, 0xe0, 0xd6, 0xb9, 0x30, 0xb6, 0x96, 0xb5, 0x30, 0x52, 0x2d, 0x56, 0xb5, 0xd5, 0xde,
	0x49, 0x9b, 0x8d, 0xf5, 0x4b, 0x7e, 0xcd, 0x5d, 0xda, 0x5a, 0xcc, 0x7d, 0x93, 0xdb, 0xb0, 0x73,
	0x2e, 0x5d, 0x28, 0x2d, 0xb6, 0x73, 0x2e, 0x6d, 0x61, 0x8c, 0xec, 0x9a, 0xa0, 0x9d, 0x8b, 0x2d,
	0xe6, 0x4f, 0x16, 0x93, 0xaf, 0x44, 0xc8, 0x23, 0x97, 0xa4, 0x16, 0xcb, 0x0f, 0xf6, 0x69, 0x3f,
	0x17, 0x66, 0x96, 0x05, 0x9d, 0xe6, 0xc6, 0xd3, 0x7e, 0x2e, 0xcc, 0x45, 0x16, 0x30, 0x2f, 0x40,
	0x7f, 0xe4, 0x44, 0x2f, 0xb2, 0xc0, 0x66, 0x3d, 0xa7, 0x69, 0x93, 0x5d, 0x5d, 0xf9, 0xc2, 0xaa,
	0x92, 0x68, 0x02, 0xbb, 0x27, 0x99, 0x88, 0xa3, 0x1b, 0xe6, 0xcf, 0x31, 0x34, 0x2c, 0x1a, 0xbe,
	0x31, 0x3b, 0xab, 0x76, 0x4b, 0x9c, 0x98, 0x93, 0xba, 0xb9, 0x19, 0xe8, 0x9f, 0x77, 0xe0, 0xa0,
	0x27, 0xb4, 0x51, 0x22, 0xc8, 0xdc, 0xdb, 0x7c, 0x04, 0x4d, 0x67, 0xbf, 0x98, 0x4a, 0xdf, 0xa9,
	0xa8, 0x77, 0x0c, 0xe6, 0xf9, 0xe4, 0x33, 0xb8, 0xdd, 0xbd, 0xe6, 0x22, 0xb6, 0x8f, 0x7b, 0x57,
	0x4f, 0xb8, 0xf2, 0xe0, 0xae, 0x51, 0xd7, 0xe4, 0x7e, 0x23, 0xe6, 0x1e, 0xf2, 0x35, 0xea, 0x9a,
	0xdc, 0x97, 0x5c, 0xf9, 0x34, 0xac, 0x51, 0xc9, 0x31, 0x1c, 0x56, 0x28, 0x3d, 0x19, 0xbe, 0x46,
	0xe5, 0x53, 0xb3, 0xc9, 0x20, 0x8f, 0xe1, 0x4e, 0x85, 0xf8, 0xd5, 0x37, 0x2f, 0xfb, 0x09, 0x9f,
	0xa2, 0xcb, 0x59, 0x8b, 0x6d, 0x63, 0xd9, 0xc2, 0x3b, 0x95, 0xda, 0xd0, 0x96, 0x45, 0x22, 0x9a,
	0xa2, 0xa1, 0xff, 0xa8, 0x01, 0xf1, 0x0f, 0x5a, 0x0f, 0x75, 0xa8, 0x84, 0x6b, 0x31, 0xf2, 0x14,
	0xee, 0x4e, 0xf0, 0xad, 0xd1, 0x97, 0x1a, 0x43, 0xae, 0x51, 0xbf, 0x9a, 0x71, 0x83, 0xd7, 0xa8,
	0x7c, 0x5a, 0xb7, 0x33, 0xf3, 0x3d, 0x6f, 0xb8, 0x7d, 0xcf, 0x1b, 0x32, 0xc7, 0x23, 0xbf, 0x84,
	0xf6, 0x85, 0x7c, 0x33, 0x91, 0x27, 0x22, 0x8e, 0x7d, 0xaf, 0x55, 0x5f, 0x07, 0x4b, 0x16, 0xe9,
	0xb4, 0xe2, 0x0b, 0x2b, 0xe5, 0xe9, 0x1f, 0x6a, 0xd0, 0xec, 0xa7, 0xa1, 0x4c, 0xd0, 0xd6, 0xd0,
	0x89, 0x30, 0xa7, 0x52, 0xe4, 0x35, 0xb4, 0xc3, 0x8a, 0x23, 0x79, 0x06, 0xcd, 0xb1, 0xcc, 0x54,
	0x88, 0xbe, 0x8a, 0xfe, 0x87, 0x7a, 0x2f, 0x4c, 0x7e, 0x60, 0xc7, 0xc3, 0x02, 0xd1, 0x3b, 0xb5,
	0xf1, 0x28, 0xe4, 0x5c, 0xfa, 0x14, 0xc8, 0xa6, 0x12, 0x3b, 0x12, 0x37, 0xf6, 0xc4, 0x0a, 0x85,
	0x26, 0x70, 0xd7, 0xae, 0xd4, 0x32, 0xc5, 0xb3, 0x58, 0xa3, 0x2e, 0x9b, 0xd7, 0xe6, 0x30, 0x0c,
	0x65, 0x96, 0x1a, 0x6b, 0xa4, 0x27, 0x14, 0x86, 0x26, 0x5e, 0xf8, 0x7d, 0x68, 0x1b, 0x8b, 0x50,
	0x38, 0x18, 0x29, 0xf9, 0x76, 0xd1, 0x4f, 0xaf, 0xa5, 0xf0, 0x41, 0xb6, 0xd8, 0x0a, 0x8d, 0x9e,
	0xc2, 0x9d, 0xaa, 0xb9, 0x81, 0x08, 0x14, 0x57, 0x8b, 0xad, 0x43, 0xbf, 0x03, 0x7b, 0x03, 0x11,
	0x62, 0xaa, 0xd1, 0xcf, 0xfd, 0xe2, 0x68, 0xb7, 0x8c, 0x11, 0xaa, 0x44, 0x68, 0xdb, 0x99, 0xf6,
	0x4f, 0xe2, 0xa5, 0x0c, 0x44, 0x8c, 0xdd, 0xf9, 0x9c, 0x7e, 0x0e, 0xad, 0x0b, 0xae, 0xa2, 0x37,
	0x5c, 0x21, 0x79, 0x0c, 0x70, 0x12, 0x67, 0x38, 0x57, 0xa2, 0x7c, 0xef, 0x37, 0x3b, 0xab, 0x22,
	0x43, 0x5f, 0x40, 0xeb, 0x85, 0x50, 0x89, 0xbb, 0xbd, 0xcd, 0xa5, 0xcf, 0xfc, 0x9c, 0xf0, 0xf9,
	0xdb, 0x54, 0x96, 0xb3, 0xe9, 0x9f, 0x6a, 0x70, 0xbf, 0x50, 0x54, 0xb8, 0x63, 0x91, 0xe5, 0x46,
	0x04, 0x22, 0x16, 0x66, 0x41, 0x8e, 0x4b, 0x3f, 0xfd, 0x34, 0xdd, 0x54, 0x56, 0x46, 0xf2, 0x1c,
	0x48, 0x71, 0x3d, 0xc6, 0x42, 0xb1, 0x2f, 0xe6, 0xcd, 0x7b, 0x5b, 0x64, 0xe9, 0x5f, 0x6a, 0x70,
	0x58, 0xa8, 0xeb, 0xa7, 0x93, 0x19, 0xbe, 0xb2, 0xe3, 0xee, 0x11, 0x80, 0x7d, 0x33, 0xe2, 0xe1,
	0x9b, 0xd4, 0x77, 0xd0, 0x96, 0xf2, 0xaa, 0x88, 0xd8, 0x14, 0x8f, 0x51, 0x09, 0x1e, 0x7f, 0x9d,
	0x25, 0x81, 0x5f, 0x53, 0xda, 0x6c, 0x85, 0x66, 0x43, 0x5b, 0xba, 0x58, 0xff, 0x16, 0x17, 0x97,
	0x12, 0xf6, 0x97, 0xf0, 0x15, 0x06, 0x63, 0x61, 0x90, 0xfe, 0xab, 0x06, 0xbb, 0x97, 0x9a, 0x4f,
	0x2d, 0xce, 0xb7, 0xc7, 0x86, 0x2b, 0xb3, 0xbe, 0x28, 0xad, 0x51, 0xad, 0x3b, 0x67, 0x69, 0x54,
	0x4a, 0xed, 0x38, 0xa9, 0x15, 0xda, 0x72, 0xa3, 0xaa, 0xdf, 0xb4, 0x51, 0x7d, 0x04, 0xad, 0xee,
	0xa8, 0x7f, 0xca, 0xe3, 0x58, 0xfb, 0xb5, 0x61, 0x79, 0xb6, 0x2f, 0xd4, 0xd0, 0xcc, 0x50, 0x69,
	0xbf, 0x2f, 0xf8, 0x93, 0x7d, 0x56, 0x2e, 0x8d, 0x88, 0x85, 0xe6, 0xae, 0xb5, 0x9a, 0xf9, 0xb3,
	0x52, 0x21, 0xd1, 0x4f, 0xed, 0xd2, 0x63, 0xb7, 0x41, 0xab, 0xdf, 0x96, 0x7d, 0x8f, 0x1b, 0xee,
	0x0a, 0xb1, 0xc1, 0x96, 0x67, 0xba, 0x07, 0xbb, 0xdd, 0x18, 0x95, 0x9b, 0x7d, 0x23, 0x25, 0x03,
	0x54, 0xb6, 0xa4, 0x7b, 0x5c, 0xcf, 0x02, 0xc9, 0x55, 0x44, 0x0f, 0xe1, 0x83, 0xb1, 0xbc, 0x32,
	0x16, 0x2d, 0xdf, 0x2e, 0x4f, 0x7a, 0xd0, 0xbe, 0xec, 0x0f, 0xf3, 0x30, 0xc8, 0xcf, 0xe1, 0xd6,
	0xa9, 0x42, 0x6e, 0xb0, 0xf8, 0x77, 0xdb, 0xf2, 0x63, 0xf7, 0xd1, 0x16, 0xda, 0xc9, 0x7d, 0xf8,
	0x18, 0xb3, 0xe5, 0x8f, 0xbc, 0xff, 0xaf, 0x5f, 0x8a, 0x05, 0x4d, 0xf7, 0xfb, 0xfe, 0xd3, 0xff,
	0x06, 0x00, 0x00, 0xff, 0xff, 0x31, 0x2c, 0xf1, 0x66, 0xf2, 0x0f, 0x00, 0x00,
}
