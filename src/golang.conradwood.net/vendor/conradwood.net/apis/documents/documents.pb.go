// Code generated by protoc-gen-go.
// source: conradwood.net/apis/documents/documents.proto
// DO NOT EDIT!

/*
Package documents is a generated protocol buffer package.

It is generated from these files:
	conradwood.net/apis/documents/documents.proto

It has these top-level messages:
	Document
	DocumentFile
	DBImage
	Image
	Page
	UpdatePageRequest
	SearchOptions
	TextSearchRequest
	DocumentList
	CreateDocRequest
	UploadBinaryRequest
	FreezeRequest
	DocumentFileRequest
	BinaryContent
	DocumentID
	DocumentFileList
	DocFileMeta
	UploadImageRequest
	ImageByIDRequest
	AddPageTextRequest
	ErrorSubmission
	CheckSumRequest
	SearchPageResult
	SearchResult
	KeywordsRequest
	ProcessorTriggerResult
*/
package documents

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import h2gproxy "golang.conradwood.net/apis/h2gproxy"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//
// a document is our 'root' for files. A document contains 0 or more files, each file may contain 0 or more pages
type Document struct {
	ID                      uint64  `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ParsedContent           string  `protobuf:"bytes,2,opt,name=ParsedContent" json:"ParsedContent,omitempty"`
	Created                 uint32  `protobuf:"varint,3,opt,name=Created" json:"Created,omitempty"`
	Pages                   []*Page `protobuf:"bytes,4,rep,name=Pages" json:"Pages,omitempty"`
	ImportCompleted         bool    `protobuf:"varint,5,opt,name=ImportCompleted" json:"ImportCompleted,omitempty"`
	LastProcessingError     string  `protobuf:"bytes,6,opt,name=LastProcessingError" json:"LastProcessingError,omitempty"`
	Keywords                string  `protobuf:"bytes,7,opt,name=Keywords" json:"Keywords,omitempty"`
	LastProcessingTimestamp uint32  `protobuf:"varint,8,opt,name=LastProcessingTimestamp" json:"LastProcessingTimestamp,omitempty"`
	Owner                   string  `protobuf:"bytes,9,opt,name=Owner" json:"Owner,omitempty"`
	ProcessingAttempts      uint32  `protobuf:"varint,10,opt,name=ProcessingAttempts" json:"ProcessingAttempts,omitempty"`
}

func (m *Document) Reset()                    { *m = Document{} }
func (m *Document) String() string            { return proto.CompactTextString(m) }
func (*Document) ProtoMessage()               {}
func (*Document) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Document) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Document) GetParsedContent() string {
	if m != nil {
		return m.ParsedContent
	}
	return ""
}

func (m *Document) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Document) GetPages() []*Page {
	if m != nil {
		return m.Pages
	}
	return nil
}

func (m *Document) GetImportCompleted() bool {
	if m != nil {
		return m.ImportCompleted
	}
	return false
}

func (m *Document) GetLastProcessingError() string {
	if m != nil {
		return m.LastProcessingError
	}
	return ""
}

func (m *Document) GetKeywords() string {
	if m != nil {
		return m.Keywords
	}
	return ""
}

func (m *Document) GetLastProcessingTimestamp() uint32 {
	if m != nil {
		return m.LastProcessingTimestamp
	}
	return 0
}

func (m *Document) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Document) GetProcessingAttempts() uint32 {
	if m != nil {
		return m.ProcessingAttempts
	}
	return 0
}

//
// a file is a PDF or a JPEG or so. Note that a single file might have multiple pages.
// Files are uploaded by the user and stored as-is (unmodified).
type DocumentFile struct {
	ID         uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	DocID      uint64 `protobuf:"varint,2,opt,name=DocID" json:"DocID,omitempty"`
	Filename   string `protobuf:"bytes,3,opt,name=Filename" json:"Filename,omitempty"`
	StorageKey string `protobuf:"bytes,4,opt,name=StorageKey" json:"StorageKey,omitempty"`
	MimeType   string `protobuf:"bytes,5,opt,name=MimeType" json:"MimeType,omitempty"`
	Checksum   string `protobuf:"bytes,6,opt,name=Checksum" json:"Checksum,omitempty"`
}

func (m *DocumentFile) Reset()                    { *m = DocumentFile{} }
func (m *DocumentFile) String() string            { return proto.CompactTextString(m) }
func (*DocumentFile) ProtoMessage()               {}
func (*DocumentFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DocumentFile) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DocumentFile) GetDocID() uint64 {
	if m != nil {
		return m.DocID
	}
	return 0
}

func (m *DocumentFile) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *DocumentFile) GetStorageKey() string {
	if m != nil {
		return m.StorageKey
	}
	return ""
}

func (m *DocumentFile) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *DocumentFile) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

//
// a PNG or JPEG image representing the document. Images are generated from a single DocumentFile.
// one documentfile may contain multiple images (e.g. multi-page PDFs)
type DBImage struct {
	ID         uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	SizeX      uint32 `protobuf:"varint,2,opt,name=SizeX" json:"SizeX,omitempty"`
	SizeY      uint32 `protobuf:"varint,3,opt,name=SizeY" json:"SizeY,omitempty"`
	MimeType   string `protobuf:"bytes,4,opt,name=MimeType" json:"MimeType,omitempty"`
	StorageKey string `protobuf:"bytes,5,opt,name=StorageKey" json:"StorageKey,omitempty"`
	DocFileID  uint64 `protobuf:"varint,6,opt,name=DocFileID" json:"DocFileID,omitempty"`
	PageNumber uint32 `protobuf:"varint,7,opt,name=PageNumber" json:"PageNumber,omitempty"`
}

func (m *DBImage) Reset()                    { *m = DBImage{} }
func (m *DBImage) String() string            { return proto.CompactTextString(m) }
func (*DBImage) ProtoMessage()               {}
func (*DBImage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DBImage) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBImage) GetSizeX() uint32 {
	if m != nil {
		return m.SizeX
	}
	return 0
}

func (m *DBImage) GetSizeY() uint32 {
	if m != nil {
		return m.SizeY
	}
	return 0
}

func (m *DBImage) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *DBImage) GetStorageKey() string {
	if m != nil {
		return m.StorageKey
	}
	return ""
}

func (m *DBImage) GetDocFileID() uint64 {
	if m != nil {
		return m.DocFileID
	}
	return 0
}

func (m *DBImage) GetPageNumber() uint32 {
	if m != nil {
		return m.PageNumber
	}
	return 0
}

type Image struct {
	ID         uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	SizeX      uint32 `protobuf:"varint,2,opt,name=SizeX" json:"SizeX,omitempty"`
	SizeY      uint32 `protobuf:"varint,3,opt,name=SizeY" json:"SizeY,omitempty"`
	MimeType   string `protobuf:"bytes,4,opt,name=MimeType" json:"MimeType,omitempty"`
	Content    []byte `protobuf:"bytes,5,opt,name=Content,proto3" json:"Content,omitempty"`
	DocFileID  uint64 `protobuf:"varint,6,opt,name=DocFileID" json:"DocFileID,omitempty"`
	PageNumber uint32 `protobuf:"varint,7,opt,name=PageNumber" json:"PageNumber,omitempty"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Image) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Image) GetSizeX() uint32 {
	if m != nil {
		return m.SizeX
	}
	return 0
}

func (m *Image) GetSizeY() uint32 {
	if m != nil {
		return m.SizeY
	}
	return 0
}

func (m *Image) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *Image) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Image) GetDocFileID() uint64 {
	if m != nil {
		return m.DocFileID
	}
	return 0
}

func (m *Image) GetPageNumber() uint32 {
	if m != nil {
		return m.PageNumber
	}
	return 0
}

type Page struct {
	ID          uint64          `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ImageID     uint64          `protobuf:"varint,2,opt,name=ImageID" json:"ImageID,omitempty"`
	TextContent string          `protobuf:"bytes,3,opt,name=TextContent" json:"TextContent,omitempty"`
	Language    common.Language `protobuf:"varint,4,opt,name=Language,enum=common.Language" json:"Language,omitempty"`
	PageNumber  uint32          `protobuf:"varint,5,opt,name=PageNumber" json:"PageNumber,omitempty"`
}

func (m *Page) Reset()                    { *m = Page{} }
func (m *Page) String() string            { return proto.CompactTextString(m) }
func (*Page) ProtoMessage()               {}
func (*Page) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Page) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Page) GetImageID() uint64 {
	if m != nil {
		return m.ImageID
	}
	return 0
}

func (m *Page) GetTextContent() string {
	if m != nil {
		return m.TextContent
	}
	return ""
}

func (m *Page) GetLanguage() common.Language {
	if m != nil {
		return m.Language
	}
	return common.Language_UNKNOWN
}

func (m *Page) GetPageNumber() uint32 {
	if m != nil {
		return m.PageNumber
	}
	return 0
}

type UpdatePageRequest struct {
	ImageID     uint64          `protobuf:"varint,1,opt,name=ImageID" json:"ImageID,omitempty"`
	TextContent string          `protobuf:"bytes,2,opt,name=TextContent" json:"TextContent,omitempty"`
	Language    common.Language `protobuf:"varint,3,opt,name=Language,enum=common.Language" json:"Language,omitempty"`
}

func (m *UpdatePageRequest) Reset()                    { *m = UpdatePageRequest{} }
func (m *UpdatePageRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdatePageRequest) ProtoMessage()               {}
func (*UpdatePageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *UpdatePageRequest) GetImageID() uint64 {
	if m != nil {
		return m.ImageID
	}
	return 0
}

func (m *UpdatePageRequest) GetTextContent() string {
	if m != nil {
		return m.TextContent
	}
	return ""
}

func (m *UpdatePageRequest) GetLanguage() common.Language {
	if m != nil {
		return m.Language
	}
	return common.Language_UNKNOWN
}

type SearchOptions struct {
	IncludeImages bool   `protobuf:"varint,1,opt,name=IncludeImages" json:"IncludeImages,omitempty"`
	IncludePages  bool   `protobuf:"varint,2,opt,name=IncludePages" json:"IncludePages,omitempty"`
	SizeMaxX      uint32 `protobuf:"varint,3,opt,name=SizeMaxX" json:"SizeMaxX,omitempty"`
	SizeMaxY      uint32 `protobuf:"varint,4,opt,name=SizeMaxY" json:"SizeMaxY,omitempty"`
}

func (m *SearchOptions) Reset()                    { *m = SearchOptions{} }
func (m *SearchOptions) String() string            { return proto.CompactTextString(m) }
func (*SearchOptions) ProtoMessage()               {}
func (*SearchOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SearchOptions) GetIncludeImages() bool {
	if m != nil {
		return m.IncludeImages
	}
	return false
}

func (m *SearchOptions) GetIncludePages() bool {
	if m != nil {
		return m.IncludePages
	}
	return false
}

func (m *SearchOptions) GetSizeMaxX() uint32 {
	if m != nil {
		return m.SizeMaxX
	}
	return 0
}

func (m *SearchOptions) GetSizeMaxY() uint32 {
	if m != nil {
		return m.SizeMaxY
	}
	return 0
}

type TextSearchRequest struct {
	Options *SearchOptions `protobuf:"bytes,1,opt,name=Options" json:"Options,omitempty"`
	Text    string         `protobuf:"bytes,2,opt,name=Text" json:"Text,omitempty"`
}

func (m *TextSearchRequest) Reset()                    { *m = TextSearchRequest{} }
func (m *TextSearchRequest) String() string            { return proto.CompactTextString(m) }
func (*TextSearchRequest) ProtoMessage()               {}
func (*TextSearchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *TextSearchRequest) GetOptions() *SearchOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *TextSearchRequest) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type DocumentList struct {
	Documents []*Document `protobuf:"bytes,1,rep,name=Documents" json:"Documents,omitempty"`
}

func (m *DocumentList) Reset()                    { *m = DocumentList{} }
func (m *DocumentList) String() string            { return proto.CompactTextString(m) }
func (*DocumentList) ProtoMessage()               {}
func (*DocumentList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DocumentList) GetDocuments() []*Document {
	if m != nil {
		return m.Documents
	}
	return nil
}

// create a document.
type CreateDocRequest struct {
	Created uint32 `protobuf:"varint,1,opt,name=Created" json:"Created,omitempty"`
}

func (m *CreateDocRequest) Reset()                    { *m = CreateDocRequest{} }
func (m *CreateDocRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateDocRequest) ProtoMessage()               {}
func (*CreateDocRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *CreateDocRequest) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

type UploadBinaryRequest struct {
	DocID    uint64 `protobuf:"varint,1,opt,name=DocID" json:"DocID,omitempty"`
	Filename string `protobuf:"bytes,2,opt,name=Filename" json:"Filename,omitempty"`
	Content  []byte `protobuf:"bytes,3,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *UploadBinaryRequest) Reset()                    { *m = UploadBinaryRequest{} }
func (m *UploadBinaryRequest) String() string            { return proto.CompactTextString(m) }
func (*UploadBinaryRequest) ProtoMessage()               {}
func (*UploadBinaryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *UploadBinaryRequest) GetDocID() uint64 {
	if m != nil {
		return m.DocID
	}
	return 0
}

func (m *UploadBinaryRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *UploadBinaryRequest) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

type FreezeRequest struct {
	DocID uint64 `protobuf:"varint,1,opt,name=DocID" json:"DocID,omitempty"`
}

func (m *FreezeRequest) Reset()                    { *m = FreezeRequest{} }
func (m *FreezeRequest) String() string            { return proto.CompactTextString(m) }
func (*FreezeRequest) ProtoMessage()               {}
func (*FreezeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *FreezeRequest) GetDocID() uint64 {
	if m != nil {
		return m.DocID
	}
	return 0
}

type DocumentFileRequest struct {
	DocFileID uint64 `protobuf:"varint,1,opt,name=DocFileID" json:"DocFileID,omitempty"`
}

func (m *DocumentFileRequest) Reset()                    { *m = DocumentFileRequest{} }
func (m *DocumentFileRequest) String() string            { return proto.CompactTextString(m) }
func (*DocumentFileRequest) ProtoMessage()               {}
func (*DocumentFileRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *DocumentFileRequest) GetDocFileID() uint64 {
	if m != nil {
		return m.DocFileID
	}
	return 0
}

type BinaryContent struct {
	Content []byte `protobuf:"bytes,1,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *BinaryContent) Reset()                    { *m = BinaryContent{} }
func (m *BinaryContent) String() string            { return proto.CompactTextString(m) }
func (*BinaryContent) ProtoMessage()               {}
func (*BinaryContent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *BinaryContent) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

type DocumentID struct {
	DocID uint64 `protobuf:"varint,1,opt,name=DocID" json:"DocID,omitempty"`
}

func (m *DocumentID) Reset()                    { *m = DocumentID{} }
func (m *DocumentID) String() string            { return proto.CompactTextString(m) }
func (*DocumentID) ProtoMessage()               {}
func (*DocumentID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *DocumentID) GetDocID() uint64 {
	if m != nil {
		return m.DocID
	}
	return 0
}

type DocumentFileList struct {
	DocFiles []*DocFileMeta `protobuf:"bytes,1,rep,name=DocFiles" json:"DocFiles,omitempty"`
}

func (m *DocumentFileList) Reset()                    { *m = DocumentFileList{} }
func (m *DocumentFileList) String() string            { return proto.CompactTextString(m) }
func (*DocumentFileList) ProtoMessage()               {}
func (*DocumentFileList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *DocumentFileList) GetDocFiles() []*DocFileMeta {
	if m != nil {
		return m.DocFiles
	}
	return nil
}

// meta data about a "documentfile"
type DocFileMeta struct {
	ID       uint64   `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	DocID    uint64   `protobuf:"varint,2,opt,name=DocID" json:"DocID,omitempty"`
	Filename string   `protobuf:"bytes,3,opt,name=Filename" json:"Filename,omitempty"`
	MimeType string   `protobuf:"bytes,4,opt,name=MimeType" json:"MimeType,omitempty"`
	ImageIDs []uint64 `protobuf:"varint,5,rep,packed,name=ImageIDs" json:"ImageIDs,omitempty"`
	Checksum string   `protobuf:"bytes,6,opt,name=Checksum" json:"Checksum,omitempty"`
}

func (m *DocFileMeta) Reset()                    { *m = DocFileMeta{} }
func (m *DocFileMeta) String() string            { return proto.CompactTextString(m) }
func (*DocFileMeta) ProtoMessage()               {}
func (*DocFileMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *DocFileMeta) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DocFileMeta) GetDocID() uint64 {
	if m != nil {
		return m.DocID
	}
	return 0
}

func (m *DocFileMeta) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *DocFileMeta) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *DocFileMeta) GetImageIDs() []uint64 {
	if m != nil {
		return m.ImageIDs
	}
	return nil
}

func (m *DocFileMeta) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

type UploadImageRequest struct {
	DocFileID uint64 `protobuf:"varint,1,opt,name=DocFileID" json:"DocFileID,omitempty"`
	PageNo    uint32 `protobuf:"varint,2,opt,name=PageNo" json:"PageNo,omitempty"`
	Content   []byte `protobuf:"bytes,3,opt,name=Content,proto3" json:"Content,omitempty"`
	MimeType  string `protobuf:"bytes,4,opt,name=MimeType" json:"MimeType,omitempty"`
}

func (m *UploadImageRequest) Reset()                    { *m = UploadImageRequest{} }
func (m *UploadImageRequest) String() string            { return proto.CompactTextString(m) }
func (*UploadImageRequest) ProtoMessage()               {}
func (*UploadImageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *UploadImageRequest) GetDocFileID() uint64 {
	if m != nil {
		return m.DocFileID
	}
	return 0
}

func (m *UploadImageRequest) GetPageNo() uint32 {
	if m != nil {
		return m.PageNo
	}
	return 0
}

func (m *UploadImageRequest) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *UploadImageRequest) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

type ImageByIDRequest struct {
	ImageID uint64 `protobuf:"varint,1,opt,name=ImageID" json:"ImageID,omitempty"`
}

func (m *ImageByIDRequest) Reset()                    { *m = ImageByIDRequest{} }
func (m *ImageByIDRequest) String() string            { return proto.CompactTextString(m) }
func (*ImageByIDRequest) ProtoMessage()               {}
func (*ImageByIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ImageByIDRequest) GetImageID() uint64 {
	if m != nil {
		return m.ImageID
	}
	return 0
}

type AddPageTextRequest struct {
	PageID   uint64          `protobuf:"varint,1,opt,name=PageID" json:"PageID,omitempty"`
	Text     string          `protobuf:"bytes,2,opt,name=Text" json:"Text,omitempty"`
	Language common.Language `protobuf:"varint,3,opt,name=Language,enum=common.Language" json:"Language,omitempty"`
	Keywords string          `protobuf:"bytes,4,opt,name=Keywords" json:"Keywords,omitempty"`
}

func (m *AddPageTextRequest) Reset()                    { *m = AddPageTextRequest{} }
func (m *AddPageTextRequest) String() string            { return proto.CompactTextString(m) }
func (*AddPageTextRequest) ProtoMessage()               {}
func (*AddPageTextRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *AddPageTextRequest) GetPageID() uint64 {
	if m != nil {
		return m.PageID
	}
	return 0
}

func (m *AddPageTextRequest) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *AddPageTextRequest) GetLanguage() common.Language {
	if m != nil {
		return m.Language
	}
	return common.Language_UNKNOWN
}

func (m *AddPageTextRequest) GetKeywords() string {
	if m != nil {
		return m.Keywords
	}
	return ""
}

type ErrorSubmission struct {
	DocID        uint64 `protobuf:"varint,1,opt,name=DocID" json:"DocID,omitempty"`
	ErrorMessage string `protobuf:"bytes,2,opt,name=ErrorMessage" json:"ErrorMessage,omitempty"`
}

func (m *ErrorSubmission) Reset()                    { *m = ErrorSubmission{} }
func (m *ErrorSubmission) String() string            { return proto.CompactTextString(m) }
func (*ErrorSubmission) ProtoMessage()               {}
func (*ErrorSubmission) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *ErrorSubmission) GetDocID() uint64 {
	if m != nil {
		return m.DocID
	}
	return 0
}

func (m *ErrorSubmission) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

type CheckSumRequest struct {
	CheckSums []string `protobuf:"bytes,1,rep,name=CheckSums" json:"CheckSums,omitempty"`
}

func (m *CheckSumRequest) Reset()                    { *m = CheckSumRequest{} }
func (m *CheckSumRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckSumRequest) ProtoMessage()               {}
func (*CheckSumRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *CheckSumRequest) GetCheckSums() []string {
	if m != nil {
		return m.CheckSums
	}
	return nil
}

type SearchPageResult struct {
	Page    *Page        `protobuf:"bytes,1,opt,name=Page" json:"Page,omitempty"`
	Image   *Image       `protobuf:"bytes,2,opt,name=Image" json:"Image,omitempty"`
	DocFile *DocFileMeta `protobuf:"bytes,3,opt,name=DocFile" json:"DocFile,omitempty"`
	Doc     *Document    `protobuf:"bytes,4,opt,name=Doc" json:"Doc,omitempty"`
}

func (m *SearchPageResult) Reset()                    { *m = SearchPageResult{} }
func (m *SearchPageResult) String() string            { return proto.CompactTextString(m) }
func (*SearchPageResult) ProtoMessage()               {}
func (*SearchPageResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *SearchPageResult) GetPage() *Page {
	if m != nil {
		return m.Page
	}
	return nil
}

func (m *SearchPageResult) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *SearchPageResult) GetDocFile() *DocFileMeta {
	if m != nil {
		return m.DocFile
	}
	return nil
}

func (m *SearchPageResult) GetDoc() *Document {
	if m != nil {
		return m.Doc
	}
	return nil
}

type SearchResult struct {
	Pages []*SearchPageResult `protobuf:"bytes,1,rep,name=Pages" json:"Pages,omitempty"`
}

func (m *SearchResult) Reset()                    { *m = SearchResult{} }
func (m *SearchResult) String() string            { return proto.CompactTextString(m) }
func (*SearchResult) ProtoMessage()               {}
func (*SearchResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *SearchResult) GetPages() []*SearchPageResult {
	if m != nil {
		return m.Pages
	}
	return nil
}

type KeywordsRequest struct {
	DocID    uint64 `protobuf:"varint,1,opt,name=DocID" json:"DocID,omitempty"`
	Keywords string `protobuf:"bytes,2,opt,name=Keywords" json:"Keywords,omitempty"`
	Replace  bool   `protobuf:"varint,3,opt,name=Replace" json:"Replace,omitempty"`
}

func (m *KeywordsRequest) Reset()                    { *m = KeywordsRequest{} }
func (m *KeywordsRequest) String() string            { return proto.CompactTextString(m) }
func (*KeywordsRequest) ProtoMessage()               {}
func (*KeywordsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *KeywordsRequest) GetDocID() uint64 {
	if m != nil {
		return m.DocID
	}
	return 0
}

func (m *KeywordsRequest) GetKeywords() string {
	if m != nil {
		return m.Keywords
	}
	return ""
}

func (m *KeywordsRequest) GetReplace() bool {
	if m != nil {
		return m.Replace
	}
	return false
}

type ProcessorTriggerResult struct {
	IsBusy bool `protobuf:"varint,1,opt,name=IsBusy" json:"IsBusy,omitempty"`
}

func (m *ProcessorTriggerResult) Reset()                    { *m = ProcessorTriggerResult{} }
func (m *ProcessorTriggerResult) String() string            { return proto.CompactTextString(m) }
func (*ProcessorTriggerResult) ProtoMessage()               {}
func (*ProcessorTriggerResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *ProcessorTriggerResult) GetIsBusy() bool {
	if m != nil {
		return m.IsBusy
	}
	return false
}

func init() {
	proto.RegisterType((*Document)(nil), "documents.Document")
	proto.RegisterType((*DocumentFile)(nil), "documents.DocumentFile")
	proto.RegisterType((*DBImage)(nil), "documents.DBImage")
	proto.RegisterType((*Image)(nil), "documents.Image")
	proto.RegisterType((*Page)(nil), "documents.Page")
	proto.RegisterType((*UpdatePageRequest)(nil), "documents.UpdatePageRequest")
	proto.RegisterType((*SearchOptions)(nil), "documents.SearchOptions")
	proto.RegisterType((*TextSearchRequest)(nil), "documents.TextSearchRequest")
	proto.RegisterType((*DocumentList)(nil), "documents.DocumentList")
	proto.RegisterType((*CreateDocRequest)(nil), "documents.CreateDocRequest")
	proto.RegisterType((*UploadBinaryRequest)(nil), "documents.UploadBinaryRequest")
	proto.RegisterType((*FreezeRequest)(nil), "documents.FreezeRequest")
	proto.RegisterType((*DocumentFileRequest)(nil), "documents.DocumentFileRequest")
	proto.RegisterType((*BinaryContent)(nil), "documents.BinaryContent")
	proto.RegisterType((*DocumentID)(nil), "documents.DocumentID")
	proto.RegisterType((*DocumentFileList)(nil), "documents.DocumentFileList")
	proto.RegisterType((*DocFileMeta)(nil), "documents.DocFileMeta")
	proto.RegisterType((*UploadImageRequest)(nil), "documents.UploadImageRequest")
	proto.RegisterType((*ImageByIDRequest)(nil), "documents.ImageByIDRequest")
	proto.RegisterType((*AddPageTextRequest)(nil), "documents.AddPageTextRequest")
	proto.RegisterType((*ErrorSubmission)(nil), "documents.ErrorSubmission")
	proto.RegisterType((*CheckSumRequest)(nil), "documents.CheckSumRequest")
	proto.RegisterType((*SearchPageResult)(nil), "documents.SearchPageResult")
	proto.RegisterType((*SearchResult)(nil), "documents.SearchResult")
	proto.RegisterType((*KeywordsRequest)(nil), "documents.KeywordsRequest")
	proto.RegisterType((*ProcessorTriggerResult)(nil), "documents.ProcessorTriggerResult")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Documents service

type DocumentsClient interface {
	// find document with text
	FindWithText(ctx context.Context, in *TextSearchRequest, opts ...grpc.CallOption) (*SearchResult, error)
	// this creates an 'anchor' to which we can upload document files
	CreateDocument(ctx context.Context, in *CreateDocRequest, opts ...grpc.CallOption) (*Document, error)
	// set keywords for a document
	SetKeywords(ctx context.Context, in *KeywordsRequest, opts ...grpc.CallOption) (*Document, error)
	//
	// upload one or more documentfile(s) to a document, this can be a pdf or a png or jpeg or whatever,
	// the server will auto-detect.
	// The binaries will be stored 'as-is' as well as converted into images for easy viewing
	// Content (bytes) will be appended to by "filename".
	UploadBinaries(ctx context.Context, opts ...grpc.CallOption) (Documents_UploadBinariesClient, error)
	// a frozen document will not be modifiable any longer
	FreezeDocument(ctx context.Context, in *FreezeRequest, opts ...grpc.CallOption) (*common.Void, error)
	// the the IDs of documentfiles
	GetDocumentFileMeta(ctx context.Context, in *DocumentID, opts ...grpc.CallOption) (*DocumentFileList, error)
	// get the original file(s) that were uploaded (by id)
	GetDocumentFile(ctx context.Context, in *DocumentFileRequest, opts ...grpc.CallOption) (Documents_GetDocumentFileClient, error)
	// upload an image
	UploadImage(ctx context.Context, opts ...grpc.CallOption) (Documents_UploadImageClient, error)
	// update (or implicitly: create) a page
	UpdatePage(ctx context.Context, in *UpdatePageRequest, opts ...grpc.CallOption) (*Page, error)
	// get Image by id
	ImageByID(ctx context.Context, in *ImageByIDRequest, opts ...grpc.CallOption) (Documents_ImageByIDClient, error)
	// documentprocessors asks for documents that needs processing
	GetNextDocToProcess(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*DocumentID, error)
	// check if the checksums exist in the database already
	DocFileByChecksums(ctx context.Context, in *CheckSumRequest, opts ...grpc.CallOption) (*DocumentFileList, error)
	// documentprocessor might say there was a problem processing a doc
	SubmitProcessingError(ctx context.Context, in *ErrorSubmission, opts ...grpc.CallOption) (*common.Void, error)
	// delete a document (remove it binaries and files and stuff), this is irrevocable
	DeleteDoc(ctx context.Context, in *DocumentID, opts ...grpc.CallOption) (*common.Void, error)
	// http access to pages (and docs)
	StreamHTTP(ctx context.Context, in *h2gproxy.StreamRequest, opts ...grpc.CallOption) (Documents_StreamHTTPClient, error)
}

type documentsClient struct {
	cc *grpc.ClientConn
}

func NewDocumentsClient(cc *grpc.ClientConn) DocumentsClient {
	return &documentsClient{cc}
}

func (c *documentsClient) FindWithText(ctx context.Context, in *TextSearchRequest, opts ...grpc.CallOption) (*SearchResult, error) {
	out := new(SearchResult)
	err := grpc.Invoke(ctx, "/documents.Documents/FindWithText", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentsClient) CreateDocument(ctx context.Context, in *CreateDocRequest, opts ...grpc.CallOption) (*Document, error) {
	out := new(Document)
	err := grpc.Invoke(ctx, "/documents.Documents/CreateDocument", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentsClient) SetKeywords(ctx context.Context, in *KeywordsRequest, opts ...grpc.CallOption) (*Document, error) {
	out := new(Document)
	err := grpc.Invoke(ctx, "/documents.Documents/SetKeywords", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentsClient) UploadBinaries(ctx context.Context, opts ...grpc.CallOption) (Documents_UploadBinariesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Documents_serviceDesc.Streams[0], c.cc, "/documents.Documents/UploadBinaries", opts...)
	if err != nil {
		return nil, err
	}
	x := &documentsUploadBinariesClient{stream}
	return x, nil
}

type Documents_UploadBinariesClient interface {
	Send(*UploadBinaryRequest) error
	CloseAndRecv() (*common.Void, error)
	grpc.ClientStream
}

type documentsUploadBinariesClient struct {
	grpc.ClientStream
}

func (x *documentsUploadBinariesClient) Send(m *UploadBinaryRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *documentsUploadBinariesClient) CloseAndRecv() (*common.Void, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(common.Void)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *documentsClient) FreezeDocument(ctx context.Context, in *FreezeRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/documents.Documents/FreezeDocument", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentsClient) GetDocumentFileMeta(ctx context.Context, in *DocumentID, opts ...grpc.CallOption) (*DocumentFileList, error) {
	out := new(DocumentFileList)
	err := grpc.Invoke(ctx, "/documents.Documents/GetDocumentFileMeta", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentsClient) GetDocumentFile(ctx context.Context, in *DocumentFileRequest, opts ...grpc.CallOption) (Documents_GetDocumentFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Documents_serviceDesc.Streams[1], c.cc, "/documents.Documents/GetDocumentFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &documentsGetDocumentFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Documents_GetDocumentFileClient interface {
	Recv() (*BinaryContent, error)
	grpc.ClientStream
}

type documentsGetDocumentFileClient struct {
	grpc.ClientStream
}

func (x *documentsGetDocumentFileClient) Recv() (*BinaryContent, error) {
	m := new(BinaryContent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *documentsClient) UploadImage(ctx context.Context, opts ...grpc.CallOption) (Documents_UploadImageClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Documents_serviceDesc.Streams[2], c.cc, "/documents.Documents/UploadImage", opts...)
	if err != nil {
		return nil, err
	}
	x := &documentsUploadImageClient{stream}
	return x, nil
}

type Documents_UploadImageClient interface {
	Send(*UploadImageRequest) error
	CloseAndRecv() (*common.Void, error)
	grpc.ClientStream
}

type documentsUploadImageClient struct {
	grpc.ClientStream
}

func (x *documentsUploadImageClient) Send(m *UploadImageRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *documentsUploadImageClient) CloseAndRecv() (*common.Void, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(common.Void)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *documentsClient) UpdatePage(ctx context.Context, in *UpdatePageRequest, opts ...grpc.CallOption) (*Page, error) {
	out := new(Page)
	err := grpc.Invoke(ctx, "/documents.Documents/UpdatePage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentsClient) ImageByID(ctx context.Context, in *ImageByIDRequest, opts ...grpc.CallOption) (Documents_ImageByIDClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Documents_serviceDesc.Streams[3], c.cc, "/documents.Documents/ImageByID", opts...)
	if err != nil {
		return nil, err
	}
	x := &documentsImageByIDClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Documents_ImageByIDClient interface {
	Recv() (*Image, error)
	grpc.ClientStream
}

type documentsImageByIDClient struct {
	grpc.ClientStream
}

func (x *documentsImageByIDClient) Recv() (*Image, error) {
	m := new(Image)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *documentsClient) GetNextDocToProcess(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*DocumentID, error) {
	out := new(DocumentID)
	err := grpc.Invoke(ctx, "/documents.Documents/GetNextDocToProcess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentsClient) DocFileByChecksums(ctx context.Context, in *CheckSumRequest, opts ...grpc.CallOption) (*DocumentFileList, error) {
	out := new(DocumentFileList)
	err := grpc.Invoke(ctx, "/documents.Documents/DocFileByChecksums", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentsClient) SubmitProcessingError(ctx context.Context, in *ErrorSubmission, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/documents.Documents/SubmitProcessingError", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentsClient) DeleteDoc(ctx context.Context, in *DocumentID, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/documents.Documents/DeleteDoc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *documentsClient) StreamHTTP(ctx context.Context, in *h2gproxy.StreamRequest, opts ...grpc.CallOption) (Documents_StreamHTTPClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Documents_serviceDesc.Streams[4], c.cc, "/documents.Documents/StreamHTTP", opts...)
	if err != nil {
		return nil, err
	}
	x := &documentsStreamHTTPClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Documents_StreamHTTPClient interface {
	Recv() (*h2gproxy.StreamDataResponse, error)
	grpc.ClientStream
}

type documentsStreamHTTPClient struct {
	grpc.ClientStream
}

func (x *documentsStreamHTTPClient) Recv() (*h2gproxy.StreamDataResponse, error) {
	m := new(h2gproxy.StreamDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Documents service

type DocumentsServer interface {
	// find document with text
	FindWithText(context.Context, *TextSearchRequest) (*SearchResult, error)
	// this creates an 'anchor' to which we can upload document files
	CreateDocument(context.Context, *CreateDocRequest) (*Document, error)
	// set keywords for a document
	SetKeywords(context.Context, *KeywordsRequest) (*Document, error)
	//
	// upload one or more documentfile(s) to a document, this can be a pdf or a png or jpeg or whatever,
	// the server will auto-detect.
	// The binaries will be stored 'as-is' as well as converted into images for easy viewing
	// Content (bytes) will be appended to by "filename".
	UploadBinaries(Documents_UploadBinariesServer) error
	// a frozen document will not be modifiable any longer
	FreezeDocument(context.Context, *FreezeRequest) (*common.Void, error)
	// the the IDs of documentfiles
	GetDocumentFileMeta(context.Context, *DocumentID) (*DocumentFileList, error)
	// get the original file(s) that were uploaded (by id)
	GetDocumentFile(*DocumentFileRequest, Documents_GetDocumentFileServer) error
	// upload an image
	UploadImage(Documents_UploadImageServer) error
	// update (or implicitly: create) a page
	UpdatePage(context.Context, *UpdatePageRequest) (*Page, error)
	// get Image by id
	ImageByID(*ImageByIDRequest, Documents_ImageByIDServer) error
	// documentprocessors asks for documents that needs processing
	GetNextDocToProcess(context.Context, *common.Void) (*DocumentID, error)
	// check if the checksums exist in the database already
	DocFileByChecksums(context.Context, *CheckSumRequest) (*DocumentFileList, error)
	// documentprocessor might say there was a problem processing a doc
	SubmitProcessingError(context.Context, *ErrorSubmission) (*common.Void, error)
	// delete a document (remove it binaries and files and stuff), this is irrevocable
	DeleteDoc(context.Context, *DocumentID) (*common.Void, error)
	// http access to pages (and docs)
	StreamHTTP(*h2gproxy.StreamRequest, Documents_StreamHTTPServer) error
}

func RegisterDocumentsServer(s *grpc.Server, srv DocumentsServer) {
	s.RegisterService(&_Documents_serviceDesc, srv)
}

func _Documents_FindWithText_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentsServer).FindWithText(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/documents.Documents/FindWithText",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentsServer).FindWithText(ctx, req.(*TextSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Documents_CreateDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentsServer).CreateDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/documents.Documents/CreateDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentsServer).CreateDocument(ctx, req.(*CreateDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Documents_SetKeywords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeywordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentsServer).SetKeywords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/documents.Documents/SetKeywords",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentsServer).SetKeywords(ctx, req.(*KeywordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Documents_UploadBinaries_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DocumentsServer).UploadBinaries(&documentsUploadBinariesServer{stream})
}

type Documents_UploadBinariesServer interface {
	SendAndClose(*common.Void) error
	Recv() (*UploadBinaryRequest, error)
	grpc.ServerStream
}

type documentsUploadBinariesServer struct {
	grpc.ServerStream
}

func (x *documentsUploadBinariesServer) SendAndClose(m *common.Void) error {
	return x.ServerStream.SendMsg(m)
}

func (x *documentsUploadBinariesServer) Recv() (*UploadBinaryRequest, error) {
	m := new(UploadBinaryRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Documents_FreezeDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FreezeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentsServer).FreezeDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/documents.Documents/FreezeDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentsServer).FreezeDocument(ctx, req.(*FreezeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Documents_GetDocumentFileMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentsServer).GetDocumentFileMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/documents.Documents/GetDocumentFileMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentsServer).GetDocumentFileMeta(ctx, req.(*DocumentID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Documents_GetDocumentFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DocumentFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DocumentsServer).GetDocumentFile(m, &documentsGetDocumentFileServer{stream})
}

type Documents_GetDocumentFileServer interface {
	Send(*BinaryContent) error
	grpc.ServerStream
}

type documentsGetDocumentFileServer struct {
	grpc.ServerStream
}

func (x *documentsGetDocumentFileServer) Send(m *BinaryContent) error {
	return x.ServerStream.SendMsg(m)
}

func _Documents_UploadImage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DocumentsServer).UploadImage(&documentsUploadImageServer{stream})
}

type Documents_UploadImageServer interface {
	SendAndClose(*common.Void) error
	Recv() (*UploadImageRequest, error)
	grpc.ServerStream
}

type documentsUploadImageServer struct {
	grpc.ServerStream
}

func (x *documentsUploadImageServer) SendAndClose(m *common.Void) error {
	return x.ServerStream.SendMsg(m)
}

func (x *documentsUploadImageServer) Recv() (*UploadImageRequest, error) {
	m := new(UploadImageRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Documents_UpdatePage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentsServer).UpdatePage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/documents.Documents/UpdatePage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentsServer).UpdatePage(ctx, req.(*UpdatePageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Documents_ImageByID_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImageByIDRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DocumentsServer).ImageByID(m, &documentsImageByIDServer{stream})
}

type Documents_ImageByIDServer interface {
	Send(*Image) error
	grpc.ServerStream
}

type documentsImageByIDServer struct {
	grpc.ServerStream
}

func (x *documentsImageByIDServer) Send(m *Image) error {
	return x.ServerStream.SendMsg(m)
}

func _Documents_GetNextDocToProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentsServer).GetNextDocToProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/documents.Documents/GetNextDocToProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentsServer).GetNextDocToProcess(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Documents_DocFileByChecksums_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckSumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentsServer).DocFileByChecksums(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/documents.Documents/DocFileByChecksums",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentsServer).DocFileByChecksums(ctx, req.(*CheckSumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Documents_SubmitProcessingError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ErrorSubmission)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentsServer).SubmitProcessingError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/documents.Documents/SubmitProcessingError",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentsServer).SubmitProcessingError(ctx, req.(*ErrorSubmission))
	}
	return interceptor(ctx, in, info, handler)
}

func _Documents_DeleteDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentsServer).DeleteDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/documents.Documents/DeleteDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentsServer).DeleteDoc(ctx, req.(*DocumentID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Documents_StreamHTTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(h2gproxy.StreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DocumentsServer).StreamHTTP(m, &documentsStreamHTTPServer{stream})
}

type Documents_StreamHTTPServer interface {
	Send(*h2gproxy.StreamDataResponse) error
	grpc.ServerStream
}

type documentsStreamHTTPServer struct {
	grpc.ServerStream
}

func (x *documentsStreamHTTPServer) Send(m *h2gproxy.StreamDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Documents_serviceDesc = grpc.ServiceDesc{
	ServiceName: "documents.Documents",
	HandlerType: (*DocumentsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindWithText",
			Handler:    _Documents_FindWithText_Handler,
		},
		{
			MethodName: "CreateDocument",
			Handler:    _Documents_CreateDocument_Handler,
		},
		{
			MethodName: "SetKeywords",
			Handler:    _Documents_SetKeywords_Handler,
		},
		{
			MethodName: "FreezeDocument",
			Handler:    _Documents_FreezeDocument_Handler,
		},
		{
			MethodName: "GetDocumentFileMeta",
			Handler:    _Documents_GetDocumentFileMeta_Handler,
		},
		{
			MethodName: "UpdatePage",
			Handler:    _Documents_UpdatePage_Handler,
		},
		{
			MethodName: "GetNextDocToProcess",
			Handler:    _Documents_GetNextDocToProcess_Handler,
		},
		{
			MethodName: "DocFileByChecksums",
			Handler:    _Documents_DocFileByChecksums_Handler,
		},
		{
			MethodName: "SubmitProcessingError",
			Handler:    _Documents_SubmitProcessingError_Handler,
		},
		{
			MethodName: "DeleteDoc",
			Handler:    _Documents_DeleteDoc_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadBinaries",
			Handler:       _Documents_UploadBinaries_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetDocumentFile",
			Handler:       _Documents_GetDocumentFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "UploadImage",
			Handler:       _Documents_UploadImage_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ImageByID",
			Handler:       _Documents_ImageByID_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamHTTP",
			Handler:       _Documents_StreamHTTP_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "conradwood.net/apis/documents/documents.proto",
}

// Client API for DocumentProcessor service

type DocumentProcessorClient interface {
	Trigger(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*ProcessorTriggerResult, error)
}

type documentProcessorClient struct {
	cc *grpc.ClientConn
}

func NewDocumentProcessorClient(cc *grpc.ClientConn) DocumentProcessorClient {
	return &documentProcessorClient{cc}
}

func (c *documentProcessorClient) Trigger(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*ProcessorTriggerResult, error) {
	out := new(ProcessorTriggerResult)
	err := grpc.Invoke(ctx, "/documents.DocumentProcessor/Trigger", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DocumentProcessor service

type DocumentProcessorServer interface {
	Trigger(context.Context, *common.Void) (*ProcessorTriggerResult, error)
}

func RegisterDocumentProcessorServer(s *grpc.Server, srv DocumentProcessorServer) {
	s.RegisterService(&_DocumentProcessor_serviceDesc, srv)
}

func _DocumentProcessor_Trigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocumentProcessorServer).Trigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/documents.DocumentProcessor/Trigger",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocumentProcessorServer).Trigger(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _DocumentProcessor_serviceDesc = grpc.ServiceDesc{
	ServiceName: "documents.DocumentProcessor",
	HandlerType: (*DocumentProcessorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Trigger",
			Handler:    _DocumentProcessor_Trigger_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "conradwood.net/apis/documents/documents.proto",
}

func init() { proto.RegisterFile("conradwood.net/apis/documents/documents.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1461 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x58, 0x4d, 0x73, 0xdb, 0x44,
	0x18, 0x1e, 0x39, 0x76, 0x6c, 0xbf, 0x8e, 0xe3, 0x74, 0xd3, 0xa6, 0x8a, 0xfb, 0x81, 0x11, 0x84,
	0x31, 0x33, 0xc5, 0x75, 0xdd, 0x4b, 0xa7, 0x74, 0x18, 0xe2, 0xa8, 0x01, 0x4f, 0x9b, 0x36, 0xa3,
	0xb8, 0xd0, 0x0e, 0xc3, 0x41, 0xb1, 0x16, 0x47, 0x83, 0xa5, 0x15, 0x92, 0x3c, 0x8d, 0x7b, 0x62,
	0x72, 0x83, 0x1b, 0x57, 0x8e, 0xe5, 0x4f, 0xc0, 0x0c, 0x3f, 0x81, 0x23, 0x3f, 0x83, 0x3f, 0xc0,
	0x8d, 0xd9, 0x2f, 0x79, 0x25, 0xcb, 0x6e, 0x39, 0xf4, 0x14, 0xbf, 0x1f, 0xbb, 0xfb, 0xbc, 0x1f,
	0xfb, 0xbc, 0xab, 0xc0, 0x27, 0x23, 0xe2, 0x87, 0xb6, 0xf3, 0x92, 0x10, 0xa7, 0xe3, 0xe3, 0xf8,
	0xb6, 0x1d, 0xb8, 0xd1, 0x6d, 0x87, 0x8c, 0xa6, 0x1e, 0xf6, 0x63, 0xe5, 0x57, 0x27, 0x08, 0x49,
	0x4c, 0x50, 0x35, 0x51, 0x34, 0x3b, 0x63, 0x32, 0xb1, 0xfd, 0x71, 0x27, 0x6f, 0x83, 0x11, 0xf1,
	0x3c, 0xe2, 0x8b, 0x3f, 0x7c, 0x69, 0xb3, 0xb7, 0xc2, 0xff, 0xac, 0x37, 0x0e, 0x42, 0x72, 0x3e,
	0x4b, 0x7e, 0xf0, 0x35, 0xc6, 0xbf, 0x05, 0xa8, 0x98, 0xe2, 0x44, 0xb4, 0x09, 0x85, 0x81, 0xa9,
	0x6b, 0x2d, 0xad, 0x5d, 0xb4, 0x0a, 0x03, 0x13, 0x7d, 0x08, 0xf5, 0x63, 0x3b, 0x8c, 0xb0, 0x73,
	0x40, 0xfc, 0x18, 0xfb, 0xb1, 0x5e, 0x68, 0x69, 0xed, 0xaa, 0x95, 0x56, 0x22, 0x1d, 0xca, 0x07,
	0x21, 0xb6, 0x63, 0xec, 0xe8, 0x6b, 0x2d, 0xad, 0x5d, 0xb7, 0xa4, 0x88, 0xf6, 0xa0, 0x74, 0x6c,
	0x8f, 0x71, 0xa4, 0x17, 0x5b, 0x6b, 0xed, 0x5a, 0xaf, 0xd1, 0x99, 0x07, 0x4b, 0xf5, 0x16, 0xb7,
	0xa2, 0x36, 0x34, 0x06, 0x5e, 0x40, 0xc2, 0xf8, 0x80, 0x78, 0xc1, 0x04, 0xd3, 0x8d, 0x4a, 0x2d,
	0xad, 0x5d, 0xb1, 0xb2, 0x6a, 0xd4, 0x85, 0xed, 0xc7, 0x76, 0x14, 0x1f, 0x87, 0x64, 0x84, 0xa3,
	0xc8, 0xf5, 0xc7, 0x0f, 0xc3, 0x90, 0x84, 0xfa, 0x3a, 0x83, 0x95, 0x67, 0x42, 0x4d, 0xa8, 0x3c,
	0xc2, 0xb3, 0x97, 0x24, 0x74, 0x22, 0xbd, 0xcc, 0xdc, 0x12, 0x19, 0xdd, 0x83, 0xab, 0xe9, 0x25,
	0x43, 0xd7, 0xc3, 0x51, 0x6c, 0x7b, 0x81, 0x5e, 0x61, 0x81, 0x2c, 0x33, 0xa3, 0xcb, 0x50, 0x7a,
	0xfa, 0xd2, 0xc7, 0xa1, 0x5e, 0x65, 0x5b, 0x72, 0x01, 0x75, 0x00, 0xcd, 0x9d, 0xf7, 0xe3, 0x18,
	0x7b, 0x41, 0x1c, 0xe9, 0xc0, 0xb6, 0xca, 0xb1, 0x18, 0x7f, 0x68, 0xb0, 0x21, 0x73, 0x7f, 0xe8,
	0x4e, 0xf0, 0x42, 0xfe, 0xf7, 0xa0, 0x64, 0x92, 0xd1, 0xc0, 0x64, 0x79, 0x2f, 0xf6, 0x1b, 0xaf,
	0x2f, 0x76, 0x6b, 0x32, 0x85, 0x1d, 0xd7, 0xb1, 0xb8, 0x95, 0xc6, 0x48, 0x97, 0xfb, 0xb6, 0x87,
	0x59, 0x05, 0xaa, 0x56, 0x22, 0xa3, 0x9b, 0x00, 0x27, 0x31, 0x09, 0xed, 0x31, 0x7e, 0x84, 0x67,
	0x7a, 0x91, 0x59, 0x15, 0x0d, 0x5d, 0x7b, 0xe4, 0x7a, 0x78, 0x38, 0x0b, 0x30, 0x4b, 0x7a, 0xd5,
	0x4a, 0x64, 0x6a, 0x3b, 0x38, 0xc3, 0xa3, 0xef, 0xa3, 0xa9, 0x27, 0x52, 0x9c, 0xc8, 0xc6, 0xdf,
	0x1a, 0x94, 0xcd, 0xfe, 0xc0, 0xb3, 0xc7, 0x8b, 0xb0, 0x2f, 0x43, 0xe9, 0xc4, 0x7d, 0x85, 0x9f,
	0x33, 0xd8, 0x75, 0x8b, 0x0b, 0x52, 0xfb, 0x42, 0x34, 0x09, 0x17, 0x52, 0xe7, 0x17, 0x33, 0xe7,
	0xa7, 0xb1, 0x97, 0x16, 0xb0, 0xdf, 0x81, 0xaa, 0x49, 0x46, 0x34, 0xd4, 0x81, 0xc9, 0x00, 0x16,
	0xfb, 0xdb, 0xaf, 0x2f, 0x76, 0x1b, 0x32, 0x45, 0xdf, 0xb9, 0x13, 0x4c, 0xd3, 0x34, 0xf7, 0xa2,
	0x5b, 0xd2, 0x9e, 0x7b, 0x32, 0xf5, 0x4e, 0x71, 0xc8, 0x1a, 0xa2, 0x6e, 0x29, 0x1a, 0xe3, 0x2f,
	0x0d, 0x4a, 0xef, 0x36, 0x28, 0x7a, 0x5b, 0xc4, 0x6d, 0xa2, 0x11, 0x6d, 0x58, 0x52, 0x7c, 0x17,
	0xe1, 0xfc, 0xa9, 0x41, 0xf1, 0x38, 0x2f, 0x9a, 0x36, 0x94, 0x59, 0x98, 0x49, 0x6f, 0x6d, 0xbe,
	0xbe, 0xd8, 0x05, 0xe7, 0xd4, 0xa5, 0x4a, 0x7a, 0x88, 0x34, 0xa3, 0x16, 0xd4, 0x86, 0xf8, 0x3c,
	0x96, 0x98, 0x79, 0x7f, 0xa9, 0x2a, 0x74, 0x0f, 0x2a, 0x8f, 0x6d, 0x7f, 0x3c, 0xb5, 0xc7, 0x3c,
	0xda, 0xcd, 0xde, 0x56, 0x47, 0xf0, 0x92, 0xd4, 0xf7, 0xe1, 0xd7, 0x8b, 0xdd, 0xf5, 0xa9, 0xeb,
	0xc7, 0x77, 0x7b, 0x56, 0xe2, 0x9d, 0x81, 0x5f, 0x5a, 0x80, 0xff, 0x93, 0x06, 0x97, 0x9e, 0x05,
	0x8e, 0x1d, 0x63, 0x46, 0x17, 0xf8, 0x87, 0x29, 0x8e, 0x18, 0xdf, 0x48, 0xec, 0x3c, 0xa0, 0x65,
	0x58, 0x0b, 0xab, 0xb1, 0xae, 0xfd, 0x1f, 0xac, 0xc6, 0x2f, 0x1a, 0xd4, 0x4f, 0xb0, 0x1d, 0x8e,
	0xce, 0x9e, 0x06, 0xb1, 0x4b, 0xfc, 0x88, 0xb2, 0xe3, 0xc0, 0x1f, 0x4d, 0xa6, 0x0e, 0x66, 0xe7,
	0x47, 0x0c, 0x4d, 0xc5, 0x4a, 0x2b, 0x91, 0x01, 0x1b, 0x42, 0xc1, 0xa9, 0xb0, 0xc0, 0x9c, 0x52,
	0x3a, 0xda, 0x2f, 0xb4, 0x71, 0x8e, 0xec, 0xf3, 0xe7, 0xa2, 0x91, 0x12, 0x59, 0xb1, 0xbd, 0x60,
	0xd9, 0x9d, 0xdb, 0x5e, 0x18, 0xdf, 0xc0, 0x25, 0x1a, 0x1c, 0x87, 0x25, 0xd3, 0xd3, 0x83, 0xb2,
	0x40, 0xc8, 0x00, 0xd5, 0x7a, 0xba, 0x42, 0xbb, 0xa9, 0x08, 0x2c, 0xe9, 0x88, 0x10, 0x14, 0xe9,
	0x46, 0x22, 0x63, 0xec, 0xb7, 0xb1, 0x3f, 0x27, 0xa7, 0xc7, 0x6e, 0x24, 0xdb, 0x93, 0xef, 0xa3,
	0x6b, 0x8c, 0xd0, 0xb7, 0x95, 0x9d, 0xa5, 0xcd, 0x9a, 0x7b, 0x19, 0xb7, 0x60, 0x8b, 0x8f, 0x02,
	0x93, 0x8c, 0x94, 0xea, 0xc9, 0x69, 0xa1, 0xa5, 0xa6, 0x85, 0x61, 0xc3, 0xf6, 0xb3, 0x60, 0x42,
	0x6c, 0xa7, 0xef, 0xfa, 0x76, 0x38, 0x93, 0x0b, 0x2e, 0x4b, 0x12, 0xe4, 0xc5, 0xce, 0xe1, 0xbc,
	0x42, 0x86, 0xf3, 0x94, 0x2b, 0xb6, 0x96, 0xba, 0x62, 0xc6, 0x1e, 0xd4, 0x0f, 0x43, 0x8c, 0x5f,
	0xe1, 0x95, 0x9b, 0x1b, 0x77, 0x61, 0x5b, 0xe5, 0x65, 0xe9, 0x7c, 0x5d, 0xbd, 0xa0, 0x7c, 0xc1,
	0x5c, 0x61, 0x7c, 0x0c, 0x75, 0x0e, 0x5c, 0x9d, 0x8b, 0x02, 0x86, 0x96, 0x86, 0x61, 0x00, 0xc8,
	0xfd, 0x39, 0xb3, 0xe4, 0x60, 0x38, 0x84, 0x2d, 0x15, 0x03, 0x2b, 0x41, 0x8f, 0xcd, 0x6a, 0x2a,
	0xca, 0x0a, 0xec, 0xa4, 0x2b, 0x40, 0x4d, 0x47, 0x38, 0xb6, 0xad, 0xc4, 0xcf, 0xf8, 0x4d, 0x83,
	0x9a, 0x62, 0xc9, 0xe3, 0x35, 0x65, 0xc6, 0xbc, 0xcd, 0x48, 0x59, 0xc5, 0x6e, 0x4d, 0xa8, 0x88,
	0xcb, 0x18, 0xe9, 0xa5, 0xd6, 0x5a, 0xbb, 0x68, 0x25, 0xf2, 0xca, 0x71, 0xf2, 0xa3, 0x06, 0x88,
	0x17, 0x9f, 0xb9, 0xbf, 0x55, 0xc6, 0xd1, 0x0e, 0xac, 0x33, 0xb2, 0x20, 0x82, 0x93, 0x85, 0xb4,
	0xbc, 0xfe, 0xab, 0xa0, 0xd3, 0x66, 0x65, 0x67, 0xf7, 0x67, 0x03, 0xf3, 0x8d, 0x54, 0x63, 0xfc,
	0xac, 0x01, 0xda, 0x77, 0x1c, 0x7a, 0x22, 0xbd, 0x2d, 0x72, 0x81, 0x80, 0x94, 0xf8, 0x0b, 0x29,
	0xef, 0x82, 0xa1, 0x5b, 0x6f, 0xe6, 0x22, 0x85, 0x2b, 0xd5, 0x87, 0x4c, 0x31, 0xfd, 0x90, 0x31,
	0x1e, 0x41, 0x83, 0xbd, 0x76, 0x4e, 0xa6, 0xa7, 0x9e, 0x1b, 0x45, 0x2e, 0xf1, 0x97, 0xdc, 0x1a,
	0x03, 0x36, 0x98, 0xe3, 0x11, 0x8e, 0x22, 0x7a, 0x2c, 0x87, 0x93, 0xd2, 0x19, 0xb7, 0xa1, 0xc1,
	0xca, 0x72, 0x32, 0xf5, 0x94, 0x32, 0x48, 0x15, 0x6f, 0xbc, 0xaa, 0x35, 0x57, 0x18, 0xbf, 0x6b,
	0xb0, 0xc5, 0x79, 0x85, 0xb3, 0x74, 0x34, 0x9d, 0xc4, 0xe8, 0x03, 0x3e, 0x78, 0x04, 0x05, 0x2d,
	0xbc, 0xfc, 0xf8, 0x54, 0xfa, 0x48, 0x0c, 0x5b, 0x86, 0xa3, 0xd6, 0xdb, 0x52, 0xbc, 0x78, 0x1b,
	0x88, 0x59, 0xdc, 0x85, 0xb2, 0xa8, 0x3a, 0x4b, 0xd4, 0xf2, 0xb6, 0x97, 0x6e, 0x68, 0x0f, 0xd6,
	0x4c, 0x32, 0x62, 0x89, 0x5a, 0x42, 0x53, 0xd4, 0x4e, 0x39, 0x4e, 0x92, 0x27, 0x43, 0x7d, 0x47,
	0x3e, 0x58, 0xf9, 0xed, 0xba, 0xb6, 0xc0, 0x9c, 0xf3, 0x08, 0xc5, 0xe3, 0xd5, 0xf8, 0x16, 0x1a,
	0xb2, 0x0e, 0x6f, 0x64, 0xac, 0xa4, 0x80, 0x85, 0xcc, 0x4b, 0x54, 0x87, 0xb2, 0x85, 0x83, 0x89,
	0x3d, 0xe2, 0x01, 0x56, 0x2c, 0x29, 0x1a, 0x5d, 0xd8, 0x11, 0x2f, 0x47, 0x12, 0x0e, 0x43, 0x77,
	0x3c, 0xc6, 0xa1, 0xc0, 0xba, 0x03, 0xeb, 0x83, 0xa8, 0x3f, 0x8d, 0x66, 0x62, 0xee, 0x08, 0xa9,
	0xf7, 0x4f, 0x59, 0x21, 0x6a, 0xf4, 0x10, 0x36, 0x0e, 0x5d, 0xdf, 0xf9, 0xda, 0x8d, 0xcf, 0x58,
	0xd3, 0x5d, 0x57, 0x42, 0x5a, 0x98, 0x1d, 0xcd, 0xab, 0x0b, 0x01, 0x8b, 0xc3, 0xfa, 0xb0, 0x99,
	0x30, 0x39, 0xff, 0x56, 0x50, 0x73, 0x93, 0x25, 0xf9, 0x66, 0x5e, 0xc6, 0xd1, 0x67, 0x50, 0x3b,
	0xc1, 0x71, 0x12, 0x73, 0x53, 0xf1, 0xc9, 0x64, 0x30, 0x7f, 0xfd, 0xe7, 0xb0, 0xa9, 0xcc, 0x07,
	0x17, 0x47, 0xe8, 0xa6, 0xe2, 0x96, 0x33, 0x3a, 0x9a, 0x1b, 0xf2, 0x3e, 0x7d, 0x45, 0x5c, 0xa7,
	0xad, 0xa1, 0x7b, 0xb0, 0xc9, 0xe9, 0x3f, 0xd9, 0x53, 0x9d, 0x8d, 0xa9, 0xc9, 0x90, 0x5e, 0x8b,
	0x06, 0xb0, 0xfd, 0x05, 0x8e, 0x55, 0x42, 0x66, 0x64, 0x7a, 0x25, 0x07, 0xe7, 0xc0, 0x6c, 0x5e,
	0xcb, 0x51, 0x27, 0x24, 0x7e, 0x04, 0x8d, 0xcc, 0x56, 0xa9, 0x38, 0x72, 0x06, 0x4f, 0x53, 0x45,
	0x99, 0x9a, 0x31, 0x5d, 0x0d, 0x3d, 0x80, 0x9a, 0x42, 0x9c, 0xe8, 0xc6, 0x42, 0x4a, 0x54, 0x42,
	0x5d, 0xc8, 0xc8, 0xa7, 0x00, 0xf3, 0x07, 0x56, 0xaa, 0x39, 0x16, 0xde, 0x5d, 0xcd, 0xec, 0x25,
	0x46, 0x0f, 0xa0, 0x9a, 0x30, 0x66, 0xaa, 0x1f, 0xb2, 0x3c, 0xda, 0x5c, 0xb8, 0xd9, 0x5d, 0x0d,
	0xdd, 0x67, 0x29, 0x7d, 0x82, 0xcf, 0x69, 0x2e, 0x86, 0x44, 0x74, 0x39, 0x4a, 0x21, 0x6c, 0xe6,
	0x27, 0x18, 0x1d, 0x01, 0x12, 0x37, 0xbd, 0x3f, 0x93, 0x33, 0x24, 0xdd, 0x51, 0x19, 0x0a, 0x5b,
	0x5d, 0x92, 0x7d, 0xb8, 0xc2, 0xa8, 0x73, 0xf1, 0xeb, 0x51, 0x59, 0x95, 0x61, 0xd8, 0x4c, 0x83,
	0x74, 0xa1, 0x6a, 0x62, 0xfa, 0x91, 0x6a, 0x92, 0xd1, 0xb2, 0xb6, 0x48, 0xaf, 0x78, 0x48, 0xbf,
	0x6e, 0x42, 0x6c, 0x7b, 0x5f, 0x0e, 0x87, 0xc7, 0xe8, 0x6a, 0x27, 0xf9, 0x30, 0xe7, 0x5a, 0x09,
	0xfc, 0x7a, 0xd6, 0x60, 0xda, 0xb1, 0x6d, 0xe1, 0x28, 0x20, 0x7e, 0x84, 0xbb, 0x5a, 0xef, 0x29,
	0x5c, 0x92, 0x47, 0x24, 0x44, 0x81, 0xee, 0x43, 0x59, 0x90, 0x45, 0x26, 0x9f, 0xef, 0xab, 0x35,
	0xcc, 0xe5, 0x95, 0xfe, 0x7b, 0x70, 0xc3, 0xc7, 0xb1, 0xfa, 0x4f, 0x04, 0x3b, 0x70, 0xa3, 0xf9,
	0xba, 0xd3, 0x75, 0xf6, 0x9f, 0x83, 0xbb, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x07, 0x08, 0x0e,
	0xb5, 0xd9, 0x10, 0x00, 0x00,
}
