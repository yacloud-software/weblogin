// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/quota/quota.proto
// DO NOT EDIT!

/*
Package quota is a generated protocol buffer package.

It is generated from these files:
	golang.conradwood.net/apis/quota/quota.proto

It has these top-level messages:
	QuotaCall
	QuotaStall
	QuotaResponse
	QuotaStallResponse
	Bucket
	BucketList
*/
package quota

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// some "call" that needs a quota enforcement
// the counters work on ALL set parameters,
// thus if you leave any blank or continuously
// set them to the same string, they'll share the same
// quota limit
type QuotaCall struct {
	// we can set either IP or User or both.
	SourceIP string `protobuf:"bytes,1,opt,name=SourceIP" json:"SourceIP,omitempty"`
	// if we set IP and not User we get some
	// protection against DoS.
	User string `protobuf:"bytes,2,opt,name=User" json:"User,omitempty"`
	// below is the system that needs protecting.
	// usually that will be the system who makes the call
	// to Quota service, so if "" it will be derived from
	// the metadata in the context.
	// sometimes we need to sit in the layer above, for
	// examples when talking to gateways (they
	// only protect themselves by resetting themselves if one
	// hits them too fast)
	TargetSystem   string `protobuf:"bytes,3,opt,name=TargetSystem" json:"TargetSystem,omitempty"`
	TargetInstance string `protobuf:"bytes,4,opt,name=TargetInstance" json:"TargetInstance,omitempty"`
	TargetCall     string `protobuf:"bytes,5,opt,name=TargetCall" json:"TargetCall,omitempty"`
	// there might be an internal resource that we need
	// to protect.
	// Example:
	Other string `protobuf:"bytes,6,opt,name=Other" json:"Other,omitempty"`
}

func (m *QuotaCall) Reset()                    { *m = QuotaCall{} }
func (m *QuotaCall) String() string            { return proto.CompactTextString(m) }
func (*QuotaCall) ProtoMessage()               {}
func (*QuotaCall) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *QuotaCall) GetSourceIP() string {
	if m != nil {
		return m.SourceIP
	}
	return ""
}

func (m *QuotaCall) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *QuotaCall) GetTargetSystem() string {
	if m != nil {
		return m.TargetSystem
	}
	return ""
}

func (m *QuotaCall) GetTargetInstance() string {
	if m != nil {
		return m.TargetInstance
	}
	return ""
}

func (m *QuotaCall) GetTargetCall() string {
	if m != nil {
		return m.TargetCall
	}
	return ""
}

func (m *QuotaCall) GetOther() string {
	if m != nil {
		return m.Other
	}
	return ""
}

type QuotaStall struct {
	QuotaCall *QuotaCall `protobuf:"bytes,1,opt,name=QuotaCall" json:"QuotaCall,omitempty"`
	TimeoutMS int32      `protobuf:"varint,2,opt,name=TimeoutMS" json:"TimeoutMS,omitempty"`
}

func (m *QuotaStall) Reset()                    { *m = QuotaStall{} }
func (m *QuotaStall) String() string            { return proto.CompactTextString(m) }
func (*QuotaStall) ProtoMessage()               {}
func (*QuotaStall) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *QuotaStall) GetQuotaCall() *QuotaCall {
	if m != nil {
		return m.QuotaCall
	}
	return nil
}

func (m *QuotaStall) GetTimeoutMS() int32 {
	if m != nil {
		return m.TimeoutMS
	}
	return 0
}

type QuotaResponse struct {
	OverLimit bool `protobuf:"varint,1,opt,name=OverLimit" json:"OverLimit,omitempty"`
}

func (m *QuotaResponse) Reset()                    { *m = QuotaResponse{} }
func (m *QuotaResponse) String() string            { return proto.CompactTextString(m) }
func (*QuotaResponse) ProtoMessage()               {}
func (*QuotaResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *QuotaResponse) GetOverLimit() bool {
	if m != nil {
		return m.OverLimit
	}
	return false
}

type QuotaStallResponse struct {
	// how long did we stall for?
	StalledForMS int32 `protobuf:"varint,1,opt,name=StalledForMS" json:"StalledForMS,omitempty"`
	// true if good to go or false if we need
	// to decline the call at this time
	GoodToGo bool `protobuf:"varint,2,opt,name=GoodToGo" json:"GoodToGo,omitempty"`
}

func (m *QuotaStallResponse) Reset()                    { *m = QuotaStallResponse{} }
func (m *QuotaStallResponse) String() string            { return proto.CompactTextString(m) }
func (*QuotaStallResponse) ProtoMessage()               {}
func (*QuotaStallResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *QuotaStallResponse) GetStalledForMS() int32 {
	if m != nil {
		return m.StalledForMS
	}
	return 0
}

func (m *QuotaStallResponse) GetGoodToGo() bool {
	if m != nil {
		return m.GoodToGo
	}
	return false
}

type Bucket struct {
	System        string  `protobuf:"bytes,1,opt,name=System" json:"System,omitempty"`
	Instance      string  `protobuf:"bytes,2,opt,name=Instance" json:"Instance,omitempty"`
	IP            string  `protobuf:"bytes,3,opt,name=IP" json:"IP,omitempty"`
	User          string  `protobuf:"bytes,4,opt,name=User" json:"User,omitempty"`
	RefillsPerSec float64 `protobuf:"fixed64,5,opt,name=RefillsPerSec" json:"RefillsPerSec,omitempty"`
}

func (m *Bucket) Reset()                    { *m = Bucket{} }
func (m *Bucket) String() string            { return proto.CompactTextString(m) }
func (*Bucket) ProtoMessage()               {}
func (*Bucket) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Bucket) GetSystem() string {
	if m != nil {
		return m.System
	}
	return ""
}

func (m *Bucket) GetInstance() string {
	if m != nil {
		return m.Instance
	}
	return ""
}

func (m *Bucket) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *Bucket) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Bucket) GetRefillsPerSec() float64 {
	if m != nil {
		return m.RefillsPerSec
	}
	return 0
}

type BucketList struct {
	Buckets []*Bucket `protobuf:"bytes,1,rep,name=Buckets" json:"Buckets,omitempty"`
}

func (m *BucketList) Reset()                    { *m = BucketList{} }
func (m *BucketList) String() string            { return proto.CompactTextString(m) }
func (*BucketList) ProtoMessage()               {}
func (*BucketList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *BucketList) GetBuckets() []*Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

func init() {
	proto.RegisterType((*QuotaCall)(nil), "quota.QuotaCall")
	proto.RegisterType((*QuotaStall)(nil), "quota.QuotaStall")
	proto.RegisterType((*QuotaResponse)(nil), "quota.QuotaResponse")
	proto.RegisterType((*QuotaStallResponse)(nil), "quota.QuotaStallResponse")
	proto.RegisterType((*Bucket)(nil), "quota.Bucket")
	proto.RegisterType((*BucketList)(nil), "quota.BucketList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for QuotaService service

type QuotaServiceClient interface {
	// got hit, check if it's good to execute
	AskForAccess(ctx context.Context, in *QuotaCall, opts ...grpc.CallOption) (*QuotaResponse, error)
	// throw an error on timeout
	StallIfNeededWithErr(ctx context.Context, in *QuotaStall, opts ...grpc.CallOption) (*QuotaStallResponse, error)
	// do not throw an error - just return "false" instead
	StallIfNeeded(ctx context.Context, in *QuotaStall, opts ...grpc.CallOption) (*QuotaStallResponse, error)
	// list all buckets known currently
	ListBuckets(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*BucketList, error)
}

type quotaServiceClient struct {
	cc *grpc.ClientConn
}

func NewQuotaServiceClient(cc *grpc.ClientConn) QuotaServiceClient {
	return &quotaServiceClient{cc}
}

func (c *quotaServiceClient) AskForAccess(ctx context.Context, in *QuotaCall, opts ...grpc.CallOption) (*QuotaResponse, error) {
	out := new(QuotaResponse)
	err := grpc.Invoke(ctx, "/quota.QuotaService/AskForAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quotaServiceClient) StallIfNeededWithErr(ctx context.Context, in *QuotaStall, opts ...grpc.CallOption) (*QuotaStallResponse, error) {
	out := new(QuotaStallResponse)
	err := grpc.Invoke(ctx, "/quota.QuotaService/StallIfNeededWithErr", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quotaServiceClient) StallIfNeeded(ctx context.Context, in *QuotaStall, opts ...grpc.CallOption) (*QuotaStallResponse, error) {
	out := new(QuotaStallResponse)
	err := grpc.Invoke(ctx, "/quota.QuotaService/StallIfNeeded", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quotaServiceClient) ListBuckets(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*BucketList, error) {
	out := new(BucketList)
	err := grpc.Invoke(ctx, "/quota.QuotaService/ListBuckets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for QuotaService service

type QuotaServiceServer interface {
	// got hit, check if it's good to execute
	AskForAccess(context.Context, *QuotaCall) (*QuotaResponse, error)
	// throw an error on timeout
	StallIfNeededWithErr(context.Context, *QuotaStall) (*QuotaStallResponse, error)
	// do not throw an error - just return "false" instead
	StallIfNeeded(context.Context, *QuotaStall) (*QuotaStallResponse, error)
	// list all buckets known currently
	ListBuckets(context.Context, *common.Void) (*BucketList, error)
}

func RegisterQuotaServiceServer(s *grpc.Server, srv QuotaServiceServer) {
	s.RegisterService(&_QuotaService_serviceDesc, srv)
}

func _QuotaService_AskForAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuotaCall)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuotaServiceServer).AskForAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/quota.QuotaService/AskForAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuotaServiceServer).AskForAccess(ctx, req.(*QuotaCall))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuotaService_StallIfNeededWithErr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuotaStall)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuotaServiceServer).StallIfNeededWithErr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/quota.QuotaService/StallIfNeededWithErr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuotaServiceServer).StallIfNeededWithErr(ctx, req.(*QuotaStall))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuotaService_StallIfNeeded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuotaStall)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuotaServiceServer).StallIfNeeded(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/quota.QuotaService/StallIfNeeded",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuotaServiceServer).StallIfNeeded(ctx, req.(*QuotaStall))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuotaService_ListBuckets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuotaServiceServer).ListBuckets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/quota.QuotaService/ListBuckets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuotaServiceServer).ListBuckets(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _QuotaService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "quota.QuotaService",
	HandlerType: (*QuotaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AskForAccess",
			Handler:    _QuotaService_AskForAccess_Handler,
		},
		{
			MethodName: "StallIfNeededWithErr",
			Handler:    _QuotaService_StallIfNeededWithErr_Handler,
		},
		{
			MethodName: "StallIfNeeded",
			Handler:    _QuotaService_StallIfNeeded_Handler,
		},
		{
			MethodName: "ListBuckets",
			Handler:    _QuotaService_ListBuckets_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.conradwood.net/apis/quota/quota.proto",
}

func init() { proto.RegisterFile("golang.conradwood.net/apis/quota/quota.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 499 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x53, 0x4f, 0x6f, 0xd3, 0x4e,
	0x10, 0x95, 0xd3, 0x24, 0xbf, 0x64, 0x92, 0x54, 0xbf, 0xae, 0x22, 0x64, 0x2c, 0x84, 0x22, 0x0b,
	0x41, 0x0f, 0xe0, 0x4a, 0x41, 0x70, 0xe3, 0x50, 0xfe, 0xb4, 0x8a, 0xd4, 0xd2, 0xb0, 0x0e, 0x20,
	0x71, 0x33, 0xf6, 0x34, 0xb5, 0x6a, 0x7b, 0xc2, 0xee, 0xa6, 0x88, 0x2f, 0xc0, 0xb7, 0xe2, 0x93,
	0x71, 0x41, 0x9e, 0x35, 0x8e, 0x4d, 0x25, 0x24, 0x2e, 0x89, 0xdf, 0xdb, 0xf7, 0x46, 0x33, 0x6f,
	0x34, 0xf0, 0x78, 0x4d, 0x59, 0x54, 0xac, 0x83, 0x98, 0x0a, 0x15, 0x25, 0x5f, 0x89, 0x92, 0xa0,
	0x40, 0x73, 0x14, 0x6d, 0x52, 0x7d, 0xf4, 0x65, 0x4b, 0x26, 0xb2, 0xbf, 0xc1, 0x46, 0x91, 0x21,
	0xd1, 0x63, 0xe0, 0x05, 0x7f, 0x31, 0xc5, 0x94, 0xe7, 0x54, 0x54, 0x7f, 0xd6, 0xe6, 0xff, 0x70,
	0x60, 0xf8, 0xae, 0x74, 0xbe, 0x8a, 0xb2, 0x4c, 0x78, 0x30, 0x08, 0x69, 0xab, 0x62, 0x5c, 0x2c,
	0x5d, 0x67, 0xe6, 0x1c, 0x0e, 0x65, 0x8d, 0x85, 0x80, 0xee, 0x7b, 0x8d, 0xca, 0xed, 0x30, 0xcf,
	0xdf, 0xc2, 0x87, 0xf1, 0x2a, 0x52, 0x6b, 0x34, 0xe1, 0x37, 0x6d, 0x30, 0x77, 0xf7, 0xf8, 0xad,
	0xc5, 0x89, 0x87, 0xb0, 0x6f, 0xf1, 0xa2, 0xd0, 0x26, 0x2a, 0x62, 0x74, 0xbb, 0xac, 0xfa, 0x83,
	0x15, 0xf7, 0x01, 0x2c, 0x53, 0x76, 0xe2, 0xf6, 0x58, 0xd3, 0x60, 0xc4, 0x14, 0x7a, 0x17, 0xe6,
	0x0a, 0x95, 0xdb, 0xe7, 0x27, 0x0b, 0xfc, 0x4f, 0x00, 0xdc, 0x7e, 0x68, 0x4a, 0x4d, 0xd0, 0x18,
	0x86, 0x07, 0x18, 0xcd, 0xff, 0x0f, 0x6c, 0x4a, 0x35, 0x2f, 0x1b, 0xf3, 0xde, 0x83, 0xe1, 0x2a,
	0xcd, 0x91, 0xb6, 0xe6, 0x3c, 0xe4, 0xc1, 0x7a, 0x72, 0x47, 0xf8, 0x4f, 0x60, 0xc2, 0x52, 0x89,
	0x7a, 0x43, 0x85, 0xc6, 0x52, 0x7e, 0x71, 0x83, 0xea, 0x2c, 0xcd, 0x53, 0xc3, 0xe5, 0x07, 0x72,
	0x47, 0xf8, 0x2b, 0x10, 0xbb, 0x56, 0x6a, 0x8f, 0x0f, 0x63, 0x26, 0x30, 0x39, 0x21, 0x75, 0x1e,
	0xb2, 0xad, 0x27, 0x5b, 0x5c, 0x19, 0xfb, 0x29, 0x51, 0xb2, 0xa2, 0x53, 0xe2, 0x2e, 0x06, 0xb2,
	0xc6, 0xfe, 0x77, 0x07, 0xfa, 0x2f, 0xb7, 0xf1, 0x35, 0x1a, 0x71, 0x07, 0xfa, 0x55, 0xce, 0x76,
	0x37, 0x15, 0x2a, 0xed, 0x75, 0xb6, 0x76, 0x3b, 0x35, 0x16, 0xfb, 0xd0, 0x59, 0x2c, 0xab, 0xbd,
	0x74, 0x1a, 0x5b, 0xec, 0x36, 0xb6, 0xf8, 0x00, 0x26, 0x12, 0x2f, 0xd3, 0x2c, 0xd3, 0x4b, 0x54,
	0x21, 0xc6, 0x1c, 0xbe, 0x23, 0xdb, 0xa4, 0xff, 0x0c, 0xc0, 0xf6, 0x71, 0x96, 0x6a, 0x23, 0x1e,
	0xc1, 0x7f, 0x16, 0x69, 0xd7, 0x99, 0xed, 0x1d, 0x8e, 0xe6, 0x93, 0x2a, 0x67, 0xcb, 0xca, 0xdf,
	0xaf, 0xf3, 0x9f, 0x0e, 0x8c, 0x6d, 0x2c, 0xa8, 0x6e, 0xd2, 0x18, 0xc5, 0x73, 0x18, 0x1f, 0xeb,
	0xeb, 0x13, 0x52, 0xc7, 0x71, 0x8c, 0x5a, 0x8b, 0x5b, 0x0b, 0xf2, 0xa6, 0x4d, 0xa6, 0x0e, 0xf2,
	0x35, 0x4c, 0x39, 0xb4, 0xc5, 0xe5, 0x5b, 0xc4, 0x04, 0x93, 0x8f, 0xa9, 0xb9, 0x7a, 0xa3, 0x94,
	0x38, 0x68, 0xaa, 0x59, 0xe1, 0xdd, 0xbd, 0x45, 0xd5, 0x55, 0x5e, 0xc0, 0xa4, 0x55, 0xe5, 0x1f,
	0xed, 0x01, 0x8c, 0xca, 0xf1, 0xab, 0xe1, 0xc4, 0x38, 0xa8, 0x8e, 0xe9, 0x03, 0xa5, 0x89, 0x77,
	0xd0, 0x8a, 0x80, 0x75, 0x3e, 0xcc, 0x0a, 0x34, 0xcd, 0x6b, 0xac, 0xee, 0xb3, 0x3c, 0x48, 0x2b,
	0xff, 0xdc, 0xe7, 0x4b, 0x7c, 0xfa, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x36, 0xe7, 0x7d, 0x16, 0xf0,
	0x03, 0x00, 0x00,
}
