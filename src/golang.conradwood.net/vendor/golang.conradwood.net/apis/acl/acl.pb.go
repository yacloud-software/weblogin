// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/acl/acl.proto
// DO NOT EDIT!

/*
Package acl is a generated protocol buffer package.

It is generated from these files:
	golang.conradwood.net/apis/acl/acl.proto

It has these top-level messages:
	NewAsset
	AddAssetRequest
	Asset
	AddAssetResponse
	AssetType
	AssetTypeResponse
	NewPermission
	CreatePermissionRequest
	PermissionRequest
	Permission
	PermissionResponse
	DeletedPermission
	DeletePermissionResponse
	Hub
	Account
	Sensor
	LegalEntity
	Site
	Structure
	CheckLegalEntityAccessRequest
	CheckSiteAccessRequest
	CheckStructureAccessRequest
	RpcRequest
	HasPermission
*/
package acl

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// NewAsset represents the details of a new asset to be tracked by the acl module
type NewAsset struct {
	// TypeID is the ID value from the asset types table
	TypeID uint32 `protobuf:"varint,1,opt,name=TypeID" json:"TypeID,omitempty"`
	// AssetID is the unique identifier of the asset e.g. SensorLocationID, hotID, hesAccountID etc
	AssetID string `protobuf:"bytes,2,opt,name=AssetID" json:"AssetID,omitempty"`
}

func (m *NewAsset) Reset()                    { *m = NewAsset{} }
func (m *NewAsset) String() string            { return proto.CompactTextString(m) }
func (*NewAsset) ProtoMessage()               {}
func (*NewAsset) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *NewAsset) GetTypeID() uint32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

func (m *NewAsset) GetAssetID() string {
	if m != nil {
		return m.AssetID
	}
	return ""
}

// A request to add a new asset. Can receive multiple NewAsset entries
type AddAssetRequest struct {
	// list of NewAsset entries
	NewAssets []*NewAsset `protobuf:"bytes,1,rep,name=NewAssets" json:"NewAssets,omitempty"`
}

func (m *AddAssetRequest) Reset()                    { *m = AddAssetRequest{} }
func (m *AddAssetRequest) String() string            { return proto.CompactTextString(m) }
func (*AddAssetRequest) ProtoMessage()               {}
func (*AddAssetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AddAssetRequest) GetNewAssets() []*NewAsset {
	if m != nil {
		return m.NewAssets
	}
	return nil
}

// Asset represents the details of an asset that's being tracked by the acl module
type Asset struct {
	// the id column value in the assets table
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// the type_id column value in the assets table
	TypeID uint32 `protobuf:"varint,2,opt,name=TypeID" json:"TypeID,omitempty"`
	// the asset_id column value in the assets table
	AssetID string `protobuf:"bytes,3,opt,name=AssetID" json:"AssetID,omitempty"`
}

func (m *Asset) Reset()                    { *m = Asset{} }
func (m *Asset) String() string            { return proto.CompactTextString(m) }
func (*Asset) ProtoMessage()               {}
func (*Asset) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Asset) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Asset) GetTypeID() uint32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

func (m *Asset) GetAssetID() string {
	if m != nil {
		return m.AssetID
	}
	return ""
}

// AddAssetResponse is the response sent back when a new asset(s) is to be tracked by the acl module
type AddAssetResponse struct {
	// List of Asset entries
	Assets []*Asset `protobuf:"bytes,1,rep,name=Assets" json:"Assets,omitempty"`
}

func (m *AddAssetResponse) Reset()                    { *m = AddAssetResponse{} }
func (m *AddAssetResponse) String() string            { return proto.CompactTextString(m) }
func (*AddAssetResponse) ProtoMessage()               {}
func (*AddAssetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *AddAssetResponse) GetAssets() []*Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

// AssetType represents the details of an asset type
type AssetType struct {
	// the id column value in the asset types table
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// the name column value in the asset types table
	Name string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	// the description column value in the asset types table
	Description string `protobuf:"bytes,3,opt,name=Description" json:"Description,omitempty"`
}

func (m *AssetType) Reset()                    { *m = AssetType{} }
func (m *AssetType) String() string            { return proto.CompactTextString(m) }
func (*AssetType) ProtoMessage()               {}
func (*AssetType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *AssetType) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *AssetType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AssetType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// AssetTypeResponse is the response sent back when a list of assets was requested
type AssetTypeResponse struct {
	// List of AssetType etries
	AssetTypes []*AssetType `protobuf:"bytes,1,rep,name=AssetTypes" json:"AssetTypes,omitempty"`
}

func (m *AssetTypeResponse) Reset()                    { *m = AssetTypeResponse{} }
func (m *AssetTypeResponse) String() string            { return proto.CompactTextString(m) }
func (*AssetTypeResponse) ProtoMessage()               {}
func (*AssetTypeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *AssetTypeResponse) GetAssetTypes() []*AssetType {
	if m != nil {
		return m.AssetTypes
	}
	return nil
}

// NewPermission represents the details of a new permission to be assigned to an auth.Group entry
type NewPermission struct {
	// the auth.Group.ID rpc entry
	GroupID string `protobuf:"bytes,1,opt,name=GroupID" json:"GroupID,omitempty"`
	// the rpcaclapi.Method.ID rpc entry
	RpcID uint64 `protobuf:"varint,2,opt,name=RpcID" json:"RpcID,omitempty"`
	// the ID column value from the assets table
	AssetID uint64 `protobuf:"varint,3,opt,name=AssetID" json:"AssetID,omitempty"`
}

func (m *NewPermission) Reset()                    { *m = NewPermission{} }
func (m *NewPermission) String() string            { return proto.CompactTextString(m) }
func (*NewPermission) ProtoMessage()               {}
func (*NewPermission) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *NewPermission) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *NewPermission) GetRpcID() uint64 {
	if m != nil {
		return m.RpcID
	}
	return 0
}

func (m *NewPermission) GetAssetID() uint64 {
	if m != nil {
		return m.AssetID
	}
	return 0
}

// A request to create a new permission. Can receive multiple NewPermission entries
type CreatePermissionRequest struct {
	// List of NewPermission entries
	NewPermissions []*NewPermission `protobuf:"bytes,1,rep,name=NewPermissions" json:"NewPermissions,omitempty"`
}

func (m *CreatePermissionRequest) Reset()                    { *m = CreatePermissionRequest{} }
func (m *CreatePermissionRequest) String() string            { return proto.CompactTextString(m) }
func (*CreatePermissionRequest) ProtoMessage()               {}
func (*CreatePermissionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CreatePermissionRequest) GetNewPermissions() []*NewPermission {
	if m != nil {
		return m.NewPermissions
	}
	return nil
}

// PermissionRequest is used when an action should be performed to one or more existing permissions
type PermissionRequest struct {
	// List of ids from the permissions table
	IDs []uint64 `protobuf:"varint,1,rep,packed,name=IDs" json:"IDs,omitempty"`
}

func (m *PermissionRequest) Reset()                    { *m = PermissionRequest{} }
func (m *PermissionRequest) String() string            { return proto.CompactTextString(m) }
func (*PermissionRequest) ProtoMessage()               {}
func (*PermissionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *PermissionRequest) GetIDs() []uint64 {
	if m != nil {
		return m.IDs
	}
	return nil
}

// Permission represents the details of a permission on the system
type Permission struct {
	// the id column value from the permissions table
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// the group_id column value from the permissions table
	GroupID string `protobuf:"bytes,2,opt,name=GroupID" json:"GroupID,omitempty"`
	// the rpc_id column value from the permissions table
	RpcID uint64 `protobuf:"varint,3,opt,name=RpcID" json:"RpcID,omitempty"`
	// the asset_id column value from the permissions table
	AssetID uint64 `protobuf:"varint,4,opt,name=AssetID" json:"AssetID,omitempty"`
}

func (m *Permission) Reset()                    { *m = Permission{} }
func (m *Permission) String() string            { return proto.CompactTextString(m) }
func (*Permission) ProtoMessage()               {}
func (*Permission) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Permission) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Permission) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *Permission) GetRpcID() uint64 {
	if m != nil {
		return m.RpcID
	}
	return 0
}

func (m *Permission) GetAssetID() uint64 {
	if m != nil {
		return m.AssetID
	}
	return 0
}

// PermissionResponse represents the details sent back when a list of permissions is required
type PermissionResponse struct {
	// List of permissions
	Permissions []*Permission `protobuf:"bytes,1,rep,name=Permissions" json:"Permissions,omitempty"`
}

func (m *PermissionResponse) Reset()                    { *m = PermissionResponse{} }
func (m *PermissionResponse) String() string            { return proto.CompactTextString(m) }
func (*PermissionResponse) ProtoMessage()               {}
func (*PermissionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *PermissionResponse) GetPermissions() []*Permission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

// DeletedPermission represents the status of a permission after a delete request was carried out on it
type DeletedPermission struct {
	// the id column value from the permissions table
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// true / false indicating whether the permission was successfully
	Status bool `protobuf:"varint,2,opt,name=status" json:"status,omitempty"`
}

func (m *DeletedPermission) Reset()                    { *m = DeletedPermission{} }
func (m *DeletedPermission) String() string            { return proto.CompactTextString(m) }
func (*DeletedPermission) ProtoMessage()               {}
func (*DeletedPermission) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *DeletedPermission) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DeletedPermission) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

// DeletePermissionResponse represents the response sent back after a request to delete 1 or more permissions
type DeletePermissionResponse struct {
	// List of DeletedPermission each indicating whether the deletion was successful or not
	DeletedPermissions []*DeletedPermission `protobuf:"bytes,1,rep,name=DeletedPermissions" json:"DeletedPermissions,omitempty"`
}

func (m *DeletePermissionResponse) Reset()                    { *m = DeletePermissionResponse{} }
func (m *DeletePermissionResponse) String() string            { return proto.CompactTextString(m) }
func (*DeletePermissionResponse) ProtoMessage()               {}
func (*DeletePermissionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *DeletePermissionResponse) GetDeletedPermissions() []*DeletedPermission {
	if m != nil {
		return m.DeletedPermissions
	}
	return nil
}

// Hub represents a list of hotID entries
type Hub struct {
	// HotID for the hub
	HotID []uint32 `protobuf:"varint,2,rep,packed,name=HotID" json:"HotID,omitempty"`
}

func (m *Hub) Reset()                    { *m = Hub{} }
func (m *Hub) String() string            { return proto.CompactTextString(m) }
func (*Hub) ProtoMessage()               {}
func (*Hub) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Hub) GetHotID() []uint32 {
	if m != nil {
		return m.HotID
	}
	return nil
}

// Account represents a list of hesAccountIDs
type Account struct {
	// ID is a hesAccountID
	ID []uint64 `protobuf:"varint,1,rep,packed,name=ID" json:"ID,omitempty"`
}

func (m *Account) Reset()                    { *m = Account{} }
func (m *Account) String() string            { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()               {}
func (*Account) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Account) GetID() []uint64 {
	if m != nil {
		return m.ID
	}
	return nil
}

// Sensor represents a list of SensorLocationIDs
type Sensor struct {
	// ID is a SensorLocationID
	ID []uint64 `protobuf:"varint,1,rep,packed,name=ID" json:"ID,omitempty"`
}

func (m *Sensor) Reset()                    { *m = Sensor{} }
func (m *Sensor) String() string            { return proto.CompactTextString(m) }
func (*Sensor) ProtoMessage()               {}
func (*Sensor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Sensor) GetID() []uint64 {
	if m != nil {
		return m.ID
	}
	return nil
}

// LegalEntity represents a list of LegalEntityIDs
type LegalEntity struct {
	// ID of the Legal Entity
	LegalEntityID []uint32 `protobuf:"varint,1,rep,packed,name=LegalEntityID" json:"LegalEntityID,omitempty"`
}

func (m *LegalEntity) Reset()                    { *m = LegalEntity{} }
func (m *LegalEntity) String() string            { return proto.CompactTextString(m) }
func (*LegalEntity) ProtoMessage()               {}
func (*LegalEntity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *LegalEntity) GetLegalEntityID() []uint32 {
	if m != nil {
		return m.LegalEntityID
	}
	return nil
}

// Site represents a list of Site IDs
type Site struct {
	// ID of the Site
	SiteID []uint32 `protobuf:"varint,2,rep,packed,name=SiteID" json:"SiteID,omitempty"`
}

func (m *Site) Reset()                    { *m = Site{} }
func (m *Site) String() string            { return proto.CompactTextString(m) }
func (*Site) ProtoMessage()               {}
func (*Site) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Site) GetSiteID() []uint32 {
	if m != nil {
		return m.SiteID
	}
	return nil
}

// Structure represents a list of Structure IDs
type Structure struct {
	// ID of the Structure
	StructureID []uint32 `protobuf:"varint,2,rep,packed,name=StructureID" json:"StructureID,omitempty"`
}

func (m *Structure) Reset()                    { *m = Structure{} }
func (m *Structure) String() string            { return proto.CompactTextString(m) }
func (*Structure) ProtoMessage()               {}
func (*Structure) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *Structure) GetStructureID() []uint32 {
	if m != nil {
		return m.StructureID
	}
	return nil
}

// LegalEntity represents a list of Legal Entity IDS
type CheckLegalEntityAccessRequest struct {
	// ID of the Legal Entity
	LegalEntityID []uint32 `protobuf:"varint,1,rep,packed,name=LegalEntityID" json:"LegalEntityID,omitempty"`
}

func (m *CheckLegalEntityAccessRequest) Reset()                    { *m = CheckLegalEntityAccessRequest{} }
func (m *CheckLegalEntityAccessRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckLegalEntityAccessRequest) ProtoMessage()               {}
func (*CheckLegalEntityAccessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *CheckLegalEntityAccessRequest) GetLegalEntityID() []uint32 {
	if m != nil {
		return m.LegalEntityID
	}
	return nil
}

// CheckSiteRequest represents a list of Site IDs
type CheckSiteAccessRequest struct {
	// ID of the Site
	SiteID []uint32 `protobuf:"varint,2,rep,packed,name=SiteID" json:"SiteID,omitempty"`
}

func (m *CheckSiteAccessRequest) Reset()                    { *m = CheckSiteAccessRequest{} }
func (m *CheckSiteAccessRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckSiteAccessRequest) ProtoMessage()               {}
func (*CheckSiteAccessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *CheckSiteAccessRequest) GetSiteID() []uint32 {
	if m != nil {
		return m.SiteID
	}
	return nil
}

// CheckStructureRequest represents a list of Structure IDs
type CheckStructureAccessRequest struct {
	// ID of the Structure
	StructureID []uint32 `protobuf:"varint,2,rep,packed,name=StructureID" json:"StructureID,omitempty"`
}

func (m *CheckStructureAccessRequest) Reset()                    { *m = CheckStructureAccessRequest{} }
func (m *CheckStructureAccessRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckStructureAccessRequest) ProtoMessage()               {}
func (*CheckStructureAccessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *CheckStructureAccessRequest) GetStructureID() []uint32 {
	if m != nil {
		return m.StructureID
	}
	return nil
}

// RpcRequest is a list of rpcaclapi.Method.ID entries
type RpcRequest struct {
	// ID is a rpcaclapi.Method.ID
	ID []uint64 `protobuf:"varint,1,rep,packed,name=ID" json:"ID,omitempty"`
}

func (m *RpcRequest) Reset()                    { *m = RpcRequest{} }
func (m *RpcRequest) String() string            { return proto.CompactTextString(m) }
func (*RpcRequest) ProtoMessage()               {}
func (*RpcRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *RpcRequest) GetID() []uint64 {
	if m != nil {
		return m.ID
	}
	return nil
}

// HasPermission indicates whether a user has a certain permission or not
type HasPermission struct {
	Status bool `protobuf:"varint,1,opt,name=status" json:"status,omitempty"`
}

func (m *HasPermission) Reset()                    { *m = HasPermission{} }
func (m *HasPermission) String() string            { return proto.CompactTextString(m) }
func (*HasPermission) ProtoMessage()               {}
func (*HasPermission) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *HasPermission) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

func init() {
	proto.RegisterType((*NewAsset)(nil), "acl.NewAsset")
	proto.RegisterType((*AddAssetRequest)(nil), "acl.AddAssetRequest")
	proto.RegisterType((*Asset)(nil), "acl.Asset")
	proto.RegisterType((*AddAssetResponse)(nil), "acl.AddAssetResponse")
	proto.RegisterType((*AssetType)(nil), "acl.AssetType")
	proto.RegisterType((*AssetTypeResponse)(nil), "acl.AssetTypeResponse")
	proto.RegisterType((*NewPermission)(nil), "acl.NewPermission")
	proto.RegisterType((*CreatePermissionRequest)(nil), "acl.CreatePermissionRequest")
	proto.RegisterType((*PermissionRequest)(nil), "acl.PermissionRequest")
	proto.RegisterType((*Permission)(nil), "acl.Permission")
	proto.RegisterType((*PermissionResponse)(nil), "acl.PermissionResponse")
	proto.RegisterType((*DeletedPermission)(nil), "acl.DeletedPermission")
	proto.RegisterType((*DeletePermissionResponse)(nil), "acl.DeletePermissionResponse")
	proto.RegisterType((*Hub)(nil), "acl.Hub")
	proto.RegisterType((*Account)(nil), "acl.Account")
	proto.RegisterType((*Sensor)(nil), "acl.Sensor")
	proto.RegisterType((*LegalEntity)(nil), "acl.LegalEntity")
	proto.RegisterType((*Site)(nil), "acl.Site")
	proto.RegisterType((*Structure)(nil), "acl.Structure")
	proto.RegisterType((*CheckLegalEntityAccessRequest)(nil), "acl.CheckLegalEntityAccessRequest")
	proto.RegisterType((*CheckSiteAccessRequest)(nil), "acl.CheckSiteAccessRequest")
	proto.RegisterType((*CheckStructureAccessRequest)(nil), "acl.CheckStructureAccessRequest")
	proto.RegisterType((*RpcRequest)(nil), "acl.RpcRequest")
	proto.RegisterType((*HasPermission)(nil), "acl.HasPermission")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AclService service

type AclServiceClient interface {
	// Get list of asset types
	GetAssetTypes(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*AssetTypeResponse, error)
	// AddAssets receives a list of new assets to be added to the module
	AddAssets(ctx context.Context, in *AddAssetRequest, opts ...grpc.CallOption) (*AddAssetResponse, error)
	// CreatePermissions receives a list of permissions to be created and returns a
	// response with the list of permissions that have been created
	CreatePermissions(ctx context.Context, in *CreatePermissionRequest, opts ...grpc.CallOption) (*PermissionResponse, error)
	// DeletePermissions receives a list of permissions to be deleted and returns a
	// a corresponding list indicating whether the deletion was successful for each
	// permission
	DeletePermissions(ctx context.Context, in *PermissionRequest, opts ...grpc.CallOption) (*DeletePermissionResponse, error)
	// CheckHubAccess checks whether a user has access to a certain hub based on the rpc call being made
	CheckHubAccess(ctx context.Context, in *Hub, opts ...grpc.CallOption) (*HasPermission, error)
	// CheckAccountAccess checks whether a user has access to a certain account based on the rpc call being made
	CheckAccountAccess(ctx context.Context, in *Account, opts ...grpc.CallOption) (*HasPermission, error)
	// CheckSensorAccess checks whether a user has access to a certain sensor based on the rpc call being made
	CheckSensorAccess(ctx context.Context, in *Sensor, opts ...grpc.CallOption) (*HasPermission, error)
	// CheckLegalEntityAccess checks whether a user has access to a certain legal entity based on the rpc call being made
	CheckLegalEntityAccess(ctx context.Context, in *CheckLegalEntityAccessRequest, opts ...grpc.CallOption) (*HasPermission, error)
	// CheckSiteAccess checks whether a user has access to a certain site based on the rpc call being made
	CheckSiteAccess(ctx context.Context, in *CheckSiteAccessRequest, opts ...grpc.CallOption) (*HasPermission, error)
	// CheckStructureAccess checks whether a user has access to a certain structure based on the rpc call being made
	CheckStructureAccess(ctx context.Context, in *CheckStructureAccessRequest, opts ...grpc.CallOption) (*HasPermission, error)
	// HubsWithAccess receives a list of rpcaclapi.Method.ID entries and returns a list of hubs
	// that the user can carry out all those rpc calls on
	HubsWithAccess(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*Hub, error)
	// AccountsWithAccess receives a list of rpcaclapi.Method.ID entries and returns a list of accounts
	// that the user can carry out all those rpc calls on
	AccountsWithAccess(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*Account, error)
	// SensorsWithAccess receives a list of rpcaclapi.Method.ID entries and returns a list of sensors
	// that the user can carry out all those rpc calls on
	SensorsWithAccess(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*Sensor, error)
	// LegalEntitiesWithAccess receives a list of rpcaclapi.Method.ID entries and returns a list of legal entities
	// that the user can carry out all those rpc calls on
	LegalEntitiesWithAccess(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*LegalEntity, error)
	// SitesWithAccess receives a list of rpcaclapi.Method.ID entries and returns a list of sites
	// that the user can carry out all those rpc calls on
	SitesWithAccess(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*Site, error)
	// StructuresWithAccess receives a list of rpcaclapi.Method.ID entries and returns a list of structures
	// that the user can carry out all those rpc calls on
	StructuresWithAccess(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*Structure, error)
}

type aclServiceClient struct {
	cc *grpc.ClientConn
}

func NewAclServiceClient(cc *grpc.ClientConn) AclServiceClient {
	return &aclServiceClient{cc}
}

func (c *aclServiceClient) GetAssetTypes(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*AssetTypeResponse, error) {
	out := new(AssetTypeResponse)
	err := grpc.Invoke(ctx, "/acl.AclService/GetAssetTypes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) AddAssets(ctx context.Context, in *AddAssetRequest, opts ...grpc.CallOption) (*AddAssetResponse, error) {
	out := new(AddAssetResponse)
	err := grpc.Invoke(ctx, "/acl.AclService/AddAssets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) CreatePermissions(ctx context.Context, in *CreatePermissionRequest, opts ...grpc.CallOption) (*PermissionResponse, error) {
	out := new(PermissionResponse)
	err := grpc.Invoke(ctx, "/acl.AclService/CreatePermissions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) DeletePermissions(ctx context.Context, in *PermissionRequest, opts ...grpc.CallOption) (*DeletePermissionResponse, error) {
	out := new(DeletePermissionResponse)
	err := grpc.Invoke(ctx, "/acl.AclService/DeletePermissions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) CheckHubAccess(ctx context.Context, in *Hub, opts ...grpc.CallOption) (*HasPermission, error) {
	out := new(HasPermission)
	err := grpc.Invoke(ctx, "/acl.AclService/CheckHubAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) CheckAccountAccess(ctx context.Context, in *Account, opts ...grpc.CallOption) (*HasPermission, error) {
	out := new(HasPermission)
	err := grpc.Invoke(ctx, "/acl.AclService/CheckAccountAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) CheckSensorAccess(ctx context.Context, in *Sensor, opts ...grpc.CallOption) (*HasPermission, error) {
	out := new(HasPermission)
	err := grpc.Invoke(ctx, "/acl.AclService/CheckSensorAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) CheckLegalEntityAccess(ctx context.Context, in *CheckLegalEntityAccessRequest, opts ...grpc.CallOption) (*HasPermission, error) {
	out := new(HasPermission)
	err := grpc.Invoke(ctx, "/acl.AclService/CheckLegalEntityAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) CheckSiteAccess(ctx context.Context, in *CheckSiteAccessRequest, opts ...grpc.CallOption) (*HasPermission, error) {
	out := new(HasPermission)
	err := grpc.Invoke(ctx, "/acl.AclService/CheckSiteAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) CheckStructureAccess(ctx context.Context, in *CheckStructureAccessRequest, opts ...grpc.CallOption) (*HasPermission, error) {
	out := new(HasPermission)
	err := grpc.Invoke(ctx, "/acl.AclService/CheckStructureAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) HubsWithAccess(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*Hub, error) {
	out := new(Hub)
	err := grpc.Invoke(ctx, "/acl.AclService/HubsWithAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) AccountsWithAccess(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*Account, error) {
	out := new(Account)
	err := grpc.Invoke(ctx, "/acl.AclService/AccountsWithAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) SensorsWithAccess(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*Sensor, error) {
	out := new(Sensor)
	err := grpc.Invoke(ctx, "/acl.AclService/SensorsWithAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) LegalEntitiesWithAccess(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*LegalEntity, error) {
	out := new(LegalEntity)
	err := grpc.Invoke(ctx, "/acl.AclService/LegalEntitiesWithAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) SitesWithAccess(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*Site, error) {
	out := new(Site)
	err := grpc.Invoke(ctx, "/acl.AclService/SitesWithAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclServiceClient) StructuresWithAccess(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*Structure, error) {
	out := new(Structure)
	err := grpc.Invoke(ctx, "/acl.AclService/StructuresWithAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AclService service

type AclServiceServer interface {
	// Get list of asset types
	GetAssetTypes(context.Context, *common.Void) (*AssetTypeResponse, error)
	// AddAssets receives a list of new assets to be added to the module
	AddAssets(context.Context, *AddAssetRequest) (*AddAssetResponse, error)
	// CreatePermissions receives a list of permissions to be created and returns a
	// response with the list of permissions that have been created
	CreatePermissions(context.Context, *CreatePermissionRequest) (*PermissionResponse, error)
	// DeletePermissions receives a list of permissions to be deleted and returns a
	// a corresponding list indicating whether the deletion was successful for each
	// permission
	DeletePermissions(context.Context, *PermissionRequest) (*DeletePermissionResponse, error)
	// CheckHubAccess checks whether a user has access to a certain hub based on the rpc call being made
	CheckHubAccess(context.Context, *Hub) (*HasPermission, error)
	// CheckAccountAccess checks whether a user has access to a certain account based on the rpc call being made
	CheckAccountAccess(context.Context, *Account) (*HasPermission, error)
	// CheckSensorAccess checks whether a user has access to a certain sensor based on the rpc call being made
	CheckSensorAccess(context.Context, *Sensor) (*HasPermission, error)
	// CheckLegalEntityAccess checks whether a user has access to a certain legal entity based on the rpc call being made
	CheckLegalEntityAccess(context.Context, *CheckLegalEntityAccessRequest) (*HasPermission, error)
	// CheckSiteAccess checks whether a user has access to a certain site based on the rpc call being made
	CheckSiteAccess(context.Context, *CheckSiteAccessRequest) (*HasPermission, error)
	// CheckStructureAccess checks whether a user has access to a certain structure based on the rpc call being made
	CheckStructureAccess(context.Context, *CheckStructureAccessRequest) (*HasPermission, error)
	// HubsWithAccess receives a list of rpcaclapi.Method.ID entries and returns a list of hubs
	// that the user can carry out all those rpc calls on
	HubsWithAccess(context.Context, *RpcRequest) (*Hub, error)
	// AccountsWithAccess receives a list of rpcaclapi.Method.ID entries and returns a list of accounts
	// that the user can carry out all those rpc calls on
	AccountsWithAccess(context.Context, *RpcRequest) (*Account, error)
	// SensorsWithAccess receives a list of rpcaclapi.Method.ID entries and returns a list of sensors
	// that the user can carry out all those rpc calls on
	SensorsWithAccess(context.Context, *RpcRequest) (*Sensor, error)
	// LegalEntitiesWithAccess receives a list of rpcaclapi.Method.ID entries and returns a list of legal entities
	// that the user can carry out all those rpc calls on
	LegalEntitiesWithAccess(context.Context, *RpcRequest) (*LegalEntity, error)
	// SitesWithAccess receives a list of rpcaclapi.Method.ID entries and returns a list of sites
	// that the user can carry out all those rpc calls on
	SitesWithAccess(context.Context, *RpcRequest) (*Site, error)
	// StructuresWithAccess receives a list of rpcaclapi.Method.ID entries and returns a list of structures
	// that the user can carry out all those rpc calls on
	StructuresWithAccess(context.Context, *RpcRequest) (*Structure, error)
}

func RegisterAclServiceServer(s *grpc.Server, srv AclServiceServer) {
	s.RegisterService(&_AclService_serviceDesc, srv)
}

func _AclService_GetAssetTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).GetAssetTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/GetAssetTypes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).GetAssetTypes(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_AddAssets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAssetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).AddAssets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/AddAssets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).AddAssets(ctx, req.(*AddAssetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_CreatePermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePermissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).CreatePermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/CreatePermissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).CreatePermissions(ctx, req.(*CreatePermissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_DeletePermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PermissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).DeletePermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/DeletePermissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).DeletePermissions(ctx, req.(*PermissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_CheckHubAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Hub)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).CheckHubAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/CheckHubAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).CheckHubAccess(ctx, req.(*Hub))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_CheckAccountAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Account)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).CheckAccountAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/CheckAccountAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).CheckAccountAccess(ctx, req.(*Account))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_CheckSensorAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Sensor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).CheckSensorAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/CheckSensorAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).CheckSensorAccess(ctx, req.(*Sensor))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_CheckLegalEntityAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckLegalEntityAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).CheckLegalEntityAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/CheckLegalEntityAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).CheckLegalEntityAccess(ctx, req.(*CheckLegalEntityAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_CheckSiteAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckSiteAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).CheckSiteAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/CheckSiteAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).CheckSiteAccess(ctx, req.(*CheckSiteAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_CheckStructureAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckStructureAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).CheckStructureAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/CheckStructureAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).CheckStructureAccess(ctx, req.(*CheckStructureAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_HubsWithAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).HubsWithAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/HubsWithAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).HubsWithAccess(ctx, req.(*RpcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_AccountsWithAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).AccountsWithAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/AccountsWithAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).AccountsWithAccess(ctx, req.(*RpcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_SensorsWithAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).SensorsWithAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/SensorsWithAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).SensorsWithAccess(ctx, req.(*RpcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_LegalEntitiesWithAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).LegalEntitiesWithAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/LegalEntitiesWithAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).LegalEntitiesWithAccess(ctx, req.(*RpcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_SitesWithAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).SitesWithAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/SitesWithAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).SitesWithAccess(ctx, req.(*RpcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclService_StructuresWithAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServiceServer).StructuresWithAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/acl.AclService/StructuresWithAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServiceServer).StructuresWithAccess(ctx, req.(*RpcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AclService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "acl.AclService",
	HandlerType: (*AclServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAssetTypes",
			Handler:    _AclService_GetAssetTypes_Handler,
		},
		{
			MethodName: "AddAssets",
			Handler:    _AclService_AddAssets_Handler,
		},
		{
			MethodName: "CreatePermissions",
			Handler:    _AclService_CreatePermissions_Handler,
		},
		{
			MethodName: "DeletePermissions",
			Handler:    _AclService_DeletePermissions_Handler,
		},
		{
			MethodName: "CheckHubAccess",
			Handler:    _AclService_CheckHubAccess_Handler,
		},
		{
			MethodName: "CheckAccountAccess",
			Handler:    _AclService_CheckAccountAccess_Handler,
		},
		{
			MethodName: "CheckSensorAccess",
			Handler:    _AclService_CheckSensorAccess_Handler,
		},
		{
			MethodName: "CheckLegalEntityAccess",
			Handler:    _AclService_CheckLegalEntityAccess_Handler,
		},
		{
			MethodName: "CheckSiteAccess",
			Handler:    _AclService_CheckSiteAccess_Handler,
		},
		{
			MethodName: "CheckStructureAccess",
			Handler:    _AclService_CheckStructureAccess_Handler,
		},
		{
			MethodName: "HubsWithAccess",
			Handler:    _AclService_HubsWithAccess_Handler,
		},
		{
			MethodName: "AccountsWithAccess",
			Handler:    _AclService_AccountsWithAccess_Handler,
		},
		{
			MethodName: "SensorsWithAccess",
			Handler:    _AclService_SensorsWithAccess_Handler,
		},
		{
			MethodName: "LegalEntitiesWithAccess",
			Handler:    _AclService_LegalEntitiesWithAccess_Handler,
		},
		{
			MethodName: "SitesWithAccess",
			Handler:    _AclService_SitesWithAccess_Handler,
		},
		{
			MethodName: "StructuresWithAccess",
			Handler:    _AclService_StructuresWithAccess_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.conradwood.net/apis/acl/acl.proto",
}

func init() { proto.RegisterFile("golang.conradwood.net/apis/acl/acl.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 867 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x56, 0x6d, 0x6f, 0xe3, 0x44,
	0x10, 0x56, 0xe2, 0x5c, 0xda, 0x4c, 0xce, 0x49, 0xb3, 0x0a, 0x69, 0x48, 0xef, 0x4e, 0xd1, 0x0a,
	0x44, 0xa4, 0xd3, 0xf9, 0xb8, 0x2b, 0x1c, 0x08, 0x4e, 0xa0, 0x5c, 0x53, 0x9a, 0xa0, 0xaa, 0x2a,
	0x0e, 0x2f, 0xe2, 0xa3, 0xe3, 0x2c, 0xad, 0x45, 0xe2, 0x35, 0xde, 0x35, 0x55, 0xff, 0x26, 0xbf,
	0x08, 0x79, 0x77, 0x6d, 0xaf, 0x5f, 0x62, 0xf8, 0x50, 0xc5, 0x33, 0x7e, 0x9e, 0xd9, 0x67, 0x5e,
	0x76, 0x6a, 0x98, 0xdd, 0xd1, 0x9d, 0xe3, 0xdf, 0x59, 0x2e, 0xf5, 0x43, 0x67, 0xfb, 0x40, 0xe9,
	0xd6, 0xf2, 0x09, 0x7f, 0xed, 0x04, 0x1e, 0x7b, 0xed, 0xb8, 0xbb, 0xf8, 0xcf, 0x0a, 0x42, 0xca,
	0x29, 0x32, 0x1c, 0x77, 0x37, 0xb1, 0x6a, 0xe0, 0x2e, 0xdd, 0xef, 0xa9, 0xaf, 0x7e, 0x24, 0x09,
	0xbf, 0x87, 0xe3, 0x1b, 0xf2, 0x30, 0x67, 0x8c, 0x70, 0x34, 0x82, 0xf6, 0xcf, 0x8f, 0x01, 0x59,
	0x2d, 0xc6, 0x8d, 0x69, 0x63, 0x66, 0xda, 0xca, 0x42, 0x63, 0x38, 0x12, 0x80, 0xd5, 0x62, 0xdc,
	0x9c, 0x36, 0x66, 0x1d, 0x3b, 0x31, 0xf1, 0x77, 0xd0, 0x9f, 0x6f, 0xb7, 0xc2, 0xb2, 0xc9, 0x5f,
	0x11, 0x61, 0x1c, 0xbd, 0x84, 0x4e, 0x12, 0x90, 0x8d, 0x1b, 0x53, 0x63, 0xd6, 0x7d, 0x6b, 0x5a,
	0xb1, 0xc8, 0xc4, 0x6b, 0x67, 0xef, 0xf1, 0x0a, 0x9e, 0xc8, 0xa3, 0x7b, 0xd0, 0x54, 0xc7, 0xb6,
	0xec, 0xe6, 0x6a, 0xa1, 0x49, 0x69, 0x1e, 0x92, 0x62, 0xe4, 0xa5, 0xbc, 0x83, 0x93, 0x4c, 0x0a,
	0x0b, 0xa8, 0xcf, 0x08, 0xc2, 0xd0, 0xce, 0x09, 0x01, 0x21, 0x44, 0x62, 0xd4, 0x1b, 0xfc, 0x13,
	0x74, 0xc4, 0x53, 0x7c, 0x40, 0x49, 0x06, 0x82, 0xd6, 0x8d, 0xb3, 0x27, 0x2a, 0x6d, 0xf1, 0x8c,
	0xa6, 0xd0, 0x5d, 0x10, 0xe6, 0x86, 0x5e, 0xc0, 0x3d, 0xea, 0x2b, 0x19, 0xba, 0x0b, 0x5f, 0xc0,
	0x20, 0x0d, 0x99, 0x6a, 0xb1, 0x00, 0x52, 0x67, 0xa2, 0xa7, 0x97, 0xe9, 0x11, 0x58, 0x0d, 0x81,
	0x7f, 0x07, 0xf3, 0x86, 0x3c, 0xdc, 0x92, 0x70, 0xef, 0x31, 0xe6, 0x51, 0x3f, 0x4e, 0xfd, 0x2a,
	0xa4, 0x51, 0xa0, 0x04, 0x76, 0xec, 0xc4, 0x44, 0x43, 0x78, 0x62, 0x07, 0xae, 0xaa, 0x55, 0xcb,
	0x96, 0x46, 0xb1, 0x54, 0xad, 0xac, 0x54, 0xbf, 0xc0, 0xe9, 0x45, 0x48, 0x1c, 0x4e, 0xb2, 0xe8,
	0x49, 0xf7, 0xbe, 0x81, 0x5e, 0xee, 0xd4, 0x44, 0x29, 0x4a, 0x5a, 0xa8, 0x51, 0x0a, 0x48, 0xfc,
	0x29, 0x0c, 0xca, 0x01, 0x4f, 0xc0, 0x58, 0x2d, 0x64, 0x94, 0x96, 0x1d, 0x3f, 0xe2, 0x3f, 0x00,
	0xb4, 0xac, 0x8a, 0x15, 0xd7, 0xb2, 0x6c, 0x1e, 0xc8, 0xd2, 0x38, 0x90, 0x65, 0x2b, 0x9f, 0xe5,
	0x15, 0x20, 0x5d, 0x8e, 0x6a, 0xc3, 0x1b, 0xe8, 0x96, 0xb3, 0xeb, 0x8b, 0xec, 0x34, 0xb4, 0x8e,
	0xc1, 0xdf, 0xc2, 0x60, 0x41, 0x76, 0x84, 0x93, 0x6d, 0x8d, 0xee, 0x11, 0xb4, 0x19, 0x77, 0x78,
	0xc4, 0x84, 0xec, 0x63, 0x5b, 0x59, 0x78, 0x03, 0x63, 0x49, 0xae, 0xd0, 0xf2, 0x03, 0xa0, 0x52,
	0xe0, 0x44, 0xd2, 0x48, 0x48, 0x2a, 0xbd, 0xb6, 0x2b, 0x18, 0xf8, 0x0c, 0x8c, 0x65, 0xb4, 0x89,
	0x0b, 0xb4, 0xa4, 0xf2, 0x92, 0x1a, 0x33, 0xd3, 0x96, 0x06, 0xfe, 0x18, 0x8e, 0xe6, 0xae, 0x4b,
	0x23, 0x3f, 0xbb, 0x64, 0x86, 0xd4, 0x8c, 0xc7, 0xd0, 0x5e, 0x13, 0x9f, 0xd1, 0xb0, 0xf4, 0xe6,
	0x1c, 0xba, 0xd7, 0xe4, 0xce, 0xd9, 0x5d, 0xfa, 0xdc, 0xe3, 0x8f, 0xe8, 0x13, 0x30, 0x35, 0x53,
	0x21, 0x4d, 0x3b, 0xef, 0xc4, 0x2f, 0xa0, 0xb5, 0xf6, 0x38, 0x89, 0x4b, 0x11, 0xff, 0xa6, 0x42,
	0x94, 0x85, 0x5f, 0x41, 0x67, 0xcd, 0xc3, 0xc8, 0xe5, 0x51, 0x28, 0x6e, 0x51, 0x6a, 0xa4, 0x48,
	0xdd, 0x85, 0x2f, 0xe1, 0xf9, 0xc5, 0x3d, 0x71, 0xff, 0xd4, 0x0e, 0x99, 0xbb, 0x2e, 0x61, 0x2c,
	0x19, 0xad, 0xff, 0xa7, 0xea, 0x73, 0x18, 0x89, 0x30, 0xb1, 0x88, 0x3c, 0xff, 0x90, 0xce, 0xef,
	0xe1, 0x4c, 0x32, 0x12, 0x31, 0x79, 0xda, 0x7f, 0x2b, 0x7f, 0x06, 0x60, 0x07, 0x6e, 0x82, 0x2f,
	0xd6, 0xf6, 0x33, 0x30, 0x97, 0x0e, 0xd3, 0x46, 0x29, 0x1b, 0x9d, 0x86, 0x3e, 0x3a, 0x6f, 0xff,
	0x39, 0x02, 0x98, 0xbb, 0xbb, 0x35, 0x09, 0xff, 0xf6, 0x5c, 0x82, 0xbe, 0x04, 0xf3, 0x8a, 0xf0,
	0x6c, 0x43, 0xa0, 0xa7, 0x96, 0xda, 0xe4, 0xbf, 0x52, 0x6f, 0x3b, 0x19, 0x15, 0x76, 0x49, 0x32,
	0x64, 0x5f, 0x43, 0x27, 0xd9, 0x8b, 0x0c, 0x0d, 0x25, 0x28, 0xbf, 0xb2, 0x27, 0x1f, 0x15, 0xbc,
	0x8a, 0xf9, 0x23, 0x0c, 0x8a, 0x6b, 0x82, 0xa1, 0x67, 0x02, 0x7b, 0x60, 0x7d, 0x4c, 0x4e, 0x8b,
	0x17, 0x49, 0x8b, 0x55, 0xbc, 0x06, 0x0c, 0x8d, 0x4a, 0x68, 0x19, 0xe5, 0xb9, 0x36, 0xfb, 0x15,
	0xb1, 0x2c, 0xe8, 0x89, 0xfe, 0x2c, 0xa3, 0x8d, 0xec, 0x0c, 0x3a, 0x16, 0x84, 0x65, 0xb4, 0x99,
	0xc8, 0x3d, 0x95, 0xaf, 0xef, 0x3b, 0x40, 0x02, 0xaf, 0xae, 0x81, 0xe2, 0x3c, 0x95, 0x49, 0x4b,
	0x5f, 0x25, 0xef, 0x0b, 0x18, 0xc8, 0x39, 0x10, 0x77, 0x44, 0xd1, 0xba, 0x02, 0x28, 0x5d, 0x95,
	0xac, 0x5b, 0x35, 0x6f, 0xa5, 0xb1, 0x45, 0x58, 0x96, 0xae, 0x6e, 0xa6, 0x2b, 0x23, 0x7e, 0x80,
	0x7e, 0x61, 0x82, 0xd1, 0x59, 0x16, 0xaa, 0x34, 0xd7, 0x95, 0x31, 0xae, 0x61, 0x58, 0x35, 0xd3,
	0x68, 0xaa, 0x05, 0xaa, 0x1c, 0xf7, 0xca, 0x68, 0x2f, 0xa1, 0xb7, 0x8c, 0x36, 0xec, 0x37, 0x8f,
	0xdf, 0xab, 0x38, 0x72, 0x83, 0x66, 0x53, 0x3f, 0x49, 0x5b, 0x82, 0xce, 0x01, 0xa9, 0x2a, 0xd7,
	0x12, 0x72, 0xfd, 0x40, 0x6f, 0x60, 0x20, 0x6b, 0x5c, 0xcb, 0xd1, 0x9b, 0x81, 0xde, 0xc3, 0x69,
	0x56, 0x56, 0x8f, 0xd4, 0x12, 0x4f, 0x84, 0x43, 0x5f, 0x71, 0xaf, 0xa0, 0x1f, 0x57, 0xb2, 0x96,
	0xd5, 0x91, 0xc7, 0xc5, 0x3b, 0xee, 0x2b, 0x18, 0xa6, 0xf5, 0xaa, 0xe5, 0xc8, 0x7f, 0xf1, 0x29,
	0xf6, 0xc3, 0x14, 0x5e, 0xf8, 0x84, 0xeb, 0x9f, 0x67, 0xea, 0x83, 0x2d, 0xfe, 0x42, 0x8b, 0xb1,
	0x9b, 0xb6, 0xf8, 0x30, 0x3b, 0xff, 0x37, 0x00, 0x00, 0xff, 0xff, 0xc8, 0x4a, 0x28, 0x02, 0xf9,
	0x09, 0x00, 0x00,
}
