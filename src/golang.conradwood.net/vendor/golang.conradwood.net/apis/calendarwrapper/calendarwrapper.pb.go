// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/calendarwrapper/calendarwrapper.proto
// DO NOT EDIT!

/*
Package calendarwrapper is a generated protocol buffer package.

It is generated from these files:
	golang.conradwood.net/apis/calendarwrapper/calendarwrapper.proto

It has these top-level messages:
	TwoCalendar
	TwoCalendarFull
	SyncList
	SyncOrder
	CalendarLog
	LogEntryList
	LogRequest
	Office365Credentials
	Office365CalendarRequest
	UserURL
	MSOfficeState
	MSOfficeUserCreds
	MSOfficeCalendar
	GSuiteCalendar
	GSuiteApplication
	GSuiteAuthState
	GSuiteUserCreds
	AccessRequest
	AccessResponse
	SQLCalendar
	SQLEvent
	Calendar
	CalendarList
	Attendee
	Event
	EventList
	EventRequest
*/
package calendarwrapper

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import h2gproxy "golang.conradwood.net/apis/h2gproxy"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type LogEntryType int32

const (
	LogEntryType_UNDEFINED LogEntryType = 0
	LogEntryType_DELETE    LogEntryType = 1
	LogEntryType_ADD       LogEntryType = 2
)

var LogEntryType_name = map[int32]string{
	0: "UNDEFINED",
	1: "DELETE",
	2: "ADD",
}
var LogEntryType_value = map[string]int32{
	"UNDEFINED": 0,
	"DELETE":    1,
	"ADD":       2,
}

func (x LogEntryType) String() string {
	return proto.EnumName(LogEntryType_name, int32(x))
}
func (LogEntryType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// **********************************************************************************************
// generic oauth abstractions follow
// *********************************************************************************************
type ForeignSystem int32

const (
	ForeignSystem_UNDEFINED_SYSTEM ForeignSystem = 0
	ForeignSystem_GSUITE           ForeignSystem = 1
	ForeignSystem_OFFICE365        ForeignSystem = 2
)

var ForeignSystem_name = map[int32]string{
	0: "UNDEFINED_SYSTEM",
	1: "GSUITE",
	2: "OFFICE365",
}
var ForeignSystem_value = map[string]int32{
	"UNDEFINED_SYSTEM": 0,
	"GSUITE":           1,
	"OFFICE365":        2,
}

func (x ForeignSystem) String() string {
	return proto.EnumName(ForeignSystem_name, int32(x))
}
func (ForeignSystem) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Scope int32

const (
	Scope_UNDEFINED_SCOPE Scope = 0
	Scope_Calendar_Read   Scope = 1
	Scope_Calendar_Write  Scope = 2
	Scope_Email_Read      Scope = 3
	Scope_Email_Write     Scope = 4
	Scope_Documents_Read  Scope = 5
	Scope_Documents_Write Scope = 6
)

var Scope_name = map[int32]string{
	0: "UNDEFINED_SCOPE",
	1: "Calendar_Read",
	2: "Calendar_Write",
	3: "Email_Read",
	4: "Email_Write",
	5: "Documents_Read",
	6: "Documents_Write",
}
var Scope_value = map[string]int32{
	"UNDEFINED_SCOPE": 0,
	"Calendar_Read":   1,
	"Calendar_Write":  2,
	"Email_Read":      3,
	"Email_Write":     4,
	"Documents_Read":  5,
	"Documents_Write": 6,
}

func (x Scope) String() string {
	return proto.EnumName(Scope_name, int32(x))
}
func (Scope) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type TwoCalendar struct {
	SourceID uint64 `protobuf:"varint,1,opt,name=SourceID" json:"SourceID,omitempty"`
	TargetID uint64 `protobuf:"varint,2,opt,name=TargetID" json:"TargetID,omitempty"`
}

func (m *TwoCalendar) Reset()                    { *m = TwoCalendar{} }
func (m *TwoCalendar) String() string            { return proto.CompactTextString(m) }
func (*TwoCalendar) ProtoMessage()               {}
func (*TwoCalendar) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *TwoCalendar) GetSourceID() uint64 {
	if m != nil {
		return m.SourceID
	}
	return 0
}

func (m *TwoCalendar) GetTargetID() uint64 {
	if m != nil {
		return m.TargetID
	}
	return 0
}

type TwoCalendarFull struct {
	Source *Calendar `protobuf:"bytes,1,opt,name=Source" json:"Source,omitempty"`
	Target *Calendar `protobuf:"bytes,2,opt,name=Target" json:"Target,omitempty"`
}

func (m *TwoCalendarFull) Reset()                    { *m = TwoCalendarFull{} }
func (m *TwoCalendarFull) String() string            { return proto.CompactTextString(m) }
func (*TwoCalendarFull) ProtoMessage()               {}
func (*TwoCalendarFull) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TwoCalendarFull) GetSource() *Calendar {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *TwoCalendarFull) GetTarget() *Calendar {
	if m != nil {
		return m.Target
	}
	return nil
}

type SyncList struct {
	Syncs []*TwoCalendarFull `protobuf:"bytes,1,rep,name=Syncs" json:"Syncs,omitempty"`
}

func (m *SyncList) Reset()                    { *m = SyncList{} }
func (m *SyncList) String() string            { return proto.CompactTextString(m) }
func (*SyncList) ProtoMessage()               {}
func (*SyncList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SyncList) GetSyncs() []*TwoCalendarFull {
	if m != nil {
		return m.Syncs
	}
	return nil
}

type SyncOrder struct {
	ID             uint64    `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Source         *Calendar `protobuf:"bytes,2,opt,name=Source" json:"Source,omitempty"`
	Target         *Calendar `protobuf:"bytes,3,opt,name=Target" json:"Target,omitempty"`
	SecretInTarget bool      `protobuf:"varint,4,opt,name=SecretInTarget" json:"SecretInTarget,omitempty"`
}

func (m *SyncOrder) Reset()                    { *m = SyncOrder{} }
func (m *SyncOrder) String() string            { return proto.CompactTextString(m) }
func (*SyncOrder) ProtoMessage()               {}
func (*SyncOrder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SyncOrder) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SyncOrder) GetSource() *Calendar {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *SyncOrder) GetTarget() *Calendar {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *SyncOrder) GetSecretInTarget() bool {
	if m != nil {
		return m.SecretInTarget
	}
	return false
}

type CalendarLog struct {
	ID             uint64       `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Calendar       *SQLCalendar `protobuf:"bytes,3,opt,name=Calendar" json:"Calendar,omitempty"`
	LogEntryType   LogEntryType `protobuf:"varint,4,opt,name=LogEntryType,enum=calendarwrapper.LogEntryType" json:"LogEntryType,omitempty"`
	EventStartTime uint32       `protobuf:"varint,5,opt,name=EventStartTime" json:"EventStartTime,omitempty"`
	EventSubject   string       `protobuf:"bytes,6,opt,name=EventSubject" json:"EventSubject,omitempty"`
	ForeignID      string       `protobuf:"bytes,7,opt,name=ForeignID" json:"ForeignID,omitempty"`
	Occured        uint32       `protobuf:"varint,8,opt,name=Occured" json:"Occured,omitempty"`
}

func (m *CalendarLog) Reset()                    { *m = CalendarLog{} }
func (m *CalendarLog) String() string            { return proto.CompactTextString(m) }
func (*CalendarLog) ProtoMessage()               {}
func (*CalendarLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CalendarLog) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CalendarLog) GetCalendar() *SQLCalendar {
	if m != nil {
		return m.Calendar
	}
	return nil
}

func (m *CalendarLog) GetLogEntryType() LogEntryType {
	if m != nil {
		return m.LogEntryType
	}
	return LogEntryType_UNDEFINED
}

func (m *CalendarLog) GetEventStartTime() uint32 {
	if m != nil {
		return m.EventStartTime
	}
	return 0
}

func (m *CalendarLog) GetEventSubject() string {
	if m != nil {
		return m.EventSubject
	}
	return ""
}

func (m *CalendarLog) GetForeignID() string {
	if m != nil {
		return m.ForeignID
	}
	return ""
}

func (m *CalendarLog) GetOccured() uint32 {
	if m != nil {
		return m.Occured
	}
	return 0
}

type LogEntryList struct {
	Logs []*CalendarLog `protobuf:"bytes,1,rep,name=Logs" json:"Logs,omitempty"`
}

func (m *LogEntryList) Reset()                    { *m = LogEntryList{} }
func (m *LogEntryList) String() string            { return proto.CompactTextString(m) }
func (*LogEntryList) ProtoMessage()               {}
func (*LogEntryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *LogEntryList) GetLogs() []*CalendarLog {
	if m != nil {
		return m.Logs
	}
	return nil
}

type LogRequest struct {
	Calendar      *Calendar `protobuf:"bytes,1,opt,name=Calendar" json:"Calendar,omitempty"`
	IncludeAdd    bool      `protobuf:"varint,2,opt,name=IncludeAdd" json:"IncludeAdd,omitempty"`
	IncludeDelete bool      `protobuf:"varint,3,opt,name=IncludeDelete" json:"IncludeDelete,omitempty"`
}

func (m *LogRequest) Reset()                    { *m = LogRequest{} }
func (m *LogRequest) String() string            { return proto.CompactTextString(m) }
func (*LogRequest) ProtoMessage()               {}
func (*LogRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *LogRequest) GetCalendar() *Calendar {
	if m != nil {
		return m.Calendar
	}
	return nil
}

func (m *LogRequest) GetIncludeAdd() bool {
	if m != nil {
		return m.IncludeAdd
	}
	return false
}

func (m *LogRequest) GetIncludeDelete() bool {
	if m != nil {
		return m.IncludeDelete
	}
	return false
}

type Office365Credentials struct {
	ID                uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Creator           string `protobuf:"bytes,2,opt,name=Creator" json:"Creator,omitempty"`
	Tenant            string `protobuf:"bytes,3,opt,name=Tenant" json:"Tenant,omitempty"`
	ApplicationSecret string `protobuf:"bytes,4,opt,name=ApplicationSecret" json:"ApplicationSecret,omitempty"`
	ClientID          string `protobuf:"bytes,5,opt,name=ClientID" json:"ClientID,omitempty"`
	RedirectURI       string `protobuf:"bytes,6,opt,name=RedirectURI" json:"RedirectURI,omitempty"`
}

func (m *Office365Credentials) Reset()                    { *m = Office365Credentials{} }
func (m *Office365Credentials) String() string            { return proto.CompactTextString(m) }
func (*Office365Credentials) ProtoMessage()               {}
func (*Office365Credentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Office365Credentials) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Office365Credentials) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *Office365Credentials) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *Office365Credentials) GetApplicationSecret() string {
	if m != nil {
		return m.ApplicationSecret
	}
	return ""
}

func (m *Office365Credentials) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Office365Credentials) GetRedirectURI() string {
	if m != nil {
		return m.RedirectURI
	}
	return ""
}

type Office365CalendarRequest struct {
	Office365CalendarID uint64 `protobuf:"varint,1,opt,name=Office365CalendarID" json:"Office365CalendarID,omitempty"`
}

func (m *Office365CalendarRequest) Reset()                    { *m = Office365CalendarRequest{} }
func (m *Office365CalendarRequest) String() string            { return proto.CompactTextString(m) }
func (*Office365CalendarRequest) ProtoMessage()               {}
func (*Office365CalendarRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Office365CalendarRequest) GetOffice365CalendarID() uint64 {
	if m != nil {
		return m.Office365CalendarID
	}
	return 0
}

// user must click on this to authorizerequest
type UserURL struct {
	URL string `protobuf:"bytes,1,opt,name=URL" json:"URL,omitempty"`
}

func (m *UserURL) Reset()                    { *m = UserURL{} }
func (m *UserURL) String() string            { return proto.CompactTextString(m) }
func (*UserURL) ProtoMessage()               {}
func (*UserURL) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *UserURL) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

type MSOfficeState struct {
	ID                   uint64                `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Office365Credentials *Office365Credentials `protobuf:"bytes,2,opt,name=Office365Credentials" json:"Office365Credentials,omitempty"`
	UserID               string                `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	RandomKey            string                `protobuf:"bytes,4,opt,name=RandomKey" json:"RandomKey,omitempty"`
	Created              uint32                `protobuf:"varint,5,opt,name=Created" json:"Created,omitempty"`
}

func (m *MSOfficeState) Reset()                    { *m = MSOfficeState{} }
func (m *MSOfficeState) String() string            { return proto.CompactTextString(m) }
func (*MSOfficeState) ProtoMessage()               {}
func (*MSOfficeState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *MSOfficeState) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *MSOfficeState) GetOffice365Credentials() *Office365Credentials {
	if m != nil {
		return m.Office365Credentials
	}
	return nil
}

func (m *MSOfficeState) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *MSOfficeState) GetRandomKey() string {
	if m != nil {
		return m.RandomKey
	}
	return ""
}

func (m *MSOfficeState) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

//
// once we sent the user through the microsoft authentication hoops we end up with some tokens
// that we need to refresh regularly
type MSOfficeUserCreds struct {
	ID                   uint64                `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Office365Credentials *Office365Credentials `protobuf:"bytes,2,opt,name=Office365Credentials" json:"Office365Credentials,omitempty"`
	UserID               string                `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	Expiry               uint32                `protobuf:"varint,4,opt,name=Expiry" json:"Expiry,omitempty"`
	AccessToken          string                `protobuf:"bytes,5,opt,name=AccessToken" json:"AccessToken,omitempty"`
	RefreshToken         string                `protobuf:"bytes,6,opt,name=RefreshToken" json:"RefreshToken,omitempty"`
}

func (m *MSOfficeUserCreds) Reset()                    { *m = MSOfficeUserCreds{} }
func (m *MSOfficeUserCreds) String() string            { return proto.CompactTextString(m) }
func (*MSOfficeUserCreds) ProtoMessage()               {}
func (*MSOfficeUserCreds) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *MSOfficeUserCreds) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *MSOfficeUserCreds) GetOffice365Credentials() *Office365Credentials {
	if m != nil {
		return m.Office365Credentials
	}
	return nil
}

func (m *MSOfficeUserCreds) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *MSOfficeUserCreds) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *MSOfficeUserCreds) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *MSOfficeUserCreds) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

type MSOfficeCalendar struct {
	ID        uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID    string `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	Name      string `protobuf:"bytes,3,opt,name=Name" json:"Name,omitempty"`
	ForeignID string `protobuf:"bytes,4,opt,name=ForeignID" json:"ForeignID,omitempty"`
}

func (m *MSOfficeCalendar) Reset()                    { *m = MSOfficeCalendar{} }
func (m *MSOfficeCalendar) String() string            { return proto.CompactTextString(m) }
func (*MSOfficeCalendar) ProtoMessage()               {}
func (*MSOfficeCalendar) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *MSOfficeCalendar) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *MSOfficeCalendar) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *MSOfficeCalendar) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MSOfficeCalendar) GetForeignID() string {
	if m != nil {
		return m.ForeignID
	}
	return ""
}

// **********************************************************************************************
// gsuite calendar abstractions follow
// *********************************************************************************************
type GSuiteCalendar struct {
	ID        uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID    string `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	Name      string `protobuf:"bytes,3,opt,name=Name" json:"Name,omitempty"`
	ForeignID string `protobuf:"bytes,4,opt,name=ForeignID" json:"ForeignID,omitempty"`
}

func (m *GSuiteCalendar) Reset()                    { *m = GSuiteCalendar{} }
func (m *GSuiteCalendar) String() string            { return proto.CompactTextString(m) }
func (*GSuiteCalendar) ProtoMessage()               {}
func (*GSuiteCalendar) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *GSuiteCalendar) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GSuiteCalendar) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *GSuiteCalendar) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GSuiteCalendar) GetForeignID() string {
	if m != nil {
		return m.ForeignID
	}
	return ""
}

// details about your app. use console.cloud.google.com to create the app and copy the details in here
type GSuiteApplication struct {
	ID           uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ClientID     string `protobuf:"bytes,2,opt,name=ClientID" json:"ClientID,omitempty"`
	ResponseURL  string `protobuf:"bytes,3,opt,name=ResponseURL" json:"ResponseURL,omitempty"`
	ClientSecret string `protobuf:"bytes,4,opt,name=ClientSecret" json:"ClientSecret,omitempty"`
}

func (m *GSuiteApplication) Reset()                    { *m = GSuiteApplication{} }
func (m *GSuiteApplication) String() string            { return proto.CompactTextString(m) }
func (*GSuiteApplication) ProtoMessage()               {}
func (*GSuiteApplication) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *GSuiteApplication) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GSuiteApplication) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *GSuiteApplication) GetResponseURL() string {
	if m != nil {
		return m.ResponseURL
	}
	return ""
}

func (m *GSuiteApplication) GetClientSecret() string {
	if m != nil {
		return m.ClientSecret
	}
	return ""
}

// this stateid will be returned to use during the auth flow
type GSuiteAuthState struct {
	ID        uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RandomKey string `protobuf:"bytes,2,opt,name=RandomKey" json:"RandomKey,omitempty"`
	UserID    string `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	Created   uint32 `protobuf:"varint,4,opt,name=Created" json:"Created,omitempty"`
}

func (m *GSuiteAuthState) Reset()                    { *m = GSuiteAuthState{} }
func (m *GSuiteAuthState) String() string            { return proto.CompactTextString(m) }
func (*GSuiteAuthState) ProtoMessage()               {}
func (*GSuiteAuthState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GSuiteAuthState) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GSuiteAuthState) GetRandomKey() string {
	if m != nil {
		return m.RandomKey
	}
	return ""
}

func (m *GSuiteAuthState) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *GSuiteAuthState) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

type GSuiteUserCreds struct {
	ID           uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID       string `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	AccessToken  string `protobuf:"bytes,3,opt,name=AccessToken" json:"AccessToken,omitempty"`
	Expiry       uint32 `protobuf:"varint,4,opt,name=Expiry" json:"Expiry,omitempty"`
	RefreshToken string `protobuf:"bytes,5,opt,name=RefreshToken" json:"RefreshToken,omitempty"`
}

func (m *GSuiteUserCreds) Reset()                    { *m = GSuiteUserCreds{} }
func (m *GSuiteUserCreds) String() string            { return proto.CompactTextString(m) }
func (*GSuiteUserCreds) ProtoMessage()               {}
func (*GSuiteUserCreds) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GSuiteUserCreds) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GSuiteUserCreds) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *GSuiteUserCreds) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *GSuiteUserCreds) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *GSuiteUserCreds) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

type AccessRequest struct {
	ForeignSystem ForeignSystem `protobuf:"varint,1,opt,name=ForeignSystem,enum=calendarwrapper.ForeignSystem" json:"ForeignSystem,omitempty"`
	Scopes        []Scope       `protobuf:"varint,2,rep,packed,name=Scopes,enum=calendarwrapper.Scope" json:"Scopes,omitempty"`
}

func (m *AccessRequest) Reset()                    { *m = AccessRequest{} }
func (m *AccessRequest) String() string            { return proto.CompactTextString(m) }
func (*AccessRequest) ProtoMessage()               {}
func (*AccessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *AccessRequest) GetForeignSystem() ForeignSystem {
	if m != nil {
		return m.ForeignSystem
	}
	return ForeignSystem_UNDEFINED_SYSTEM
}

func (m *AccessRequest) GetScopes() []Scope {
	if m != nil {
		return m.Scopes
	}
	return nil
}

type AccessResponse struct {
	Result       string `protobuf:"bytes,1,opt,name=Result" json:"Result,omitempty"`
	NeedUserAuth bool   `protobuf:"varint,2,opt,name=NeedUserAuth" json:"NeedUserAuth,omitempty"`
}

func (m *AccessResponse) Reset()                    { *m = AccessResponse{} }
func (m *AccessResponse) String() string            { return proto.CompactTextString(m) }
func (*AccessResponse) ProtoMessage()               {}
func (*AccessResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *AccessResponse) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *AccessResponse) GetNeedUserAuth() bool {
	if m != nil {
		return m.NeedUserAuth
	}
	return false
}

// the calendar as stored in the database
type SQLCalendar struct {
	ID                 uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID             string `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	Name               string `protobuf:"bytes,3,opt,name=Name" json:"Name,omitempty"`
	MSOfficeCalendarID uint64 `protobuf:"varint,4,opt,name=MSOfficeCalendarID" json:"MSOfficeCalendarID,omitempty"`
	GSuiteCalendarID   uint64 `protobuf:"varint,5,opt,name=GSuiteCalendarID" json:"GSuiteCalendarID,omitempty"`
	LastRefreshed      uint32 `protobuf:"varint,6,opt,name=LastRefreshed" json:"LastRefreshed,omitempty"`
}

func (m *SQLCalendar) Reset()                    { *m = SQLCalendar{} }
func (m *SQLCalendar) String() string            { return proto.CompactTextString(m) }
func (*SQLCalendar) ProtoMessage()               {}
func (*SQLCalendar) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *SQLCalendar) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SQLCalendar) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *SQLCalendar) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SQLCalendar) GetMSOfficeCalendarID() uint64 {
	if m != nil {
		return m.MSOfficeCalendarID
	}
	return 0
}

func (m *SQLCalendar) GetGSuiteCalendarID() uint64 {
	if m != nil {
		return m.GSuiteCalendarID
	}
	return 0
}

func (m *SQLCalendar) GetLastRefreshed() uint32 {
	if m != nil {
		return m.LastRefreshed
	}
	return 0
}

// an event stored in the database
type SQLEvent struct {
	ID            uint64       `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ForeignID     string       `protobuf:"bytes,2,opt,name=ForeignID" json:"ForeignID,omitempty"`
	Calendar      *SQLCalendar `protobuf:"bytes,3,opt,name=Calendar" json:"Calendar,omitempty"`
	Subject       string       `protobuf:"bytes,4,opt,name=Subject" json:"Subject,omitempty"`
	Body          string       `protobuf:"bytes,5,opt,name=Body" json:"Body,omitempty"`
	StartTime     uint32       `protobuf:"varint,6,opt,name=StartTime" json:"StartTime,omitempty"`
	EndTime       uint32       `protobuf:"varint,7,opt,name=EndTime" json:"EndTime,omitempty"`
	LastRefreshed uint32       `protobuf:"varint,8,opt,name=LastRefreshed" json:"LastRefreshed,omitempty"`
}

func (m *SQLEvent) Reset()                    { *m = SQLEvent{} }
func (m *SQLEvent) String() string            { return proto.CompactTextString(m) }
func (*SQLEvent) ProtoMessage()               {}
func (*SQLEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *SQLEvent) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SQLEvent) GetForeignID() string {
	if m != nil {
		return m.ForeignID
	}
	return ""
}

func (m *SQLEvent) GetCalendar() *SQLCalendar {
	if m != nil {
		return m.Calendar
	}
	return nil
}

func (m *SQLEvent) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *SQLEvent) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *SQLEvent) GetStartTime() uint32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *SQLEvent) GetEndTime() uint32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *SQLEvent) GetLastRefreshed() uint32 {
	if m != nil {
		return m.LastRefreshed
	}
	return 0
}

type Calendar struct {
	ID               uint64            `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID           string            `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	Name             string            `protobuf:"bytes,3,opt,name=Name" json:"Name,omitempty"`
	MSOfficeCalendar *MSOfficeCalendar `protobuf:"bytes,4,opt,name=MSOfficeCalendar" json:"MSOfficeCalendar,omitempty"`
	GSuiteCalendar   *GSuiteCalendar   `protobuf:"bytes,5,opt,name=GSuiteCalendar" json:"GSuiteCalendar,omitempty"`
}

func (m *Calendar) Reset()                    { *m = Calendar{} }
func (m *Calendar) String() string            { return proto.CompactTextString(m) }
func (*Calendar) ProtoMessage()               {}
func (*Calendar) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *Calendar) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Calendar) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *Calendar) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Calendar) GetMSOfficeCalendar() *MSOfficeCalendar {
	if m != nil {
		return m.MSOfficeCalendar
	}
	return nil
}

func (m *Calendar) GetGSuiteCalendar() *GSuiteCalendar {
	if m != nil {
		return m.GSuiteCalendar
	}
	return nil
}

type CalendarList struct {
	Calendars []*Calendar `protobuf:"bytes,1,rep,name=Calendars" json:"Calendars,omitempty"`
}

func (m *CalendarList) Reset()                    { *m = CalendarList{} }
func (m *CalendarList) String() string            { return proto.CompactTextString(m) }
func (*CalendarList) ProtoMessage()               {}
func (*CalendarList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *CalendarList) GetCalendars() []*Calendar {
	if m != nil {
		return m.Calendars
	}
	return nil
}

type Attendee struct {
	Email string `protobuf:"bytes,1,opt,name=Email" json:"Email,omitempty"`
}

func (m *Attendee) Reset()                    { *m = Attendee{} }
func (m *Attendee) String() string            { return proto.CompactTextString(m) }
func (*Attendee) ProtoMessage()               {}
func (*Attendee) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *Attendee) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

type Event struct {
	ID        uint64      `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Calendar  *Calendar   `protobuf:"bytes,2,opt,name=Calendar" json:"Calendar,omitempty"`
	Subject   string      `protobuf:"bytes,3,opt,name=Subject" json:"Subject,omitempty"`
	Body      string      `protobuf:"bytes,4,opt,name=Body" json:"Body,omitempty"`
	Start     uint32      `protobuf:"varint,5,opt,name=Start" json:"Start,omitempty"`
	End       uint32      `protobuf:"varint,6,opt,name=End" json:"End,omitempty"`
	Attendees []*Attendee `protobuf:"bytes,7,rep,name=Attendees" json:"Attendees,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *Event) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Event) GetCalendar() *Calendar {
	if m != nil {
		return m.Calendar
	}
	return nil
}

func (m *Event) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Event) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *Event) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Event) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Event) GetAttendees() []*Attendee {
	if m != nil {
		return m.Attendees
	}
	return nil
}

type EventList struct {
	Events []*Event `protobuf:"bytes,1,rep,name=Events" json:"Events,omitempty"`
}

func (m *EventList) Reset()                    { *m = EventList{} }
func (m *EventList) String() string            { return proto.CompactTextString(m) }
func (*EventList) ProtoMessage()               {}
func (*EventList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *EventList) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

type EventRequest struct {
	Calendar  *Calendar `protobuf:"bytes,1,opt,name=Calendar" json:"Calendar,omitempty"`
	NotBefore uint32    `protobuf:"varint,2,opt,name=NotBefore" json:"NotBefore,omitempty"`
	NotAfter  uint32    `protobuf:"varint,3,opt,name=NotAfter" json:"NotAfter,omitempty"`
}

func (m *EventRequest) Reset()                    { *m = EventRequest{} }
func (m *EventRequest) String() string            { return proto.CompactTextString(m) }
func (*EventRequest) ProtoMessage()               {}
func (*EventRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *EventRequest) GetCalendar() *Calendar {
	if m != nil {
		return m.Calendar
	}
	return nil
}

func (m *EventRequest) GetNotBefore() uint32 {
	if m != nil {
		return m.NotBefore
	}
	return 0
}

func (m *EventRequest) GetNotAfter() uint32 {
	if m != nil {
		return m.NotAfter
	}
	return 0
}

func init() {
	proto.RegisterType((*TwoCalendar)(nil), "calendarwrapper.TwoCalendar")
	proto.RegisterType((*TwoCalendarFull)(nil), "calendarwrapper.TwoCalendarFull")
	proto.RegisterType((*SyncList)(nil), "calendarwrapper.SyncList")
	proto.RegisterType((*SyncOrder)(nil), "calendarwrapper.SyncOrder")
	proto.RegisterType((*CalendarLog)(nil), "calendarwrapper.CalendarLog")
	proto.RegisterType((*LogEntryList)(nil), "calendarwrapper.LogEntryList")
	proto.RegisterType((*LogRequest)(nil), "calendarwrapper.LogRequest")
	proto.RegisterType((*Office365Credentials)(nil), "calendarwrapper.Office365Credentials")
	proto.RegisterType((*Office365CalendarRequest)(nil), "calendarwrapper.Office365CalendarRequest")
	proto.RegisterType((*UserURL)(nil), "calendarwrapper.UserURL")
	proto.RegisterType((*MSOfficeState)(nil), "calendarwrapper.MSOfficeState")
	proto.RegisterType((*MSOfficeUserCreds)(nil), "calendarwrapper.MSOfficeUserCreds")
	proto.RegisterType((*MSOfficeCalendar)(nil), "calendarwrapper.MSOfficeCalendar")
	proto.RegisterType((*GSuiteCalendar)(nil), "calendarwrapper.GSuiteCalendar")
	proto.RegisterType((*GSuiteApplication)(nil), "calendarwrapper.GSuiteApplication")
	proto.RegisterType((*GSuiteAuthState)(nil), "calendarwrapper.GSuiteAuthState")
	proto.RegisterType((*GSuiteUserCreds)(nil), "calendarwrapper.GSuiteUserCreds")
	proto.RegisterType((*AccessRequest)(nil), "calendarwrapper.AccessRequest")
	proto.RegisterType((*AccessResponse)(nil), "calendarwrapper.AccessResponse")
	proto.RegisterType((*SQLCalendar)(nil), "calendarwrapper.SQLCalendar")
	proto.RegisterType((*SQLEvent)(nil), "calendarwrapper.SQLEvent")
	proto.RegisterType((*Calendar)(nil), "calendarwrapper.Calendar")
	proto.RegisterType((*CalendarList)(nil), "calendarwrapper.CalendarList")
	proto.RegisterType((*Attendee)(nil), "calendarwrapper.Attendee")
	proto.RegisterType((*Event)(nil), "calendarwrapper.Event")
	proto.RegisterType((*EventList)(nil), "calendarwrapper.EventList")
	proto.RegisterType((*EventRequest)(nil), "calendarwrapper.EventRequest")
	proto.RegisterEnum("calendarwrapper.LogEntryType", LogEntryType_name, LogEntryType_value)
	proto.RegisterEnum("calendarwrapper.ForeignSystem", ForeignSystem_name, ForeignSystem_value)
	proto.RegisterEnum("calendarwrapper.Scope", Scope_name, Scope_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CalendarWrapper service

type CalendarWrapperClient interface {
	// submit stuff to access office365 calendars
	AddOffice365Credentials(ctx context.Context, in *Office365Credentials, opts ...grpc.CallOption) (*Office365Credentials, error)
	// serve websites, in respnose to auth requests
	ServeHTML(ctx context.Context, in *h2gproxy.ServeRequest, opts ...grpc.CallOption) (*h2gproxy.ServeResponse, error)
	// add office365 calendar
	AddOffice365Calendar(ctx context.Context, in *Office365CalendarRequest, opts ...grpc.CallOption) (*UserURL, error)
	// refresh all 'foreign' calendars (not their events though)
	RefreshCalendars(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error)
	// get all calendars known to this service
	GetCalendars(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*CalendarList, error)
	// create event
	DeleteEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*common.Void, error)
	// create event
	CreateEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*common.Void, error)
	// get events for a calendar
	GetEvents(ctx context.Context, in *EventRequest, opts ...grpc.CallOption) (*EventList, error)
	// get an oauth access token for current user
	GetOAuthToken(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*AccessResponse, error)
	// setup a copy task from one calendar to another. Once created the server will automatically copy events from source calendar to target calendar. Events are 'marked' with the source calendar, by adding a string to the subject, e.g. "[msoutlook]" or "[gsuite]". This prevents infinite copy loops if two calendars are copied bi-directionally
	CreateSync(ctx context.Context, in *TwoCalendar, opts ...grpc.CallOption) (*common.Void, error)
	// remove a copy task from one calendar to another
	RemoveSync(ctx context.Context, in *TwoCalendar, opts ...grpc.CallOption) (*common.Void, error)
	// get list of all current sync tasks (for user)
	GetSyncs(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*SyncList, error)
	// show log of stuff that was done recently
	GetLog(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*LogEntryList, error)
}

type calendarWrapperClient struct {
	cc *grpc.ClientConn
}

func NewCalendarWrapperClient(cc *grpc.ClientConn) CalendarWrapperClient {
	return &calendarWrapperClient{cc}
}

func (c *calendarWrapperClient) AddOffice365Credentials(ctx context.Context, in *Office365Credentials, opts ...grpc.CallOption) (*Office365Credentials, error) {
	out := new(Office365Credentials)
	err := grpc.Invoke(ctx, "/calendarwrapper.CalendarWrapper/AddOffice365Credentials", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarWrapperClient) ServeHTML(ctx context.Context, in *h2gproxy.ServeRequest, opts ...grpc.CallOption) (*h2gproxy.ServeResponse, error) {
	out := new(h2gproxy.ServeResponse)
	err := grpc.Invoke(ctx, "/calendarwrapper.CalendarWrapper/ServeHTML", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarWrapperClient) AddOffice365Calendar(ctx context.Context, in *Office365CalendarRequest, opts ...grpc.CallOption) (*UserURL, error) {
	out := new(UserURL)
	err := grpc.Invoke(ctx, "/calendarwrapper.CalendarWrapper/AddOffice365Calendar", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarWrapperClient) RefreshCalendars(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/calendarwrapper.CalendarWrapper/RefreshCalendars", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarWrapperClient) GetCalendars(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*CalendarList, error) {
	out := new(CalendarList)
	err := grpc.Invoke(ctx, "/calendarwrapper.CalendarWrapper/GetCalendars", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarWrapperClient) DeleteEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/calendarwrapper.CalendarWrapper/DeleteEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarWrapperClient) CreateEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/calendarwrapper.CalendarWrapper/CreateEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarWrapperClient) GetEvents(ctx context.Context, in *EventRequest, opts ...grpc.CallOption) (*EventList, error) {
	out := new(EventList)
	err := grpc.Invoke(ctx, "/calendarwrapper.CalendarWrapper/GetEvents", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarWrapperClient) GetOAuthToken(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*AccessResponse, error) {
	out := new(AccessResponse)
	err := grpc.Invoke(ctx, "/calendarwrapper.CalendarWrapper/GetOAuthToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarWrapperClient) CreateSync(ctx context.Context, in *TwoCalendar, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/calendarwrapper.CalendarWrapper/CreateSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarWrapperClient) RemoveSync(ctx context.Context, in *TwoCalendar, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/calendarwrapper.CalendarWrapper/RemoveSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarWrapperClient) GetSyncs(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*SyncList, error) {
	out := new(SyncList)
	err := grpc.Invoke(ctx, "/calendarwrapper.CalendarWrapper/GetSyncs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calendarWrapperClient) GetLog(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*LogEntryList, error) {
	out := new(LogEntryList)
	err := grpc.Invoke(ctx, "/calendarwrapper.CalendarWrapper/GetLog", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CalendarWrapper service

type CalendarWrapperServer interface {
	// submit stuff to access office365 calendars
	AddOffice365Credentials(context.Context, *Office365Credentials) (*Office365Credentials, error)
	// serve websites, in respnose to auth requests
	ServeHTML(context.Context, *h2gproxy.ServeRequest) (*h2gproxy.ServeResponse, error)
	// add office365 calendar
	AddOffice365Calendar(context.Context, *Office365CalendarRequest) (*UserURL, error)
	// refresh all 'foreign' calendars (not their events though)
	RefreshCalendars(context.Context, *common.Void) (*common.Void, error)
	// get all calendars known to this service
	GetCalendars(context.Context, *common.Void) (*CalendarList, error)
	// create event
	DeleteEvent(context.Context, *Event) (*common.Void, error)
	// create event
	CreateEvent(context.Context, *Event) (*common.Void, error)
	// get events for a calendar
	GetEvents(context.Context, *EventRequest) (*EventList, error)
	// get an oauth access token for current user
	GetOAuthToken(context.Context, *AccessRequest) (*AccessResponse, error)
	// setup a copy task from one calendar to another. Once created the server will automatically copy events from source calendar to target calendar. Events are 'marked' with the source calendar, by adding a string to the subject, e.g. "[msoutlook]" or "[gsuite]". This prevents infinite copy loops if two calendars are copied bi-directionally
	CreateSync(context.Context, *TwoCalendar) (*common.Void, error)
	// remove a copy task from one calendar to another
	RemoveSync(context.Context, *TwoCalendar) (*common.Void, error)
	// get list of all current sync tasks (for user)
	GetSyncs(context.Context, *common.Void) (*SyncList, error)
	// show log of stuff that was done recently
	GetLog(context.Context, *LogRequest) (*LogEntryList, error)
}

func RegisterCalendarWrapperServer(s *grpc.Server, srv CalendarWrapperServer) {
	s.RegisterService(&_CalendarWrapper_serviceDesc, srv)
}

func _CalendarWrapper_AddOffice365Credentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Office365Credentials)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarWrapperServer).AddOffice365Credentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calendarwrapper.CalendarWrapper/AddOffice365Credentials",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarWrapperServer).AddOffice365Credentials(ctx, req.(*Office365Credentials))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarWrapper_ServeHTML_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(h2gproxy.ServeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarWrapperServer).ServeHTML(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calendarwrapper.CalendarWrapper/ServeHTML",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarWrapperServer).ServeHTML(ctx, req.(*h2gproxy.ServeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarWrapper_AddOffice365Calendar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Office365CalendarRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarWrapperServer).AddOffice365Calendar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calendarwrapper.CalendarWrapper/AddOffice365Calendar",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarWrapperServer).AddOffice365Calendar(ctx, req.(*Office365CalendarRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarWrapper_RefreshCalendars_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarWrapperServer).RefreshCalendars(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calendarwrapper.CalendarWrapper/RefreshCalendars",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarWrapperServer).RefreshCalendars(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarWrapper_GetCalendars_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarWrapperServer).GetCalendars(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calendarwrapper.CalendarWrapper/GetCalendars",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarWrapperServer).GetCalendars(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarWrapper_DeleteEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarWrapperServer).DeleteEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calendarwrapper.CalendarWrapper/DeleteEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarWrapperServer).DeleteEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarWrapper_CreateEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarWrapperServer).CreateEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calendarwrapper.CalendarWrapper/CreateEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarWrapperServer).CreateEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarWrapper_GetEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarWrapperServer).GetEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calendarwrapper.CalendarWrapper/GetEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarWrapperServer).GetEvents(ctx, req.(*EventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarWrapper_GetOAuthToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarWrapperServer).GetOAuthToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calendarwrapper.CalendarWrapper/GetOAuthToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarWrapperServer).GetOAuthToken(ctx, req.(*AccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarWrapper_CreateSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TwoCalendar)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarWrapperServer).CreateSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calendarwrapper.CalendarWrapper/CreateSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarWrapperServer).CreateSync(ctx, req.(*TwoCalendar))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarWrapper_RemoveSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TwoCalendar)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarWrapperServer).RemoveSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calendarwrapper.CalendarWrapper/RemoveSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarWrapperServer).RemoveSync(ctx, req.(*TwoCalendar))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarWrapper_GetSyncs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarWrapperServer).GetSyncs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calendarwrapper.CalendarWrapper/GetSyncs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarWrapperServer).GetSyncs(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalendarWrapper_GetLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalendarWrapperServer).GetLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calendarwrapper.CalendarWrapper/GetLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalendarWrapperServer).GetLog(ctx, req.(*LogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CalendarWrapper_serviceDesc = grpc.ServiceDesc{
	ServiceName: "calendarwrapper.CalendarWrapper",
	HandlerType: (*CalendarWrapperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddOffice365Credentials",
			Handler:    _CalendarWrapper_AddOffice365Credentials_Handler,
		},
		{
			MethodName: "ServeHTML",
			Handler:    _CalendarWrapper_ServeHTML_Handler,
		},
		{
			MethodName: "AddOffice365Calendar",
			Handler:    _CalendarWrapper_AddOffice365Calendar_Handler,
		},
		{
			MethodName: "RefreshCalendars",
			Handler:    _CalendarWrapper_RefreshCalendars_Handler,
		},
		{
			MethodName: "GetCalendars",
			Handler:    _CalendarWrapper_GetCalendars_Handler,
		},
		{
			MethodName: "DeleteEvent",
			Handler:    _CalendarWrapper_DeleteEvent_Handler,
		},
		{
			MethodName: "CreateEvent",
			Handler:    _CalendarWrapper_CreateEvent_Handler,
		},
		{
			MethodName: "GetEvents",
			Handler:    _CalendarWrapper_GetEvents_Handler,
		},
		{
			MethodName: "GetOAuthToken",
			Handler:    _CalendarWrapper_GetOAuthToken_Handler,
		},
		{
			MethodName: "CreateSync",
			Handler:    _CalendarWrapper_CreateSync_Handler,
		},
		{
			MethodName: "RemoveSync",
			Handler:    _CalendarWrapper_RemoveSync_Handler,
		},
		{
			MethodName: "GetSyncs",
			Handler:    _CalendarWrapper_GetSyncs_Handler,
		},
		{
			MethodName: "GetLog",
			Handler:    _CalendarWrapper_GetLog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.conradwood.net/apis/calendarwrapper/calendarwrapper.proto",
}

func init() {
	proto.RegisterFile("golang.conradwood.net/apis/calendarwrapper/calendarwrapper.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1700 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xd4, 0x58, 0x4f, 0x8f, 0x23, 0x57,
	0x11, 0x4f, 0xfb, 0xbf, 0xcb, 0x63, 0x8f, 0xf7, 0x65, 0x34, 0xeb, 0xf1, 0xce, 0x26, 0xa6, 0x61,
	0xa3, 0x61, 0x85, 0x1c, 0xf0, 0xb0, 0x4b, 0xa4, 0x70, 0xd8, 0xf1, 0xd8, 0x63, 0x2c, 0x3c, 0xe3,
	0xe4, 0xb5, 0x27, 0x11, 0xe2, 0x10, 0x75, 0xba, 0xdf, 0x78, 0x1b, 0xec, 0x6e, 0xa7, 0xfb, 0x79,
	0x37, 0x16, 0x07, 0xd0, 0x4a, 0x39, 0x70, 0xe0, 0x8c, 0x84, 0x38, 0xe5, 0xc8, 0xe7, 0xe0, 0x80,
	0xc4, 0x67, 0x80, 0x1b, 0x1f, 0x81, 0x1b, 0x07, 0xf4, 0xfe, 0xf5, 0x5f, 0x7b, 0xb2, 0xab, 0x11,
	0x48, 0x39, 0xb9, 0xab, 0x5e, 0x55, 0xbd, 0x57, 0x55, 0xbf, 0x2a, 0xd7, 0x7b, 0xf0, 0x6c, 0xee,
	0x2d, 0x4c, 0x77, 0xde, 0xb5, 0x3c, 0xd7, 0x37, 0xed, 0x97, 0x9e, 0x67, 0x77, 0x5d, 0x42, 0xdf,
	0x37, 0x57, 0x4e, 0xf0, 0xbe, 0x65, 0x2e, 0x88, 0x6b, 0x9b, 0xfe, 0x4b, 0xdf, 0x5c, 0xad, 0x88,
	0x9f, 0xa6, 0xbb, 0x2b, 0xdf, 0xa3, 0x1e, 0xda, 0x4f, 0xb1, 0xdb, 0xdd, 0xdb, 0x4c, 0x7a, 0xcb,
	0xa5, 0xe7, 0xca, 0x1f, 0x61, 0xa0, 0xdd, 0xbb, 0x45, 0xfe, 0x79, 0x6f, 0xbe, 0xf2, 0xbd, 0x2f,
	0x37, 0xe1, 0x87, 0xd0, 0xd1, 0x87, 0x50, 0x9b, 0xbd, 0xf4, 0xce, 0xe5, 0xce, 0xa8, 0x0d, 0x15,
	0xc3, 0x5b, 0xfb, 0x16, 0x19, 0x0f, 0x5a, 0x5a, 0x47, 0x3b, 0x29, 0xe0, 0x90, 0x66, 0x6b, 0x33,
	0xd3, 0x9f, 0x13, 0x3a, 0x1e, 0xb4, 0x72, 0x62, 0x4d, 0xd1, 0xfa, 0x4b, 0xd8, 0x8f, 0x99, 0xb9,
	0x58, 0x2f, 0x16, 0xe8, 0x47, 0x50, 0x12, 0xaa, 0xdc, 0x50, 0xad, 0x77, 0xd4, 0x4d, 0xbb, 0xad,
	0xc4, 0xb1, 0x14, 0x64, 0x2a, 0xc2, 0x22, 0xb7, 0x7f, 0xbb, 0x8a, 0x10, 0xd4, 0xfb, 0x50, 0x31,
	0x36, 0xae, 0x35, 0x71, 0x02, 0x8a, 0x9e, 0x42, 0x91, 0x7d, 0x07, 0x2d, 0xad, 0x93, 0x3f, 0xa9,
	0xf5, 0x3a, 0x19, 0xed, 0xd4, 0x11, 0xb1, 0x10, 0xd7, 0xff, 0xa5, 0x41, 0x95, 0x7d, 0x4d, 0x7d,
	0x9b, 0xf8, 0xa8, 0x01, 0xb9, 0xd0, 0xf9, 0xdc, 0x78, 0x80, 0xa6, 0xa1, 0x1f, 0xdf, 0x74, 0xa8,
	0xfe, 0xf1, 0x9f, 0x5e, 0x1d, 0x95, 0xd6, 0x8e, 0x4b, 0x9f, 0xfe, 0xf8, 0xeb, 0x57, 0x47, 0x8d,
	0xe0, 0x8b, 0x85, 0x12, 0xed, 0x3a, 0x76, 0xe8, 0xe5, 0x34, 0xf4, 0x32, 0x7f, 0x47, 0x83, 0xc2,
	0x0c, 0x7a, 0x0f, 0x1a, 0x06, 0xb1, 0x7c, 0x42, 0xc7, 0xae, 0x34, 0x5c, 0xe8, 0x68, 0x27, 0x15,
	0x9c, 0xe2, 0xea, 0x7f, 0xcb, 0x41, 0x4d, 0x99, 0x9e, 0x78, 0xf3, 0x8c, 0xa7, 0x9f, 0x40, 0x45,
	0x2d, 0xcb, 0xa3, 0x1d, 0x67, 0x8e, 0x66, 0x7c, 0x3c, 0x79, 0xcd, 0xd3, 0x85, 0xb6, 0xd0, 0x25,
	0xec, 0x4d, 0xbc, 0xf9, 0xd0, 0xa5, 0xfe, 0x66, 0xb6, 0x59, 0x11, 0x7e, 0xba, 0x46, 0xef, 0x61,
	0xc6, 0x76, 0x5c, 0xa8, 0x0f, 0x91, 0x71, 0x9c, 0x50, 0x67, 0xee, 0x0e, 0x5f, 0x10, 0x97, 0x1a,
	0xd4, 0xf4, 0xe9, 0xcc, 0x59, 0x92, 0x56, 0xb1, 0xa3, 0x9d, 0xd4, 0x71, 0x8a, 0x8b, 0x74, 0xd8,
	0x13, 0x9c, 0xf5, 0xe7, 0xbf, 0x22, 0x16, 0x6d, 0x95, 0x3a, 0xda, 0x49, 0x15, 0x27, 0x78, 0xe8,
	0x18, 0xaa, 0x17, 0x9e, 0x4f, 0x9c, 0xb9, 0x3b, 0x1e, 0xb4, 0xca, 0x5c, 0x20, 0x62, 0xa0, 0x16,
	0x94, 0xa7, 0x96, 0xb5, 0xf6, 0x89, 0xdd, 0xaa, 0xf0, 0x2d, 0x14, 0xa9, 0x3f, 0x8b, 0x5c, 0xe2,
	0xd0, 0xfb, 0x21, 0x14, 0x26, 0xde, 0x5c, 0x21, 0xef, 0x78, 0x67, 0x46, 0x27, 0xde, 0x1c, 0x73,
	0x49, 0xfd, 0xf7, 0x1a, 0x00, 0xa3, 0xc8, 0x17, 0x6b, 0x12, 0x50, 0xf4, 0x24, 0x16, 0xfb, 0x6f,
	0xac, 0x97, 0x28, 0xb4, 0xef, 0x00, 0x8c, 0x5d, 0x6b, 0xb1, 0xb6, 0xc9, 0x99, 0x6d, 0x73, 0x80,
	0x56, 0x70, 0x8c, 0x83, 0xbe, 0x07, 0x75, 0x49, 0x0d, 0xc8, 0x82, 0x50, 0xc2, 0xf3, 0x5a, 0xc1,
	0x49, 0xa6, 0xfe, 0x57, 0x0d, 0x0e, 0xa6, 0x37, 0x37, 0x8e, 0x45, 0x4e, 0x9f, 0x3e, 0x39, 0xf7,
	0x89, 0x4d, 0x5c, 0xea, 0x98, 0x8b, 0x20, 0x83, 0x90, 0x16, 0x94, 0xcf, 0x7d, 0x62, 0x52, 0xcf,
	0xe7, 0x7b, 0x55, 0xb1, 0x22, 0xd1, 0x21, 0x94, 0x66, 0xc4, 0x35, 0x5d, 0x01, 0xea, 0x2a, 0x96,
	0x14, 0xfa, 0x01, 0xdc, 0x3b, 0x5b, 0xad, 0x16, 0x8e, 0x65, 0x52, 0xc7, 0x73, 0x05, 0x20, 0x39,
	0x00, 0xaa, 0x38, 0xbb, 0xc0, 0x5a, 0xcc, 0xf9, 0xc2, 0x21, 0x2e, 0x6b, 0x31, 0x45, 0x2e, 0x14,
	0xd2, 0xa8, 0x03, 0x35, 0x4c, 0x6c, 0xc7, 0x27, 0x16, 0xbd, 0xc6, 0x63, 0x99, 0xcd, 0x38, 0x4b,
	0x77, 0xa0, 0x15, 0x79, 0xa1, 0x62, 0x25, 0xe3, 0x7b, 0x09, 0x6f, 0x67, 0xd6, 0x94, 0x6b, 0xfd,
	0x07, 0x5f, 0xbf, 0x3a, 0xba, 0xef, 0xa9, 0x65, 0x2b, 0x0a, 0x00, 0xc3, 0xf1, 0x36, 0x3d, 0xfd,
	0x01, 0x94, 0xaf, 0x03, 0xe2, 0x5f, 0xe3, 0x09, 0x6a, 0x42, 0xfe, 0x1a, 0x4f, 0xb8, 0xa5, 0x2a,
	0x66, 0x9f, 0xfa, 0x7f, 0x34, 0xa8, 0x5f, 0x1a, 0x42, 0xcd, 0xa0, 0x26, 0x25, 0x99, 0x38, 0xfe,
	0x6e, 0x47, 0xc0, 0x65, 0x8b, 0x79, 0x94, 0x49, 0xfd, 0x36, 0xe1, 0xfe, 0xa3, 0x44, 0xfd, 0xed,
	0x74, 0x60, 0x7b, 0x6a, 0x0f, 0xa1, 0xc4, 0x3c, 0x18, 0x0f, 0x54, 0xc2, 0x04, 0x85, 0xde, 0x83,
	0x2a, 0x36, 0x5d, 0xdb, 0x5b, 0xfe, 0x9c, 0x6c, 0x44, 0xa2, 0xfa, 0x95, 0xbf, 0xbc, 0x3a, 0x2a,
	0x50, 0x7f, 0x4d, 0x70, 0xb4, 0x14, 0x42, 0x81, 0xd8, 0xb2, 0xfc, 0x14, 0xa9, 0xff, 0x39, 0x07,
	0xf7, 0x94, 0xfb, 0xcc, 0x28, 0xdb, 0x35, 0xf8, 0x36, 0x85, 0xe0, 0x10, 0x4a, 0xc3, 0x2f, 0x57,
	0x8e, 0x2f, 0xfc, 0xaf, 0x63, 0x49, 0x31, 0x04, 0x9e, 0x59, 0x16, 0x09, 0x82, 0x99, 0xf7, 0x6b,
	0xe2, 0x4a, 0x80, 0xc6, 0x59, 0xac, 0xe5, 0x60, 0x72, 0xe3, 0x93, 0xe0, 0xb9, 0x10, 0x91, 0x2d,
	0x27, 0xce, 0xd3, 0x5f, 0x40, 0x53, 0x45, 0x27, 0x2c, 0xe3, 0x74, 0x70, 0xa2, 0x93, 0xe5, 0x12,
	0x27, 0x43, 0x50, 0xb8, 0x32, 0x97, 0x44, 0x9e, 0x97, 0x7f, 0xb3, 0x84, 0x45, 0x2d, 0x2c, 0x93,
	0xb0, 0x70, 0x49, 0xa7, 0xd0, 0x18, 0x19, 0x6b, 0x87, 0xfe, 0x7f, 0x77, 0xfd, 0x4a, 0x83, 0x7b,
	0x62, 0xdb, 0x58, 0xb5, 0x67, 0x76, 0x8e, 0xd7, 0x7d, 0x6e, 0x5b, 0xdd, 0x07, 0x2b, 0xcf, 0x0d,
	0x08, 0xab, 0xb3, 0xbc, 0xaa, 0xfb, 0x90, 0xc5, 0xa2, 0x2e, 0xa4, 0x13, 0xed, 0x25, 0xc1, 0xd3,
	0x7f, 0x03, 0xfb, 0xf2, 0x18, 0x6b, 0xfa, 0x7c, 0x7b, 0x51, 0x26, 0x90, 0x9f, 0xdb, 0x8d, 0xfc,
	0x5d, 0xb0, 0x89, 0x55, 0x44, 0x21, 0x59, 0x11, 0x7f, 0xd4, 0xd4, 0xee, 0xbb, 0xeb, 0x61, 0x57,
	0xf0, 0x53, 0xa0, 0xcb, 0x67, 0x41, 0xb7, 0x0b, 0xae, 0x69, 0x30, 0x16, 0xb7, 0x80, 0xf1, 0x2b,
	0x0d, 0xea, 0xc2, 0x96, 0x6a, 0x94, 0x03, 0xa8, 0xcb, 0xec, 0x19, 0x9b, 0x80, 0x92, 0x25, 0x3f,
	0x62, 0xa3, 0xf7, 0x4e, 0xa6, 0x1e, 0x13, 0x52, 0x38, 0xa9, 0x84, 0xba, 0x50, 0x32, 0x2c, 0x6f,
	0x45, 0x58, 0x39, 0xe7, 0x4f, 0x1a, 0xbd, 0xc3, 0xec, 0x20, 0xc1, 0x96, 0xb1, 0x94, 0xd2, 0x27,
	0xd0, 0x50, 0xc7, 0x10, 0x79, 0x65, 0x5e, 0x61, 0x12, 0xac, 0x17, 0x54, 0x76, 0x56, 0x49, 0x31,
	0xaf, 0xae, 0x08, 0xb1, 0x59, 0x74, 0x58, 0x2a, 0xe5, 0x7f, 0x5e, 0x82, 0xa7, 0xff, 0x5d, 0x83,
	0x5a, 0x6c, 0x50, 0xb9, 0x13, 0xd0, 0xbb, 0x80, 0xd2, 0xe5, 0x2a, 0x11, 0x5f, 0xc0, 0x5b, 0x56,
	0xd0, 0x63, 0x68, 0x26, 0xcb, 0x4c, 0xfe, 0x95, 0x15, 0x70, 0x86, 0xcf, 0xfe, 0x9d, 0x27, 0x66,
	0x40, 0x65, 0x46, 0x88, 0xcd, 0xfb, 0x45, 0x1d, 0x27, 0x99, 0xac, 0x9f, 0x56, 0x8c, 0x8f, 0x27,
	0x7c, 0x6e, 0xc9, 0xb8, 0x92, 0x18, 0x60, 0x72, 0xe9, 0x01, 0xe6, 0x7f, 0x35, 0xd1, 0xb5, 0xa0,
	0xac, 0xa6, 0x2a, 0x51, 0x6c, 0x8a, 0x64, 0x21, 0xec, 0x7b, 0xf6, 0x46, 0x82, 0x8d, 0x7f, 0xb3,
	0x33, 0x46, 0xb3, 0x9a, 0x70, 0x31, 0x62, 0x30, 0x5b, 0x43, 0xd7, 0xe6, 0x6b, 0x65, 0x51, 0x36,
	0x92, 0xcc, 0x86, 0xa7, 0xb2, 0x2d, 0x3c, 0xff, 0xd4, 0x22, 0x27, 0xef, 0x94, 0xe9, 0xcb, 0x6c,
	0x63, 0xe6, 0xde, 0xd5, 0x7a, 0xdf, 0xc9, 0x04, 0x2d, 0x2d, 0x88, 0xb3, 0x3d, 0x7d, 0x94, 0xee,
	0xb7, 0x3c, 0x26, 0xb5, 0xde, 0xbb, 0x19, 0x63, 0x49, 0x31, 0x9c, 0x52, 0xd3, 0x47, 0xb0, 0x17,
	0x8e, 0x8f, 0x6c, 0xd6, 0xfc, 0x09, 0x54, 0x15, 0xad, 0x06, 0xce, 0x5b, 0x66, 0xc5, 0x48, 0x56,
	0xef, 0x40, 0xe5, 0x8c, 0x52, 0xe2, 0xda, 0x84, 0xa0, 0x03, 0x28, 0x0e, 0x97, 0xa6, 0xb3, 0x90,
	0xd5, 0x25, 0x08, 0xfd, 0x1f, 0x1a, 0x14, 0xb7, 0xe3, 0x2c, 0x3e, 0x9f, 0xe6, 0x5e, 0x7f, 0x3e,
	0x8d, 0x01, 0x25, 0xbf, 0x1d, 0x28, 0x85, 0x18, 0x50, 0x0e, 0xa0, 0xc8, 0x71, 0x21, 0x27, 0x0a,
	0x41, 0xb0, 0x01, 0x6b, 0xe8, 0xaa, 0xda, 0x60, 0x9f, 0x2c, 0x02, 0xca, 0x91, 0xa0, 0x55, 0xde,
	0x11, 0x01, 0x25, 0x81, 0x23, 0x59, 0xfd, 0x43, 0xa8, 0x72, 0xf7, 0x78, 0x1c, 0xbb, 0x50, 0xe2,
	0x84, 0x0a, 0x62, 0xb6, 0x47, 0xf1, 0x65, 0x2c, 0xa5, 0xf4, 0xdf, 0xca, 0xfb, 0xc4, 0x1d, 0x47,
	0xf6, 0x63, 0xa8, 0x5e, 0x79, 0xb4, 0x4f, 0x6e, 0x3c, 0x5f, 0x5c, 0x29, 0xeb, 0x38, 0x62, 0xb0,
	0x7f, 0xc2, 0x2b, 0x8f, 0x9e, 0xdd, 0x50, 0x22, 0x2a, 0xb6, 0x8e, 0x43, 0xfa, 0x71, 0x2f, 0x79,
	0x8f, 0x42, 0x75, 0xa8, 0x5e, 0x5f, 0x0d, 0x86, 0x17, 0xe3, 0xab, 0xe1, 0xa0, 0xf9, 0x16, 0x02,
	0x28, 0x0d, 0x86, 0x93, 0xe1, 0x6c, 0xd8, 0xd4, 0x50, 0x19, 0xf2, 0x67, 0x83, 0x41, 0x33, 0xf7,
	0xf8, 0x59, 0xaa, 0x9d, 0xa3, 0x03, 0x68, 0x86, 0x4a, 0x9f, 0x19, 0xbf, 0x30, 0x66, 0xc3, 0x4b,
	0xa1, 0x3b, 0x32, 0xae, 0xc7, 0x5c, 0xb7, 0x0e, 0xd5, 0xe9, 0xc5, 0xc5, 0xf8, 0x7c, 0x78, 0xfa,
	0xf4, 0x49, 0x33, 0xf7, 0xf8, 0x0f, 0x1a, 0x14, 0x79, 0x97, 0x46, 0x6f, 0xc3, 0x7e, 0x4c, 0xf5,
	0x7c, 0xfa, 0xd1, 0xb0, 0xf9, 0x16, 0xba, 0x07, 0x75, 0xe5, 0xda, 0x67, 0x98, 0x98, 0x76, 0x53,
	0x43, 0x08, 0x1a, 0x21, 0xeb, 0x53, 0xdf, 0xa1, 0xa4, 0x99, 0x43, 0x0d, 0x00, 0x0e, 0x31, 0x21,
	0x93, 0x47, 0xfb, 0x50, 0x13, 0xb4, 0x10, 0x28, 0x30, 0xa5, 0x81, 0x67, 0xad, 0x97, 0x2c, 0xd4,
	0x42, 0xa8, 0xc8, 0x36, 0x8c, 0x78, 0x42, 0xb0, 0xd4, 0xfb, 0x77, 0x09, 0xf6, 0x95, 0xf9, 0x4f,
	0x45, 0x98, 0xd1, 0x1c, 0xee, 0x9f, 0xd9, 0xf6, 0xd6, 0x21, 0xef, 0xf5, 0x06, 0xc9, 0xf6, 0xeb,
	0x89, 0xa1, 0x9f, 0x42, 0xd5, 0x20, 0xfe, 0x0b, 0xf2, 0xb3, 0xd9, 0xe5, 0x04, 0x1d, 0x76, 0xc3,
	0xc7, 0x14, 0xce, 0x94, 0xc0, 0x68, 0xdf, 0xcf, 0xf0, 0xe5, 0x7f, 0xda, 0x2f, 0xe1, 0x20, 0x71,
	0x4c, 0x05, 0x89, 0xef, 0xdf, 0xb2, 0x79, 0xf2, 0x1e, 0xd3, 0x6e, 0x65, 0x44, 0xd5, 0x3d, 0xa4,
	0x0b, 0x4d, 0xd9, 0x14, 0xc3, 0x8a, 0x47, 0x7b, 0x5d, 0xf9, 0x40, 0xf4, 0x89, 0xe7, 0xd8, 0xed,
	0x04, 0x85, 0x3e, 0x84, 0xbd, 0x11, 0xa1, 0xbb, 0x64, 0x1f, 0xee, 0xbe, 0xc2, 0xb2, 0xda, 0x39,
	0x85, 0x9a, 0xb8, 0x3b, 0x8a, 0x6e, 0xb1, 0xa3, 0x74, 0x52, 0x3b, 0x9e, 0x42, 0x4d, 0x4c, 0x44,
	0x6f, 0xa2, 0x74, 0x01, 0xd5, 0x11, 0xa1, 0xa2, 0x04, 0xd1, 0xc3, 0x1d, 0x25, 0x2a, 0x83, 0xd3,
	0xde, 0xbe, 0xcc, 0x4f, 0xfc, 0x11, 0xd4, 0x47, 0x84, 0x4e, 0xd9, 0x7c, 0x20, 0xc6, 0xa6, 0xec,
	0x44, 0x93, 0x18, 0x84, 0xda, 0xef, 0xee, 0x5c, 0x97, 0xd9, 0xfc, 0x00, 0x40, 0xb8, 0x63, 0x6c,
	0x5c, 0x0b, 0x1d, 0xdf, 0xf6, 0xda, 0x94, 0xf2, 0xe9, 0x03, 0x00, 0x4c, 0x96, 0xde, 0x8b, 0x37,
	0xd7, 0x3c, 0x85, 0xca, 0x88, 0x50, 0xfe, 0x6c, 0x95, 0x4a, 0x58, 0xb6, 0xf7, 0x84, 0xef, 0x62,
	0x03, 0x28, 0x8d, 0x08, 0x9d, 0x78, 0x73, 0xf4, 0x60, 0xdb, 0x9b, 0x8b, 0x72, 0x78, 0xf7, 0x83,
	0x0c, 0xb3, 0xd2, 0x7f, 0x04, 0xdf, 0x75, 0x09, 0x8d, 0x3f, 0x2e, 0x9a, 0x2b, 0x27, 0x48, 0xeb,
	0x7c, 0x5e, 0xe2, 0xef, 0x8a, 0xa7, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x14, 0x53, 0x1c, 0x2e,
	0x10, 0x15, 0x00, 0x00,
}
