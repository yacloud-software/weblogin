// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/objectauth/objectauth.proto
// DO NOT EDIT!

/*
Package objectauth is a generated protocol buffer package.

It is generated from these files:
	golang.conradwood.net/apis/objectauth/objectauth.proto

It has these top-level messages:
	UserToObject
	GroupToObject
	AuthRequest
	AuthResponse
	ObjectType
	ObjectIDList
	GrantUserRequest
	GrantGroupRequest
	PermissionSet
	AccessRightList
*/
package objectauth

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type OBJECTTYPE int32

const (
	OBJECTTYPE_UNDEFINED        OBJECTTYPE = 0
	OBJECTTYPE_Service          OBJECTTYPE = 1
	OBJECTTYPE_Artefact         OBJECTTYPE = 2
	OBJECTTYPE_GitRepository    OBJECTTYPE = 3
	OBJECTTYPE_SingingCatModule OBJECTTYPE = 4
	OBJECTTYPE_Proto            OBJECTTYPE = 5
	OBJECTTYPE_Domain           OBJECTTYPE = 6
)

var OBJECTTYPE_name = map[int32]string{
	0: "UNDEFINED",
	1: "Service",
	2: "Artefact",
	3: "GitRepository",
	4: "SingingCatModule",
	5: "Proto",
	6: "Domain",
}
var OBJECTTYPE_value = map[string]int32{
	"UNDEFINED":        0,
	"Service":          1,
	"Artefact":         2,
	"GitRepository":    3,
	"SingingCatModule": 4,
	"Proto":            5,
	"Domain":           6,
}

func (x OBJECTTYPE) String() string {
	return proto.EnumName(OBJECTTYPE_name, int32(x))
}
func (OBJECTTYPE) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// database user to object acl
type UserToObject struct {
	ID         uint64     `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ObjectType OBJECTTYPE `protobuf:"varint,2,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	ObjectID   uint64     `protobuf:"varint,3,opt,name=ObjectID" json:"ObjectID,omitempty"`
	UserID     string     `protobuf:"bytes,4,opt,name=UserID" json:"UserID,omitempty"`
	Active     bool       `protobuf:"varint,5,opt,name=Active" json:"Active,omitempty"`
	Read       bool       `protobuf:"varint,6,opt,name=Read" json:"Read,omitempty"`
	Write      bool       `protobuf:"varint,7,opt,name=Write" json:"Write,omitempty"`
	Execute    bool       `protobuf:"varint,8,opt,name=Execute" json:"Execute,omitempty"`
	View       bool       `protobuf:"varint,9,opt,name=View" json:"View,omitempty"`
}

func (m *UserToObject) Reset()                    { *m = UserToObject{} }
func (m *UserToObject) String() string            { return proto.CompactTextString(m) }
func (*UserToObject) ProtoMessage()               {}
func (*UserToObject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *UserToObject) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserToObject) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *UserToObject) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *UserToObject) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *UserToObject) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *UserToObject) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *UserToObject) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *UserToObject) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *UserToObject) GetView() bool {
	if m != nil {
		return m.View
	}
	return false
}

// database group to object acl
type GroupToObject struct {
	ID         uint64     `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ObjectType OBJECTTYPE `protobuf:"varint,2,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	ObjectID   uint64     `protobuf:"varint,3,opt,name=ObjectID" json:"ObjectID,omitempty"`
	GroupID    string     `protobuf:"bytes,4,opt,name=GroupID" json:"GroupID,omitempty"`
	Active     bool       `protobuf:"varint,5,opt,name=Active" json:"Active,omitempty"`
	Read       bool       `protobuf:"varint,6,opt,name=Read" json:"Read,omitempty"`
	Write      bool       `protobuf:"varint,7,opt,name=Write" json:"Write,omitempty"`
	Execute    bool       `protobuf:"varint,8,opt,name=Execute" json:"Execute,omitempty"`
	View       bool       `protobuf:"varint,9,opt,name=View" json:"View,omitempty"`
}

func (m *GroupToObject) Reset()                    { *m = GroupToObject{} }
func (m *GroupToObject) String() string            { return proto.CompactTextString(m) }
func (*GroupToObject) ProtoMessage()               {}
func (*GroupToObject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GroupToObject) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GroupToObject) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *GroupToObject) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *GroupToObject) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *GroupToObject) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *GroupToObject) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *GroupToObject) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *GroupToObject) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *GroupToObject) GetView() bool {
	if m != nil {
		return m.View
	}
	return false
}

//
// authenticate against objecttype and id. Using context to identify user
type AuthRequest struct {
	ObjectType OBJECTTYPE `protobuf:"varint,1,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	ObjectID   uint64     `protobuf:"varint,2,opt,name=ObjectID" json:"ObjectID,omitempty"`
}

func (m *AuthRequest) Reset()                    { *m = AuthRequest{} }
func (m *AuthRequest) String() string            { return proto.CompactTextString(m) }
func (*AuthRequest) ProtoMessage()               {}
func (*AuthRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AuthRequest) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *AuthRequest) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

type AuthResponse struct {
	Granted     bool           `protobuf:"varint,1,opt,name=Granted" json:"Granted,omitempty"`
	Permissions *PermissionSet `protobuf:"bytes,2,opt,name=Permissions" json:"Permissions,omitempty"`
}

func (m *AuthResponse) Reset()                    { *m = AuthResponse{} }
func (m *AuthResponse) String() string            { return proto.CompactTextString(m) }
func (*AuthResponse) ProtoMessage()               {}
func (*AuthResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *AuthResponse) GetGranted() bool {
	if m != nil {
		return m.Granted
	}
	return false
}

func (m *AuthResponse) GetPermissions() *PermissionSet {
	if m != nil {
		return m.Permissions
	}
	return nil
}

type ObjectType struct {
	ObjectType OBJECTTYPE `protobuf:"varint,1,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
}

func (m *ObjectType) Reset()                    { *m = ObjectType{} }
func (m *ObjectType) String() string            { return proto.CompactTextString(m) }
func (*ObjectType) ProtoMessage()               {}
func (*ObjectType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ObjectType) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

type ObjectIDList struct {
	ObjectIDs []uint64 `protobuf:"varint,1,rep,packed,name=ObjectIDs" json:"ObjectIDs,omitempty"`
}

func (m *ObjectIDList) Reset()                    { *m = ObjectIDList{} }
func (m *ObjectIDList) String() string            { return proto.CompactTextString(m) }
func (*ObjectIDList) ProtoMessage()               {}
func (*ObjectIDList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ObjectIDList) GetObjectIDs() []uint64 {
	if m != nil {
		return m.ObjectIDs
	}
	return nil
}

type GrantUserRequest struct {
	ObjectType OBJECTTYPE `protobuf:"varint,1,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	ObjectID   uint64     `protobuf:"varint,2,opt,name=ObjectID" json:"ObjectID,omitempty"`
	UserID     string     `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	Read       bool       `protobuf:"varint,4,opt,name=Read" json:"Read,omitempty"`
	Write      bool       `protobuf:"varint,5,opt,name=Write" json:"Write,omitempty"`
	Execute    bool       `protobuf:"varint,6,opt,name=Execute" json:"Execute,omitempty"`
	View       bool       `protobuf:"varint,7,opt,name=View" json:"View,omitempty"`
}

func (m *GrantUserRequest) Reset()                    { *m = GrantUserRequest{} }
func (m *GrantUserRequest) String() string            { return proto.CompactTextString(m) }
func (*GrantUserRequest) ProtoMessage()               {}
func (*GrantUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GrantUserRequest) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *GrantUserRequest) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *GrantUserRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *GrantUserRequest) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *GrantUserRequest) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *GrantUserRequest) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *GrantUserRequest) GetView() bool {
	if m != nil {
		return m.View
	}
	return false
}

type GrantGroupRequest struct {
	ObjectType OBJECTTYPE `protobuf:"varint,1,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	ObjectID   uint64     `protobuf:"varint,2,opt,name=ObjectID" json:"ObjectID,omitempty"`
	GroupID    string     `protobuf:"bytes,3,opt,name=GroupID" json:"GroupID,omitempty"`
	Read       bool       `protobuf:"varint,4,opt,name=Read" json:"Read,omitempty"`
	Write      bool       `protobuf:"varint,5,opt,name=Write" json:"Write,omitempty"`
	Execute    bool       `protobuf:"varint,6,opt,name=Execute" json:"Execute,omitempty"`
	View       bool       `protobuf:"varint,7,opt,name=View" json:"View,omitempty"`
}

func (m *GrantGroupRequest) Reset()                    { *m = GrantGroupRequest{} }
func (m *GrantGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*GrantGroupRequest) ProtoMessage()               {}
func (*GrantGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GrantGroupRequest) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *GrantGroupRequest) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *GrantGroupRequest) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *GrantGroupRequest) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *GrantGroupRequest) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *GrantGroupRequest) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *GrantGroupRequest) GetView() bool {
	if m != nil {
		return m.View
	}
	return false
}

type PermissionSet struct {
	Read    bool `protobuf:"varint,1,opt,name=Read" json:"Read,omitempty"`
	Write   bool `protobuf:"varint,2,opt,name=Write" json:"Write,omitempty"`
	Execute bool `protobuf:"varint,3,opt,name=Execute" json:"Execute,omitempty"`
	View    bool `protobuf:"varint,4,opt,name=View" json:"View,omitempty"`
}

func (m *PermissionSet) Reset()                    { *m = PermissionSet{} }
func (m *PermissionSet) String() string            { return proto.CompactTextString(m) }
func (*PermissionSet) ProtoMessage()               {}
func (*PermissionSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *PermissionSet) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *PermissionSet) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *PermissionSet) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *PermissionSet) GetView() bool {
	if m != nil {
		return m.View
	}
	return false
}

type AccessRightList struct {
	ObjectType OBJECTTYPE `protobuf:"varint,1,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	ObjectID   uint64     `protobuf:"varint,2,opt,name=ObjectID" json:"ObjectID,omitempty"`
	// GroupID to PermissionSet
	GroupPermissions map[string]*PermissionSet `protobuf:"bytes,3,rep,name=GroupPermissions" json:"GroupPermissions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// UserID to Permission Set
	UserPermissions map[string]*PermissionSet `protobuf:"bytes,4,rep,name=UserPermissions" json:"UserPermissions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AccessRightList) Reset()                    { *m = AccessRightList{} }
func (m *AccessRightList) String() string            { return proto.CompactTextString(m) }
func (*AccessRightList) ProtoMessage()               {}
func (*AccessRightList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *AccessRightList) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *AccessRightList) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *AccessRightList) GetGroupPermissions() map[string]*PermissionSet {
	if m != nil {
		return m.GroupPermissions
	}
	return nil
}

func (m *AccessRightList) GetUserPermissions() map[string]*PermissionSet {
	if m != nil {
		return m.UserPermissions
	}
	return nil
}

func init() {
	proto.RegisterType((*UserToObject)(nil), "objectauth.UserToObject")
	proto.RegisterType((*GroupToObject)(nil), "objectauth.GroupToObject")
	proto.RegisterType((*AuthRequest)(nil), "objectauth.AuthRequest")
	proto.RegisterType((*AuthResponse)(nil), "objectauth.AuthResponse")
	proto.RegisterType((*ObjectType)(nil), "objectauth.ObjectType")
	proto.RegisterType((*ObjectIDList)(nil), "objectauth.ObjectIDList")
	proto.RegisterType((*GrantUserRequest)(nil), "objectauth.GrantUserRequest")
	proto.RegisterType((*GrantGroupRequest)(nil), "objectauth.GrantGroupRequest")
	proto.RegisterType((*PermissionSet)(nil), "objectauth.PermissionSet")
	proto.RegisterType((*AccessRightList)(nil), "objectauth.AccessRightList")
	proto.RegisterEnum("objectauth.OBJECTTYPE", OBJECTTYPE_name, OBJECTTYPE_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ObjectAuthService service

type ObjectAuthServiceClient interface {
	// ask if user has access to an object
	AskObjectAccess(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	// get all objects (of a given type) the current user has access to
	AvailableObjects(ctx context.Context, in *ObjectType, opts ...grpc.CallOption) (*ObjectIDList, error)
	// grant access to a user. Currently this call is privileged for root users only
	GrantToUser(ctx context.Context, in *GrantUserRequest, opts ...grpc.CallOption) (*common.Void, error)
	// grant access to a group. Currently this call is privileged for root users only
	GrantToGroup(ctx context.Context, in *GrantGroupRequest, opts ...grpc.CallOption) (*common.Void, error)
	// grant access to me. Currently this call is privileged for root users only. Leave the userid field to 0
	GrantToMe(ctx context.Context, in *GrantUserRequest, opts ...grpc.CallOption) (*common.Void, error)
	// get acessrights for a specific object
	GetRights(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AccessRightList, error)
}

type objectAuthServiceClient struct {
	cc *grpc.ClientConn
}

func NewObjectAuthServiceClient(cc *grpc.ClientConn) ObjectAuthServiceClient {
	return &objectAuthServiceClient{cc}
}

func (c *objectAuthServiceClient) AskObjectAccess(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/AskObjectAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) AvailableObjects(ctx context.Context, in *ObjectType, opts ...grpc.CallOption) (*ObjectIDList, error) {
	out := new(ObjectIDList)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/AvailableObjects", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) GrantToUser(ctx context.Context, in *GrantUserRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/GrantToUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) GrantToGroup(ctx context.Context, in *GrantGroupRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/GrantToGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) GrantToMe(ctx context.Context, in *GrantUserRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/GrantToMe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) GetRights(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AccessRightList, error) {
	out := new(AccessRightList)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/GetRights", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ObjectAuthService service

type ObjectAuthServiceServer interface {
	// ask if user has access to an object
	AskObjectAccess(context.Context, *AuthRequest) (*AuthResponse, error)
	// get all objects (of a given type) the current user has access to
	AvailableObjects(context.Context, *ObjectType) (*ObjectIDList, error)
	// grant access to a user. Currently this call is privileged for root users only
	GrantToUser(context.Context, *GrantUserRequest) (*common.Void, error)
	// grant access to a group. Currently this call is privileged for root users only
	GrantToGroup(context.Context, *GrantGroupRequest) (*common.Void, error)
	// grant access to me. Currently this call is privileged for root users only. Leave the userid field to 0
	GrantToMe(context.Context, *GrantUserRequest) (*common.Void, error)
	// get acessrights for a specific object
	GetRights(context.Context, *AuthRequest) (*AccessRightList, error)
}

func RegisterObjectAuthServiceServer(s *grpc.Server, srv ObjectAuthServiceServer) {
	s.RegisterService(&_ObjectAuthService_serviceDesc, srv)
}

func _ObjectAuthService_AskObjectAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).AskObjectAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/AskObjectAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).AskObjectAccess(ctx, req.(*AuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_AvailableObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectType)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).AvailableObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/AvailableObjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).AvailableObjects(ctx, req.(*ObjectType))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_GrantToUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).GrantToUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/GrantToUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).GrantToUser(ctx, req.(*GrantUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_GrantToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).GrantToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/GrantToGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).GrantToGroup(ctx, req.(*GrantGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_GrantToMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).GrantToMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/GrantToMe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).GrantToMe(ctx, req.(*GrantUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_GetRights_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).GetRights(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/GetRights",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).GetRights(ctx, req.(*AuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ObjectAuthService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "objectauth.ObjectAuthService",
	HandlerType: (*ObjectAuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AskObjectAccess",
			Handler:    _ObjectAuthService_AskObjectAccess_Handler,
		},
		{
			MethodName: "AvailableObjects",
			Handler:    _ObjectAuthService_AvailableObjects_Handler,
		},
		{
			MethodName: "GrantToUser",
			Handler:    _ObjectAuthService_GrantToUser_Handler,
		},
		{
			MethodName: "GrantToGroup",
			Handler:    _ObjectAuthService_GrantToGroup_Handler,
		},
		{
			MethodName: "GrantToMe",
			Handler:    _ObjectAuthService_GrantToMe_Handler,
		},
		{
			MethodName: "GetRights",
			Handler:    _ObjectAuthService_GetRights_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.conradwood.net/apis/objectauth/objectauth.proto",
}

func init() {
	proto.RegisterFile("golang.conradwood.net/apis/objectauth/objectauth.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 792 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x56, 0x6d, 0x6f, 0xda, 0x48,
	0x10, 0x3e, 0x63, 0xf3, 0xe2, 0x01, 0x12, 0x67, 0x95, 0xcb, 0xf9, 0xb8, 0x9c, 0x84, 0x90, 0x4e,
	0x87, 0x4e, 0x27, 0xd2, 0x52, 0x29, 0x7d, 0xfb, 0x44, 0x62, 0x1a, 0x51, 0x35, 0x2f, 0x72, 0x48,
	0xaa, 0x56, 0x4a, 0x25, 0xc7, 0x6c, 0xc9, 0x36, 0xe0, 0xa5, 0xde, 0x35, 0x29, 0xbf, 0xa3, 0xff,
	0xad, 0x52, 0x3f, 0xf5, 0x7f, 0x54, 0xaa, 0x54, 0x79, 0x6d, 0x60, 0x4d, 0x08, 0x55, 0xa3, 0x92,
	0x4f, 0xde, 0x99, 0xdd, 0x79, 0x9e, 0x99, 0xdd, 0x67, 0xc7, 0x0b, 0xdb, 0x5d, 0xda, 0x73, 0xbc,
	0x6e, 0xcd, 0xa5, 0x9e, 0xef, 0x74, 0xae, 0x28, 0xed, 0xd4, 0x3c, 0xcc, 0xb7, 0x9c, 0x01, 0x61,
	0x5b, 0xf4, 0xfc, 0x1d, 0x76, 0xb9, 0x13, 0xf0, 0x0b, 0x69, 0x58, 0x1b, 0xf8, 0x94, 0x53, 0x04,
	0x53, 0x4f, 0xa9, 0xb6, 0x00, 0xc3, 0xa5, 0xfd, 0x3e, 0xf5, 0xe2, 0x4f, 0x14, 0x5b, 0xf9, 0xaa,
	0x40, 0xe1, 0x84, 0x61, 0xbf, 0x4d, 0x0f, 0x05, 0x08, 0x5a, 0x81, 0x54, 0xcb, 0x32, 0x95, 0xb2,
	0x52, 0xd5, 0xec, 0x54, 0xcb, 0x42, 0xdb, 0x00, 0xd1, 0x4c, 0x7b, 0x34, 0xc0, 0x66, 0xaa, 0xac,
	0x54, 0x57, 0xea, 0x1b, 0x35, 0x29, 0x87, 0xc3, 0x9d, 0xe7, 0xcd, 0xdd, 0x76, 0xfb, 0xd5, 0x51,
	0xd3, 0x96, 0x56, 0xa2, 0x12, 0xe4, 0x22, 0xab, 0x65, 0x99, 0xaa, 0x40, 0x9b, 0xd8, 0x68, 0x03,
	0x32, 0x21, 0x67, 0xcb, 0x32, 0xb5, 0xb2, 0x52, 0xd5, 0xed, 0xd8, 0x0a, 0xfd, 0x0d, 0x97, 0x93,
	0x21, 0x36, 0xd3, 0x65, 0xa5, 0x9a, 0xb3, 0x63, 0x0b, 0x21, 0xd0, 0x6c, 0xec, 0x74, 0xcc, 0x8c,
	0xf0, 0x8a, 0x31, 0x5a, 0x87, 0xf4, 0x4b, 0x9f, 0x70, 0x6c, 0x66, 0x85, 0x33, 0x32, 0x90, 0x09,
	0xd9, 0xe6, 0x07, 0xec, 0x06, 0x1c, 0x9b, 0x39, 0xe1, 0x1f, 0x9b, 0x21, 0xc6, 0x29, 0xc1, 0x57,
	0xa6, 0x1e, 0x61, 0x84, 0xe3, 0xca, 0x37, 0x05, 0x8a, 0x7b, 0x3e, 0x0d, 0x06, 0x77, 0x5a, 0xbd,
	0x09, 0x59, 0x41, 0x3a, 0x29, 0x7f, 0x6c, 0xde, 0x79, 0xfd, 0x0e, 0xe4, 0x1b, 0x01, 0xbf, 0xb0,
	0xf1, 0xfb, 0x00, 0x33, 0x3e, 0x53, 0xac, 0x72, 0xab, 0x62, 0x53, 0xc9, 0x62, 0x2b, 0x18, 0x0a,
	0x11, 0x05, 0x1b, 0x50, 0x8f, 0xe1, 0xa8, 0x78, 0xc7, 0xe3, 0xb8, 0x23, 0x08, 0x72, 0xf6, 0xd8,
	0x44, 0x4f, 0x21, 0x7f, 0x84, 0xfd, 0x3e, 0x61, 0x8c, 0x50, 0x8f, 0x09, 0xa0, 0x7c, 0xfd, 0x4f,
	0x99, 0x7e, 0x3a, 0x7d, 0x8c, 0xb9, 0x2d, 0xaf, 0xae, 0x58, 0x72, 0xea, 0xb7, 0x2d, 0xa4, 0xf2,
	0x3f, 0x14, 0xc6, 0x89, 0xbf, 0x20, 0x8c, 0xa3, 0x4d, 0xd0, 0xc7, 0x36, 0x33, 0x95, 0xb2, 0x5a,
	0xd5, 0xec, 0xa9, 0xa3, 0xf2, 0x49, 0x01, 0x43, 0x24, 0x1f, 0xaa, 0x77, 0x89, 0x7b, 0x28, 0x5d,
	0x17, 0x35, 0x71, 0x5d, 0xc6, 0xb2, 0xd0, 0xe6, 0xc9, 0x22, 0x7d, 0x83, 0x2c, 0x32, 0xf3, 0x65,
	0x91, 0x95, 0x64, 0xf1, 0x59, 0x81, 0x35, 0x51, 0x98, 0xd0, 0xe5, 0x32, 0x2b, 0x93, 0xae, 0x82,
	0x9a, 0xbc, 0x0a, 0xcb, 0xaa, 0xad, 0x0b, 0xc5, 0x84, 0x8c, 0x26, 0x44, 0xca, 0x3c, 0xa2, 0xd4,
	0x0d, 0x44, 0xea, 0x7c, 0x22, 0x4d, 0x22, 0xfa, 0xa2, 0xc2, 0x6a, 0xc3, 0x75, 0x31, 0x63, 0x36,
	0xe9, 0x5e, 0x70, 0xa1, 0xa7, 0x65, 0x6c, 0xe1, 0x59, 0x28, 0x42, 0x1a, 0x0c, 0xe4, 0xbb, 0xa3,
	0x96, 0xd5, 0x6a, 0xbe, 0x7e, 0x5f, 0x46, 0x9e, 0x49, 0xa5, 0x36, 0x1b, 0xd3, 0xf4, 0xb8, 0x3f,
	0xb2, 0xaf, 0x41, 0xa1, 0xd7, 0xb0, 0x1a, 0xaa, 0x4d, 0x46, 0xd7, 0x04, 0xfa, 0xbd, 0x45, 0xe8,
	0x33, 0x21, 0x11, 0xf8, 0x2c, 0x50, 0xe9, 0x0d, 0xfc, 0x3e, 0x37, 0x0d, 0x64, 0x80, 0x7a, 0x89,
	0x47, 0x62, 0x83, 0x74, 0x3b, 0x1c, 0xa2, 0x2d, 0x48, 0x0f, 0x9d, 0x5e, 0x80, 0x7f, 0xdc, 0x16,
	0xa2, 0x75, 0x4f, 0x52, 0x8f, 0x94, 0xd2, 0x19, 0xac, 0xcf, 0x4b, 0xe4, 0x17, 0xc1, 0xff, 0x37,
	0x04, 0x98, 0x9e, 0x17, 0x2a, 0x82, 0x7e, 0x72, 0x60, 0x35, 0x9f, 0xb5, 0x0e, 0x9a, 0x96, 0xf1,
	0x1b, 0xca, 0x43, 0xf6, 0x18, 0xfb, 0x43, 0xe2, 0x62, 0x43, 0x41, 0x05, 0xc8, 0x35, 0x7c, 0x8e,
	0xdf, 0x3a, 0x2e, 0x37, 0x52, 0x68, 0x0d, 0x8a, 0x7b, 0x84, 0xdb, 0x78, 0x40, 0x19, 0xe1, 0xd4,
	0x1f, 0x19, 0x2a, 0x5a, 0x07, 0xe3, 0x98, 0x78, 0x5d, 0xe2, 0x75, 0x77, 0x1d, 0xbe, 0x4f, 0x3b,
	0x41, 0x0f, 0x1b, 0x1a, 0xd2, 0x21, 0x7d, 0x14, 0xfe, 0xa4, 0x8d, 0x34, 0x02, 0xc8, 0x58, 0xb4,
	0xef, 0x10, 0xcf, 0xc8, 0xd4, 0x3f, 0xaa, 0xb0, 0x16, 0x1d, 0x7f, 0xd8, 0x59, 0x63, 0x16, 0x64,
	0xc1, 0x6a, 0x83, 0x5d, 0xc6, 0x7e, 0x71, 0x1c, 0xe8, 0x8f, 0xc4, 0x11, 0x4d, 0x1b, 0x7d, 0xc9,
	0xbc, 0x3e, 0x11, 0xb7, 0x67, 0x0b, 0x8c, 0xc6, 0xd0, 0x21, 0x3d, 0xe7, 0xbc, 0x87, 0x23, 0x2c,
	0x86, 0x92, 0x0a, 0x9d, 0xa8, 0x32, 0x89, 0x92, 0xe8, 0x9b, 0x8f, 0x21, 0x2f, 0xfa, 0x47, 0x9b,
	0x86, 0xfb, 0x8f, 0x36, 0xe5, 0x85, 0xb3, 0x1d, 0xb3, 0x54, 0xa8, 0xc5, 0x0f, 0x92, 0x53, 0x4a,
	0xc2, 0xbf, 0x40, 0x21, 0x0e, 0x15, 0xd2, 0x40, 0x7f, 0x5f, 0x8b, 0x95, 0x9b, 0xd2, 0x4c, 0xf0,
	0x43, 0xd0, 0xe3, 0xe0, 0x7d, 0xfc, 0x53, 0xac, 0x0d, 0xd0, 0xf7, 0x30, 0x17, 0xfa, 0x5d, 0xb0,
	0x6d, 0x7f, 0x2d, 0x90, 0xfc, 0xce, 0xbf, 0xf0, 0x8f, 0x87, 0xb9, 0xfc, 0xee, 0x8a, 0x5f, 0x62,
	0xe1, 0xd3, 0x4b, 0x0a, 0x3c, 0xcf, 0x88, 0x87, 0xd7, 0x83, 0xef, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x82, 0x4a, 0xef, 0x4c, 0xee, 0x09, 0x00, 0x00,
}
