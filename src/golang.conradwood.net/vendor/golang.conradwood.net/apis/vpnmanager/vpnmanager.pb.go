// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/vpnmanager/vpnmanager.proto
// DO NOT EDIT!

/*
Package vpnmanager is a generated protocol buffer package.

It is generated from these files:
	golang.conradwood.net/apis/vpnmanager/vpnmanager.proto

It has these top-level messages:
	DeviceDef
	LanDefinition
	TargetDefinition
	VPNDefinition
	ByIPRequest
	IPSecPSKVPN
	OpenVPN
	CreateRequest
	CreateResponse
	GetVpnRequest
	StatusUpdateRequest
	EmptyResponse
	VPNListResponse
	StatusUpdate
	GenericStatusRequest
	UpDownStatusRequest
*/
package vpnmanager

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// enum stuff is a really bad idea ;(
// instead should have different messages and rpcs
// for different types of VPNs
type VPNType int32

const (
	VPNType_IPSEC1   VPNType = 0
	VPNType_OPENVPN1 VPNType = 1
)

var VPNType_name = map[int32]string{
	0: "IPSEC1",
	1: "OPENVPN1",
}
var VPNType_value = map[string]int32{
	"IPSEC1":   0,
	"OPENVPN1": 1,
}

func (x VPNType) String() string {
	return proto.EnumName(VPNType_name, int32(x))
}
func (VPNType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type VPNPurpose int32

const (
	VPNPurpose_SITE        VPNPurpose = 0
	VPNPurpose_DCTODC      VPNPurpose = 1
	VPNPurpose_ROADWARRIOR VPNPurpose = 2
)

var VPNPurpose_name = map[int32]string{
	0: "SITE",
	1: "DCTODC",
	2: "ROADWARRIOR",
}
var VPNPurpose_value = map[string]int32{
	"SITE":        0,
	"DCTODC":      1,
	"ROADWARRIOR": 2,
}

func (x VPNPurpose) String() string {
	return proto.EnumName(VPNPurpose_name, int32(x))
}
func (VPNPurpose) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type DeviceAccess int32

const (
	DeviceAccess_HUBAPI            DeviceAccess = 0
	DeviceAccess_ROADWARRIOR_STAFF DeviceAccess = 1
	DeviceAccess_ROADWARRIOR_TECH  DeviceAccess = 2
)

var DeviceAccess_name = map[int32]string{
	0: "HUBAPI",
	1: "ROADWARRIOR_STAFF",
	2: "ROADWARRIOR_TECH",
}
var DeviceAccess_value = map[string]int32{
	"HUBAPI":            0,
	"ROADWARRIOR_STAFF": 1,
	"ROADWARRIOR_TECH":  2,
}

func (x DeviceAccess) String() string {
	return proto.EnumName(DeviceAccess_name, int32(x))
}
func (DeviceAccess) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// a device at the remote end
// for example: A Gateway or a enduser laptop
type DeviceDef struct {
	IPV4 string `protobuf:"bytes,1,opt,name=IPV4" json:"IPV4,omitempty"`
}

func (m *DeviceDef) Reset()                    { *m = DeviceDef{} }
func (m *DeviceDef) String() string            { return proto.CompactTextString(m) }
func (*DeviceDef) ProtoMessage()               {}
func (*DeviceDef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DeviceDef) GetIPV4() string {
	if m != nil {
		return m.IPV4
	}
	return ""
}

// each lan can have multiple devices
// the remote network we connect to
type LanDefinition struct {
	Device          []*DeviceDef `protobuf:"bytes,1,rep,name=Device" json:"Device,omitempty"`
	NetworkMaskSize uint32       `protobuf:"varint,3,opt,name=NetworkMaskSize" json:"NetworkMaskSize,omitempty"`
	Network         string       `protobuf:"bytes,4,opt,name=Network" json:"Network,omitempty"`
}

func (m *LanDefinition) Reset()                    { *m = LanDefinition{} }
func (m *LanDefinition) String() string            { return proto.CompactTextString(m) }
func (*LanDefinition) ProtoMessage()               {}
func (*LanDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *LanDefinition) GetDevice() []*DeviceDef {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *LanDefinition) GetNetworkMaskSize() uint32 {
	if m != nil {
		return m.NetworkMaskSize
	}
	return 0
}

func (m *LanDefinition) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

// each target can have multiple lans
type TargetDefinition struct {
	ID                uint32           `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Lans              []*LanDefinition `protobuf:"bytes,2,rep,name=Lans" json:"Lans,omitempty"`
	DeviceAccessFlags uint64           `protobuf:"varint,3,opt,name=DeviceAccessFlags" json:"DeviceAccessFlags,omitempty"`
}

func (m *TargetDefinition) Reset()                    { *m = TargetDefinition{} }
func (m *TargetDefinition) String() string            { return proto.CompactTextString(m) }
func (*TargetDefinition) ProtoMessage()               {}
func (*TargetDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TargetDefinition) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TargetDefinition) GetLans() []*LanDefinition {
	if m != nil {
		return m.Lans
	}
	return nil
}

func (m *TargetDefinition) GetDeviceAccessFlags() uint64 {
	if m != nil {
		return m.DeviceAccessFlags
	}
	return 0
}

// each VPN has got exactly one target
// multiple VPNs can have the same target
// old-style IPSec need fixed IP-Addresses :(
type VPNDefinition struct {
	VPNID       uint64            `protobuf:"varint,1,opt,name=VPNID" json:"VPNID,omitempty"`
	Comment     string            `protobuf:"bytes,2,opt,name=Comment" json:"Comment,omitempty"`
	Type        VPNType           `protobuf:"varint,3,opt,name=Type,enum=vpnmanager.VPNType" json:"Type,omitempty"`
	Purpose     VPNPurpose        `protobuf:"varint,4,opt,name=Purpose,enum=vpnmanager.VPNPurpose" json:"Purpose,omitempty"`
	Version     uint32            `protobuf:"varint,6,opt,name=Version" json:"Version,omitempty"`
	UserID      string            `protobuf:"bytes,7,opt,name=UserID" json:"UserID,omitempty"`
	AlwaysOn    bool              `protobuf:"varint,8,opt,name=AlwaysOn" json:"AlwaysOn,omitempty"`
	Targetdef   *TargetDefinition `protobuf:"bytes,9,opt,name=Targetdef" json:"Targetdef,omitempty"`
	IPSecPSKVPN *IPSecPSKVPN      `protobuf:"bytes,10,opt,name=IPSecPSKVPN" json:"IPSecPSKVPN,omitempty"`
	OpenVPN     *OpenVPN          `protobuf:"bytes,11,opt,name=OpenVPN" json:"OpenVPN,omitempty"`
	LocalIPs    []string          `protobuf:"bytes,12,rep,name=LocalIPs" json:"LocalIPs,omitempty"`
	AlertsOn    bool              `protobuf:"varint,13,opt,name=AlertsOn" json:"AlertsOn,omitempty"`
}

func (m *VPNDefinition) Reset()                    { *m = VPNDefinition{} }
func (m *VPNDefinition) String() string            { return proto.CompactTextString(m) }
func (*VPNDefinition) ProtoMessage()               {}
func (*VPNDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *VPNDefinition) GetVPNID() uint64 {
	if m != nil {
		return m.VPNID
	}
	return 0
}

func (m *VPNDefinition) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *VPNDefinition) GetType() VPNType {
	if m != nil {
		return m.Type
	}
	return VPNType_IPSEC1
}

func (m *VPNDefinition) GetPurpose() VPNPurpose {
	if m != nil {
		return m.Purpose
	}
	return VPNPurpose_SITE
}

func (m *VPNDefinition) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *VPNDefinition) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *VPNDefinition) GetAlwaysOn() bool {
	if m != nil {
		return m.AlwaysOn
	}
	return false
}

func (m *VPNDefinition) GetTargetdef() *TargetDefinition {
	if m != nil {
		return m.Targetdef
	}
	return nil
}

func (m *VPNDefinition) GetIPSecPSKVPN() *IPSecPSKVPN {
	if m != nil {
		return m.IPSecPSKVPN
	}
	return nil
}

func (m *VPNDefinition) GetOpenVPN() *OpenVPN {
	if m != nil {
		return m.OpenVPN
	}
	return nil
}

func (m *VPNDefinition) GetLocalIPs() []string {
	if m != nil {
		return m.LocalIPs
	}
	return nil
}

func (m *VPNDefinition) GetAlertsOn() bool {
	if m != nil {
		return m.AlertsOn
	}
	return false
}

type ByIPRequest struct {
	IP string `protobuf:"bytes,1,opt,name=IP" json:"IP,omitempty"`
}

func (m *ByIPRequest) Reset()                    { *m = ByIPRequest{} }
func (m *ByIPRequest) String() string            { return proto.CompactTextString(m) }
func (*ByIPRequest) ProtoMessage()               {}
func (*ByIPRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ByIPRequest) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

// **************************************************
// Begin of VPN specific settings
// different types of VPN require different settings
// **************************************************
type IPSecPSKVPN struct {
	RemoteIP string `protobuf:"bytes,1,opt,name=RemoteIP" json:"RemoteIP,omitempty"`
	// line) - empty for modern vpns
	RemoteID string `protobuf:"bytes,2,opt,name=RemoteID" json:"RemoteID,omitempty"`
	// us. E.g. Draytek seem to take this from one of the wan
	// interfaces? (unclear which one)
	Password string `protobuf:"bytes,3,opt,name=Password" json:"Password,omitempty"`
}

func (m *IPSecPSKVPN) Reset()                    { *m = IPSecPSKVPN{} }
func (m *IPSecPSKVPN) String() string            { return proto.CompactTextString(m) }
func (*IPSecPSKVPN) ProtoMessage()               {}
func (*IPSecPSKVPN) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *IPSecPSKVPN) GetRemoteIP() string {
	if m != nil {
		return m.RemoteIP
	}
	return ""
}

func (m *IPSecPSKVPN) GetRemoteID() string {
	if m != nil {
		return m.RemoteID
	}
	return ""
}

func (m *IPSecPSKVPN) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type OpenVPN struct {
	Suffix string `protobuf:"bytes,1,opt,name=suffix" json:"suffix,omitempty"`
}

func (m *OpenVPN) Reset()                    { *m = OpenVPN{} }
func (m *OpenVPN) String() string            { return proto.CompactTextString(m) }
func (*OpenVPN) ProtoMessage()               {}
func (*OpenVPN) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *OpenVPN) GetSuffix() string {
	if m != nil {
		return m.Suffix
	}
	return ""
}

type CreateRequest struct {
	VPN *VPNDefinition `protobuf:"bytes,1,opt,name=VPN" json:"VPN,omitempty"`
}

func (m *CreateRequest) Reset()                    { *m = CreateRequest{} }
func (m *CreateRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateRequest) ProtoMessage()               {}
func (*CreateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CreateRequest) GetVPN() *VPNDefinition {
	if m != nil {
		return m.VPN
	}
	return nil
}

type CreateResponse struct {
	// returns the same VPNdefinition, including the newly assigned VPNID
	VPN *VPNDefinition `protobuf:"bytes,1,opt,name=VPN" json:"VPN,omitempty"`
}

func (m *CreateResponse) Reset()                    { *m = CreateResponse{} }
func (m *CreateResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateResponse) ProtoMessage()               {}
func (*CreateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CreateResponse) GetVPN() *VPNDefinition {
	if m != nil {
		return m.VPN
	}
	return nil
}

type GetVpnRequest struct {
}

func (m *GetVpnRequest) Reset()                    { *m = GetVpnRequest{} }
func (m *GetVpnRequest) String() string            { return proto.CompactTextString(m) }
func (*GetVpnRequest) ProtoMessage()               {}
func (*GetVpnRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type StatusUpdateRequest struct {
}

func (m *StatusUpdateRequest) Reset()                    { *m = StatusUpdateRequest{} }
func (m *StatusUpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*StatusUpdateRequest) ProtoMessage()               {}
func (*StatusUpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type EmptyResponse struct {
}

func (m *EmptyResponse) Reset()                    { *m = EmptyResponse{} }
func (m *EmptyResponse) String() string            { return proto.CompactTextString(m) }
func (*EmptyResponse) ProtoMessage()               {}
func (*EmptyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type VPNListResponse struct {
	VPNs []*VPNDefinition `protobuf:"bytes,1,rep,name=VPNs" json:"VPNs,omitempty"`
}

func (m *VPNListResponse) Reset()                    { *m = VPNListResponse{} }
func (m *VPNListResponse) String() string            { return proto.CompactTextString(m) }
func (*VPNListResponse) ProtoMessage()               {}
func (*VPNListResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *VPNListResponse) GetVPNs() []*VPNDefinition {
	if m != nil {
		return m.VPNs
	}
	return nil
}

type StatusUpdate struct {
	VPNID        uint64 `protobuf:"varint,1,opt,name=VPNID" json:"VPNID,omitempty"`
	Success      bool   `protobuf:"varint,2,opt,name=Success" json:"Success,omitempty"`
	Errormessage string `protobuf:"bytes,3,opt,name=Errormessage" json:"Errormessage,omitempty"`
}

func (m *StatusUpdate) Reset()                    { *m = StatusUpdate{} }
func (m *StatusUpdate) String() string            { return proto.CompactTextString(m) }
func (*StatusUpdate) ProtoMessage()               {}
func (*StatusUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *StatusUpdate) GetVPNID() uint64 {
	if m != nil {
		return m.VPNID
	}
	return 0
}

func (m *StatusUpdate) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *StatusUpdate) GetErrormessage() string {
	if m != nil {
		return m.Errormessage
	}
	return ""
}

type GenericStatusRequest struct {
	Success      bool   `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
	Errormessage string `protobuf:"bytes,2,opt,name=Errormessage" json:"Errormessage,omitempty"`
}

func (m *GenericStatusRequest) Reset()                    { *m = GenericStatusRequest{} }
func (m *GenericStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*GenericStatusRequest) ProtoMessage()               {}
func (*GenericStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *GenericStatusRequest) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *GenericStatusRequest) GetErrormessage() string {
	if m != nil {
		return m.Errormessage
	}
	return ""
}

type UpDownStatusRequest struct {
	VPNID    uint64 `protobuf:"varint,1,opt,name=VPNID" json:"VPNID,omitempty"`
	Up       bool   `protobuf:"varint,2,opt,name=Up" json:"Up,omitempty"`
	Instance string `protobuf:"bytes,3,opt,name=Instance" json:"Instance,omitempty"`
}

func (m *UpDownStatusRequest) Reset()                    { *m = UpDownStatusRequest{} }
func (m *UpDownStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*UpDownStatusRequest) ProtoMessage()               {}
func (*UpDownStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *UpDownStatusRequest) GetVPNID() uint64 {
	if m != nil {
		return m.VPNID
	}
	return 0
}

func (m *UpDownStatusRequest) GetUp() bool {
	if m != nil {
		return m.Up
	}
	return false
}

func (m *UpDownStatusRequest) GetInstance() string {
	if m != nil {
		return m.Instance
	}
	return ""
}

func init() {
	proto.RegisterType((*DeviceDef)(nil), "vpnmanager.DeviceDef")
	proto.RegisterType((*LanDefinition)(nil), "vpnmanager.LanDefinition")
	proto.RegisterType((*TargetDefinition)(nil), "vpnmanager.TargetDefinition")
	proto.RegisterType((*VPNDefinition)(nil), "vpnmanager.VPNDefinition")
	proto.RegisterType((*ByIPRequest)(nil), "vpnmanager.ByIPRequest")
	proto.RegisterType((*IPSecPSKVPN)(nil), "vpnmanager.IPSecPSKVPN")
	proto.RegisterType((*OpenVPN)(nil), "vpnmanager.OpenVPN")
	proto.RegisterType((*CreateRequest)(nil), "vpnmanager.CreateRequest")
	proto.RegisterType((*CreateResponse)(nil), "vpnmanager.CreateResponse")
	proto.RegisterType((*GetVpnRequest)(nil), "vpnmanager.GetVpnRequest")
	proto.RegisterType((*StatusUpdateRequest)(nil), "vpnmanager.StatusUpdateRequest")
	proto.RegisterType((*EmptyResponse)(nil), "vpnmanager.EmptyResponse")
	proto.RegisterType((*VPNListResponse)(nil), "vpnmanager.VPNListResponse")
	proto.RegisterType((*StatusUpdate)(nil), "vpnmanager.StatusUpdate")
	proto.RegisterType((*GenericStatusRequest)(nil), "vpnmanager.GenericStatusRequest")
	proto.RegisterType((*UpDownStatusRequest)(nil), "vpnmanager.UpDownStatusRequest")
	proto.RegisterEnum("vpnmanager.VPNType", VPNType_name, VPNType_value)
	proto.RegisterEnum("vpnmanager.VPNPurpose", VPNPurpose_name, VPNPurpose_value)
	proto.RegisterEnum("vpnmanager.DeviceAccess", DeviceAccess_name, DeviceAccess_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for VpnManager service

type VpnManagerClient interface {
	CreateVPN(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)
	GetAllVPNs(ctx context.Context, in *GetVpnRequest, opts ...grpc.CallOption) (*VPNListResponse, error)
	// called if the VPN is 'ready to go'
	ConfigApplyStatus(ctx context.Context, in *StatusUpdateRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// called if the VPN configuration was syntactically ok
	ConfigAcceptStatus(ctx context.Context, in *StatusUpdateRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// something bad happened and the entire new config could not
	// be applied (not VPN specific)
	// this *might* have an impact on individual VPNs, but we only report
	// this error  if we're in a really bad state and cannot determine
	// details of which vpns were affected. (e.g. disk i/o errors)
	// vice versa, if we apply all vpns correctly, this is called
	// with a successmessage.
	// This means, whilst there is a "general" error reported, the
	// individual status of a VPN is likely to be inaccurate/misleading.
	// only once the general error is cleared, is the status accurate
	// of individual VPNs.
	GeneralStatusUpdate(ctx context.Context, in *GenericStatusRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	VPNUpDownStatus(ctx context.Context, in *UpDownStatusRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	GetVPNByIP(ctx context.Context, in *ByIPRequest, opts ...grpc.CallOption) (*VPNListResponse, error)
}

type vpnManagerClient struct {
	cc *grpc.ClientConn
}

func NewVpnManagerClient(cc *grpc.ClientConn) VpnManagerClient {
	return &vpnManagerClient{cc}
}

func (c *vpnManagerClient) CreateVPN(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) {
	out := new(CreateResponse)
	err := grpc.Invoke(ctx, "/vpnmanager.VpnManager/CreateVPN", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnManagerClient) GetAllVPNs(ctx context.Context, in *GetVpnRequest, opts ...grpc.CallOption) (*VPNListResponse, error) {
	out := new(VPNListResponse)
	err := grpc.Invoke(ctx, "/vpnmanager.VpnManager/GetAllVPNs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnManagerClient) ConfigApplyStatus(ctx context.Context, in *StatusUpdateRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/vpnmanager.VpnManager/ConfigApplyStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnManagerClient) ConfigAcceptStatus(ctx context.Context, in *StatusUpdateRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/vpnmanager.VpnManager/ConfigAcceptStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnManagerClient) GeneralStatusUpdate(ctx context.Context, in *GenericStatusRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/vpnmanager.VpnManager/GeneralStatusUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnManagerClient) VPNUpDownStatus(ctx context.Context, in *UpDownStatusRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/vpnmanager.VpnManager/VPNUpDownStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnManagerClient) GetVPNByIP(ctx context.Context, in *ByIPRequest, opts ...grpc.CallOption) (*VPNListResponse, error) {
	out := new(VPNListResponse)
	err := grpc.Invoke(ctx, "/vpnmanager.VpnManager/GetVPNByIP", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VpnManager service

type VpnManagerServer interface {
	CreateVPN(context.Context, *CreateRequest) (*CreateResponse, error)
	GetAllVPNs(context.Context, *GetVpnRequest) (*VPNListResponse, error)
	// called if the VPN is 'ready to go'
	ConfigApplyStatus(context.Context, *StatusUpdateRequest) (*EmptyResponse, error)
	// called if the VPN configuration was syntactically ok
	ConfigAcceptStatus(context.Context, *StatusUpdateRequest) (*EmptyResponse, error)
	// something bad happened and the entire new config could not
	// be applied (not VPN specific)
	// this *might* have an impact on individual VPNs, but we only report
	// this error  if we're in a really bad state and cannot determine
	// details of which vpns were affected. (e.g. disk i/o errors)
	// vice versa, if we apply all vpns correctly, this is called
	// with a successmessage.
	// This means, whilst there is a "general" error reported, the
	// individual status of a VPN is likely to be inaccurate/misleading.
	// only once the general error is cleared, is the status accurate
	// of individual VPNs.
	GeneralStatusUpdate(context.Context, *GenericStatusRequest) (*EmptyResponse, error)
	VPNUpDownStatus(context.Context, *UpDownStatusRequest) (*EmptyResponse, error)
	GetVPNByIP(context.Context, *ByIPRequest) (*VPNListResponse, error)
}

func RegisterVpnManagerServer(s *grpc.Server, srv VpnManagerServer) {
	s.RegisterService(&_VpnManager_serviceDesc, srv)
}

func _VpnManager_CreateVPN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnManagerServer).CreateVPN(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpnmanager.VpnManager/CreateVPN",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnManagerServer).CreateVPN(ctx, req.(*CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnManager_GetAllVPNs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVpnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnManagerServer).GetAllVPNs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpnmanager.VpnManager/GetAllVPNs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnManagerServer).GetAllVPNs(ctx, req.(*GetVpnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnManager_ConfigApplyStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnManagerServer).ConfigApplyStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpnmanager.VpnManager/ConfigApplyStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnManagerServer).ConfigApplyStatus(ctx, req.(*StatusUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnManager_ConfigAcceptStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnManagerServer).ConfigAcceptStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpnmanager.VpnManager/ConfigAcceptStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnManagerServer).ConfigAcceptStatus(ctx, req.(*StatusUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnManager_GeneralStatusUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnManagerServer).GeneralStatusUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpnmanager.VpnManager/GeneralStatusUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnManagerServer).GeneralStatusUpdate(ctx, req.(*GenericStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnManager_VPNUpDownStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpDownStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnManagerServer).VPNUpDownStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpnmanager.VpnManager/VPNUpDownStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnManagerServer).VPNUpDownStatus(ctx, req.(*UpDownStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnManager_GetVPNByIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnManagerServer).GetVPNByIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpnmanager.VpnManager/GetVPNByIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnManagerServer).GetVPNByIP(ctx, req.(*ByIPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VpnManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vpnmanager.VpnManager",
	HandlerType: (*VpnManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVPN",
			Handler:    _VpnManager_CreateVPN_Handler,
		},
		{
			MethodName: "GetAllVPNs",
			Handler:    _VpnManager_GetAllVPNs_Handler,
		},
		{
			MethodName: "ConfigApplyStatus",
			Handler:    _VpnManager_ConfigApplyStatus_Handler,
		},
		{
			MethodName: "ConfigAcceptStatus",
			Handler:    _VpnManager_ConfigAcceptStatus_Handler,
		},
		{
			MethodName: "GeneralStatusUpdate",
			Handler:    _VpnManager_GeneralStatusUpdate_Handler,
		},
		{
			MethodName: "VPNUpDownStatus",
			Handler:    _VpnManager_VPNUpDownStatus_Handler,
		},
		{
			MethodName: "GetVPNByIP",
			Handler:    _VpnManager_GetVPNByIP_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.conradwood.net/apis/vpnmanager/vpnmanager.proto",
}

func init() {
	proto.RegisterFile("golang.conradwood.net/apis/vpnmanager/vpnmanager.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 963 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x56, 0x6f, 0x6f, 0xe3, 0xc4,
	0x13, 0xae, 0xdd, 0xfc, 0xda, 0x64, 0xd2, 0xb4, 0xee, 0xb6, 0xbd, 0x9f, 0xaf, 0x80, 0x2e, 0x18,
	0xa1, 0x8b, 0x0a, 0xed, 0x71, 0x39, 0x84, 0x04, 0x02, 0x89, 0x24, 0x4e, 0x7b, 0x16, 0xad, 0xb3,
	0xda, 0x24, 0xbe, 0x97, 0xc8, 0xe7, 0x6c, 0x22, 0xeb, 0x92, 0xb5, 0xf1, 0x3a, 0x17, 0xc2, 0x1b,
	0x24, 0x3e, 0x09, 0x9f, 0x86, 0xcf, 0x85, 0xbc, 0xfe, 0xd3, 0x75, 0x2e, 0x44, 0x42, 0xe2, 0x9d,
	0x67, 0xe7, 0x99, 0x99, 0x67, 0x66, 0x1e, 0xaf, 0x16, 0xbe, 0x99, 0x05, 0x73, 0x97, 0xcd, 0x6e,
	0xbc, 0x80, 0x45, 0xee, 0x64, 0x15, 0x04, 0x93, 0x1b, 0x46, 0xe3, 0x17, 0x6e, 0xe8, 0xf3, 0x17,
	0xef, 0x43, 0xb6, 0x70, 0x99, 0x3b, 0xa3, 0x91, 0xf4, 0x79, 0x13, 0x46, 0x41, 0x1c, 0x20, 0x78,
	0x3c, 0x31, 0x9e, 0x41, 0xcd, 0xa4, 0xef, 0x7d, 0x8f, 0x9a, 0x74, 0x8a, 0x10, 0x54, 0x2c, 0xec,
	0x7c, 0xad, 0x2b, 0x4d, 0xa5, 0x55, 0x23, 0xe2, 0xdb, 0xf8, 0x43, 0x81, 0xc6, 0xbd, 0xcb, 0x4c,
	0x3a, 0xf5, 0x99, 0x1f, 0xfb, 0x01, 0x43, 0xd7, 0x70, 0x90, 0x86, 0xe8, 0x4a, 0x73, 0xbf, 0x55,
	0x6f, 0x5f, 0xdc, 0x48, 0x15, 0x8a, 0x64, 0x24, 0x03, 0xa1, 0x16, 0x9c, 0xd8, 0x34, 0x5e, 0x05,
	0xd1, 0xbb, 0x07, 0x97, 0xbf, 0x1b, 0xfa, 0xbf, 0x51, 0x7d, 0xbf, 0xa9, 0xb4, 0x1a, 0x64, 0xf3,
	0x18, 0xe9, 0x70, 0x98, 0x1d, 0xe9, 0x15, 0xc1, 0x20, 0x37, 0x8d, 0xdf, 0x41, 0x1b, 0xb9, 0xd1,
	0x8c, 0xc6, 0x12, 0x8d, 0x63, 0x50, 0x2d, 0x53, 0x50, 0x6d, 0x10, 0xd5, 0x32, 0xd1, 0x35, 0x54,
	0xee, 0x5d, 0xc6, 0x75, 0x55, 0x90, 0x7a, 0x2a, 0x93, 0x2a, 0xf1, 0x27, 0x02, 0x86, 0xbe, 0x84,
	0xd3, 0x94, 0x60, 0xc7, 0xf3, 0x28, 0xe7, 0xb7, 0x73, 0x77, 0xc6, 0x05, 0xb1, 0x0a, 0xf9, 0xd0,
	0x61, 0xfc, 0xb5, 0x0f, 0x0d, 0x07, 0xdb, 0x52, 0xf9, 0x73, 0xf8, 0x9f, 0x83, 0xed, 0x8c, 0x41,
	0x85, 0xa4, 0x46, 0xd2, 0x42, 0x2f, 0x58, 0x2c, 0x28, 0x8b, 0x75, 0x35, 0x6d, 0x21, 0x33, 0xd1,
	0x73, 0xa8, 0x8c, 0xd6, 0x61, 0xda, 0xfb, 0x71, 0xfb, 0x4c, 0xa6, 0xe7, 0x60, 0x3b, 0x71, 0x11,
	0x01, 0x40, 0x5f, 0xc1, 0x21, 0x5e, 0x46, 0x61, 0xc0, 0xa9, 0x98, 0xc2, 0x71, 0xfb, 0xc9, 0x06,
	0x36, 0xf3, 0x92, 0x1c, 0x96, 0x14, 0x75, 0x68, 0xc4, 0xfd, 0x80, 0xe9, 0x07, 0x62, 0x1c, 0xb9,
	0x89, 0x9e, 0xc0, 0xc1, 0x98, 0xd3, 0xc8, 0x32, 0xf5, 0x43, 0xc1, 0x26, 0xb3, 0xd0, 0x25, 0x54,
	0x3b, 0xf3, 0x95, 0xbb, 0xe6, 0x03, 0xa6, 0x57, 0x9b, 0x4a, 0xab, 0x4a, 0x0a, 0x1b, 0x7d, 0x07,
	0xb5, 0x74, 0xd6, 0x13, 0x3a, 0xd5, 0x6b, 0x4d, 0xa5, 0x55, 0x6f, 0x7f, 0x2c, 0x33, 0xd8, 0x5c,
	0x04, 0x79, 0x84, 0xa3, 0x6f, 0xa1, 0x6e, 0xe1, 0x21, 0xf5, 0xf0, 0xf0, 0x27, 0x07, 0xdb, 0x3a,
	0x88, 0xe8, 0xff, 0xcb, 0xd1, 0x92, 0x9b, 0xc8, 0x58, 0x74, 0x0d, 0x87, 0x83, 0x90, 0xb2, 0x24,
	0xac, 0x2e, 0xc2, 0x4a, 0x23, 0xca, 0x5c, 0x24, 0xc7, 0x24, 0x1d, 0xdc, 0x07, 0x9e, 0x3b, 0xb7,
	0x30, 0xd7, 0x8f, 0x9a, 0xfb, 0xad, 0x1a, 0x29, 0xec, 0xb4, 0x3b, 0x1a, 0xc5, 0x49, 0x77, 0x8d,
	0xbc, 0xbb, 0xd4, 0x36, 0x3e, 0x81, 0x7a, 0x77, 0x6d, 0x61, 0x42, 0x7f, 0x59, 0x52, 0x1e, 0x0b,
	0x11, 0xe1, 0x4c, 0xef, 0xaa, 0x85, 0x0d, 0xb7, 0xd4, 0x40, 0x92, 0x89, 0xd0, 0x45, 0x10, 0xd3,
	0x02, 0x54, 0xd8, 0x92, 0xcf, 0xcc, 0x76, 0x5d, 0xd8, 0x89, 0x0f, 0xbb, 0x9c, 0xaf, 0x82, 0x68,
	0x22, 0x16, 0x5e, 0x23, 0x85, 0x6d, 0x7c, 0x5a, 0x34, 0x9a, 0xac, 0x87, 0x2f, 0xa7, 0x53, 0xff,
	0xd7, 0x2c, 0x79, 0x66, 0x19, 0xdf, 0x43, 0xa3, 0x17, 0x51, 0x37, 0xa6, 0x39, 0xcd, 0x2f, 0x60,
	0x3f, 0x19, 0x8c, 0x22, 0x06, 0xf3, 0x74, 0x43, 0x0f, 0xd2, 0x2a, 0x12, 0x94, 0xf1, 0x03, 0x1c,
	0xe7, 0xd1, 0x3c, 0x0c, 0x18, 0xa7, 0xff, 0x2e, 0xfc, 0x04, 0x1a, 0x77, 0x34, 0x76, 0x42, 0x96,
	0x15, 0x37, 0x2e, 0xe0, 0x6c, 0x18, 0xbb, 0xf1, 0x92, 0x8f, 0xc3, 0xc9, 0x23, 0xa7, 0x04, 0xd7,
	0x5f, 0x84, 0xf1, 0x3a, 0xaf, 0x62, 0xfc, 0x08, 0x27, 0x0e, 0xb6, 0xef, 0x7d, 0x1e, 0x17, 0x85,
	0xaf, 0xa1, 0xe2, 0x60, 0x9b, 0x67, 0x17, 0xc5, 0x8e, 0xca, 0x02, 0x66, 0xbc, 0x85, 0x23, 0xb9,
	0xd2, 0x3f, 0xff, 0x63, 0xc3, 0xa5, 0xf8, 0x37, 0xc5, 0xdc, 0xab, 0x24, 0x37, 0x91, 0x01, 0x47,
	0xfd, 0x28, 0x0a, 0xa2, 0x05, 0xe5, 0xdc, 0x9d, 0xd1, 0x6c, 0xf4, 0xa5, 0x33, 0x63, 0x04, 0xe7,
	0x77, 0x94, 0xd1, 0xc8, 0xf7, 0xd2, 0x52, 0xf9, 0x88, 0xa5, 0xac, 0xca, 0xee, 0xac, 0xea, 0x96,
	0xac, 0x6f, 0xe0, 0x6c, 0x1c, 0x9a, 0xc1, 0x8a, 0x95, 0x93, 0x6e, 0x6f, 0xe0, 0x18, 0xd4, 0x71,
	0x98, 0x71, 0x57, 0xc7, 0x61, 0xa2, 0x16, 0x8b, 0xf1, 0xd8, 0x65, 0x5e, 0x4e, 0xb9, 0xb0, 0xaf,
	0x3e, 0x83, 0xc3, 0xec, 0x7a, 0x40, 0x00, 0x07, 0x16, 0x1e, 0xf6, 0x7b, 0x2f, 0xb5, 0x3d, 0x74,
	0x04, 0xd5, 0x01, 0xee, 0xdb, 0x0e, 0xb6, 0x5f, 0x6a, 0xca, 0xd5, 0x2b, 0x80, 0xc7, 0x7b, 0x01,
	0x55, 0xa1, 0x32, 0xb4, 0x46, 0x7d, 0x6d, 0x2f, 0x89, 0x30, 0x7b, 0xa3, 0x81, 0xd9, 0xd3, 0x14,
	0x74, 0x02, 0x75, 0x32, 0xe8, 0x98, 0x6f, 0x3a, 0x84, 0x58, 0x03, 0xa2, 0xa9, 0x57, 0x77, 0x70,
	0x24, 0xdf, 0x73, 0x09, 0xf8, 0xf5, 0xb8, 0xdb, 0xc1, 0x96, 0xb6, 0x87, 0x2e, 0xe0, 0x54, 0x02,
	0xff, 0x3c, 0x1c, 0x75, 0x6e, 0x6f, 0x35, 0x05, 0x9d, 0x83, 0x26, 0x1f, 0x8f, 0xfa, 0xbd, 0xd7,
	0x9a, 0xda, 0xfe, 0xb3, 0x02, 0xe0, 0x84, 0xec, 0x21, 0x5d, 0x2c, 0xea, 0x42, 0x2d, 0x95, 0x5f,
	0xa2, 0xf0, 0xd2, 0xca, 0x4b, 0x9a, 0xbe, 0xbc, 0xdc, 0xe6, 0xca, 0x74, 0x63, 0x02, 0xdc, 0xd1,
	0xb8, 0x33, 0x9f, 0x27, 0xb2, 0x28, 0x27, 0x29, 0x69, 0xf3, 0xf2, 0xa3, 0x0d, 0x49, 0x95, 0xd4,
	0x37, 0x80, 0xd3, 0x5e, 0xc0, 0xa6, 0xfe, 0xac, 0x13, 0x86, 0xf3, 0x75, 0xba, 0x19, 0xf4, 0x4c,
	0x8e, 0xd8, 0xa2, 0xeb, 0xcb, 0x52, 0xb5, 0x92, 0xc2, 0x11, 0x06, 0x94, 0x25, 0xf4, 0x3c, 0x1a,
	0xc6, 0xff, 0x41, 0x46, 0x02, 0x67, 0x42, 0x8d, 0xee, 0xbc, 0x24, 0xfc, 0x66, 0xb9, 0xe3, 0x0f,
	0xe5, 0xba, 0x2b, 0xe7, 0x83, 0xf8, 0x0f, 0x65, 0x39, 0x96, 0x29, 0x6e, 0x11, 0xea, 0xae, 0x74,
	0x5d, 0xb1, 0x0b, 0x07, 0xdb, 0xc9, 0xbd, 0x89, 0x4a, 0x97, 0xb9, 0x74, 0x93, 0xee, 0xdc, 0x44,
	0xf7, 0x39, 0x7c, 0xce, 0x68, 0x2c, 0x3f, 0x54, 0xb2, 0xa7, 0x4b, 0xf2, 0x56, 0x91, 0x02, 0xdf,
	0x1e, 0x88, 0x17, 0xca, 0xab, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xfe, 0xf9, 0xb1, 0x46, 0xdb,
	0x08, 0x00, 0x00,
}
