// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/auth/auth-db.proto
// DO NOT EDIT!

/*
Package auth is a generated protocol buffer package.

It is generated from these files:
	golang.conradwood.net/apis/auth/auth-db.proto
	golang.conradwood.net/apis/auth/auth.proto
	golang.conradwood.net/apis/auth/authmgr.proto
	golang.conradwood.net/apis/auth/authsvc.proto

It has these top-level messages:
	UserDetail
	UserTokens
	GroupDB
	EmailVerifyPins
	SudoStatus
	AuthResponse
	SignedAuthResponse
	SignedUser
	User
	LinkGroupOrganisation
	Organisation
	Group
	GroupList
	AddToGroupRequest
	RemoveFromGroupRequest
	ListGroupRequest
	UserListResponse
	UpdatePasswordRequest
	ElevateAccessRequest
	ForceUpdatePasswordRequest
	EditAnyUserRequest
	EditSelfRequest
	CreateGroup
	CreateGroupRequest
	CreateGroupResponse
	GetGroupRequest
	GetGroupResponse
	GroupDescriptionRequest
	CreateServiceRequest
	NewService
	ResetRequest
	ExpireTokenRequest
	VerifyEmailRequest
	VerifyEmailResponse
	GetTokenRequest
	TokenResponse
	UserList
	ByAbbrevRequest
	RemoteStoreRequest
	RemoteUserRequest
	RemoteUser
	RemoteUserDetail
	SudoRequest
	TokenCompromisedRequest
	NewToken
	VerifyRequest
	VerifyResponse
	ByIDRequest
	VerifyPasswordResponse
	CreateUserRequest
	ByEmailRequest
	UserEmailAddressList
	ListAllGroupsRequest
	NewPasswordResponse
	UserDef
	AddTokenRequest
	KeyResponse
	AuthenticatePasswordRequest
	AuthenticateTokenRequest
*/
package auth

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TokenType int32

const (
	TokenType_UNDEFINED TokenType = 0
	TokenType_PERMANENT TokenType = 1
	TokenType_SESSION   TokenType = 2
)

var TokenType_name = map[int32]string{
	0: "UNDEFINED",
	1: "PERMANENT",
	2: "SESSION",
}
var TokenType_value = map[string]int32{
	"UNDEFINED": 0,
	"PERMANENT": 1,
	"SESSION":   2,
}

func (x TokenType) String() string {
	return proto.EnumName(TokenType_name, int32(x))
}
func (TokenType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

//
// id            | bigint                      |           | not null |
// email         | character varying(1000)     |           | not null |
// emailverified | integer                     |           | not null |
// firstname     | character varying(1000)     |           | not null |
// lastname      | character varying(1000)     |           | not null |
// password      | character varying(1000)     |           | not null |
// created       | timestamp without time zone |           | not null |
// lastmodified  | timestamp without time zone |           | not null |
// creator_id    | bigint                      |           | not null |
// modifiedby_id | bigint                      |           | not null |
// admin         | boolean                     |           | not null |
type UserDetail struct {
	ID            uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Email         string `protobuf:"bytes,2,opt,name=Email" json:"Email,omitempty"`
	FirstName     string `protobuf:"bytes,3,opt,name=FirstName" json:"FirstName,omitempty"`
	LastName      string `protobuf:"bytes,4,opt,name=LastName" json:"LastName,omitempty"`
	Password      string `protobuf:"bytes,5,opt,name=Password" json:"Password,omitempty"`
	Admin         bool   `protobuf:"varint,6,opt,name=Admin" json:"Admin,omitempty"`
	EmailVerified uint32 `protobuf:"varint,7,opt,name=EmailVerified" json:"EmailVerified,omitempty"`
}

func (m *UserDetail) Reset()                    { *m = UserDetail{} }
func (m *UserDetail) String() string            { return proto.CompactTextString(m) }
func (*UserDetail) ProtoMessage()               {}
func (*UserDetail) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *UserDetail) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserDetail) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *UserDetail) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *UserDetail) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *UserDetail) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *UserDetail) GetAdmin() bool {
	if m != nil {
		return m.Admin
	}
	return false
}

func (m *UserDetail) GetEmailVerified() uint32 {
	if m != nil {
		return m.EmailVerified
	}
	return 0
}

type UserTokens struct {
	ID        uint64    `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID    uint64    `protobuf:"varint,2,opt,name=UserID" json:"UserID,omitempty"`
	Token     string    `protobuf:"bytes,3,opt,name=Token" json:"Token,omitempty"`
	Created   uint32    `protobuf:"varint,4,opt,name=Created" json:"Created,omitempty"`
	Expiry    uint32    `protobuf:"varint,5,opt,name=Expiry" json:"Expiry,omitempty"`
	TokenType TokenType `protobuf:"varint,6,opt,name=TokenType,enum=auth.TokenType" json:"TokenType,omitempty"`
}

func (m *UserTokens) Reset()                    { *m = UserTokens{} }
func (m *UserTokens) String() string            { return proto.CompactTextString(m) }
func (*UserTokens) ProtoMessage()               {}
func (*UserTokens) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *UserTokens) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserTokens) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserTokens) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *UserTokens) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *UserTokens) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *UserTokens) GetTokenType() TokenType {
	if m != nil {
		return m.TokenType
	}
	return TokenType_UNDEFINED
}

type GroupDB struct {
	ID          uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	Description string `protobuf:"bytes,3,opt,name=Description" json:"Description,omitempty"`
}

func (m *GroupDB) Reset()                    { *m = GroupDB{} }
func (m *GroupDB) String() string            { return proto.CompactTextString(m) }
func (*GroupDB) ProtoMessage()               {}
func (*GroupDB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GroupDB) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GroupDB) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GroupDB) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type EmailVerifyPins struct {
	ID       uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID   uint64 `protobuf:"varint,2,opt,name=UserID" json:"UserID,omitempty"`
	Pin      string `protobuf:"bytes,3,opt,name=Pin" json:"Pin,omitempty"`
	Created  uint64 `protobuf:"varint,4,opt,name=Created" json:"Created,omitempty"`
	Accepted uint64 `protobuf:"varint,5,opt,name=Accepted" json:"Accepted,omitempty"`
}

func (m *EmailVerifyPins) Reset()                    { *m = EmailVerifyPins{} }
func (m *EmailVerifyPins) String() string            { return proto.CompactTextString(m) }
func (*EmailVerifyPins) ProtoMessage()               {}
func (*EmailVerifyPins) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *EmailVerifyPins) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *EmailVerifyPins) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *EmailVerifyPins) GetPin() string {
	if m != nil {
		return m.Pin
	}
	return ""
}

func (m *EmailVerifyPins) GetCreated() uint64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *EmailVerifyPins) GetAccepted() uint64 {
	if m != nil {
		return m.Accepted
	}
	return 0
}

type SudoStatus struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// which user has sudoed
	UserID uint64 `protobuf:"varint,2,opt,name=UserID" json:"UserID,omitempty"`
	// to which group? typcially root
	GroupID string `protobuf:"bytes,3,opt,name=GroupID" json:"GroupID,omitempty"`
	// for how long?
	Expiry uint32 `protobuf:"varint,4,opt,name=Expiry" json:"Expiry,omitempty"`
}

func (m *SudoStatus) Reset()                    { *m = SudoStatus{} }
func (m *SudoStatus) String() string            { return proto.CompactTextString(m) }
func (*SudoStatus) ProtoMessage()               {}
func (*SudoStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SudoStatus) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SudoStatus) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *SudoStatus) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *SudoStatus) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func init() {
	proto.RegisterType((*UserDetail)(nil), "auth.UserDetail")
	proto.RegisterType((*UserTokens)(nil), "auth.UserTokens")
	proto.RegisterType((*GroupDB)(nil), "auth.GroupDB")
	proto.RegisterType((*EmailVerifyPins)(nil), "auth.EmailVerifyPins")
	proto.RegisterType((*SudoStatus)(nil), "auth.SudoStatus")
	proto.RegisterEnum("auth.TokenType", TokenType_name, TokenType_value)
}

func init() { proto.RegisterFile("golang.conradwood.net/apis/auth/auth-db.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 446 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x93, 0xdf, 0x6a, 0xdb, 0x30,
	0x14, 0xc6, 0xe7, 0xd4, 0xf9, 0x77, 0x8a, 0xdb, 0x20, 0xc6, 0x30, 0x65, 0x30, 0xcf, 0xec, 0x22,
	0x0c, 0xe2, 0xc2, 0x06, 0xbb, 0x4f, 0x27, 0x77, 0x18, 0x36, 0x37, 0xc8, 0xe9, 0xee, 0xd5, 0x48,
	0xed, 0xc4, 0x12, 0xcb, 0xc8, 0x0a, 0x5d, 0x2e, 0xf7, 0x3c, 0x7b, 0x8d, 0x3d, 0xd8, 0x90, 0x2c,
	0x27, 0xde, 0x72, 0xb3, 0xde, 0x04, 0xfd, 0xce, 0x17, 0xe9, 0x9c, 0xef, 0x33, 0x07, 0x66, 0x0f,
	0x72, 0x4d, 0xcb, 0x87, 0x64, 0x25, 0x4b, 0x45, 0xd9, 0xa3, 0x94, 0x2c, 0x29, 0xb9, 0xbe, 0xa4,
	0x95, 0xa8, 0x2f, 0xe9, 0x56, 0x7f, 0xb3, 0x3f, 0x33, 0x76, 0x97, 0x54, 0x4a, 0x6a, 0x89, 0x7c,
	0x83, 0xf1, 0x6f, 0x0f, 0xe0, 0xb6, 0xe6, 0x0a, 0x73, 0x4d, 0xc5, 0x1a, 0x9d, 0x41, 0x2f, 0xc3,
	0xa1, 0x17, 0x79, 0x53, 0x9f, 0xf4, 0x32, 0x8c, 0x9e, 0x43, 0x3f, 0xdd, 0x50, 0xb1, 0x0e, 0x7b,
	0x91, 0x37, 0x1d, 0x93, 0x06, 0xd0, 0x4b, 0x18, 0x5f, 0x0b, 0x55, 0xeb, 0x9c, 0x6e, 0x78, 0x78,
	0x62, 0x95, 0x43, 0x01, 0x5d, 0xc0, 0xe8, 0x33, 0x75, 0xa2, 0x6f, 0xc5, 0x3d, 0x1b, 0x6d, 0x41,
	0xeb, 0xfa, 0x51, 0x2a, 0x16, 0xf6, 0x1b, 0xad, 0x65, 0xd3, 0x6b, 0xce, 0x36, 0xa2, 0x0c, 0x07,
	0x91, 0x37, 0x1d, 0x91, 0x06, 0xd0, 0x1b, 0x08, 0x6c, 0xd3, 0xaf, 0x5c, 0x89, 0x7b, 0xc1, 0x59,
	0x38, 0x8c, 0xbc, 0x69, 0x40, 0xfe, 0x2e, 0xc6, 0xbf, 0x9c, 0x8d, 0xa5, 0xfc, 0xce, 0xcb, 0xfa,
	0xc8, 0xc6, 0x0b, 0x18, 0x18, 0x35, 0xc3, 0xd6, 0x87, 0x4f, 0x1c, 0x99, 0x96, 0xf6, 0x86, 0x33,
	0xd1, 0x00, 0x0a, 0x61, 0xf8, 0x51, 0x71, 0xaa, 0x39, 0xb3, 0xf3, 0x07, 0xa4, 0x45, 0xf3, 0x4e,
	0xfa, 0xa3, 0x12, 0x6a, 0x67, 0x87, 0x0f, 0x88, 0x23, 0x34, 0x83, 0xb1, 0xbd, 0xba, 0xdc, 0x55,
	0xdc, 0x8e, 0x7f, 0xf6, 0xee, 0x3c, 0x31, 0xf9, 0x26, 0xfb, 0x32, 0x39, 0xfc, 0x23, 0xbe, 0x81,
	0xe1, 0x27, 0x25, 0xb7, 0x15, 0xbe, 0x3a, 0x9a, 0x14, 0x81, 0x6f, 0x83, 0x6b, 0xf2, 0xb6, 0x67,
	0x14, 0xc1, 0x29, 0xe6, 0xf5, 0x4a, 0x89, 0x4a, 0x0b, 0xd9, 0xce, 0xda, 0x2d, 0xc5, 0x3f, 0x3d,
	0x38, 0x3f, 0x04, 0xb2, 0x5b, 0x88, 0x27, 0x64, 0x30, 0x81, 0x93, 0x85, 0x68, 0x5f, 0x35, 0xc7,
	0x7f, 0xfd, 0xfb, 0x07, 0xff, 0x17, 0x30, 0x9a, 0xaf, 0x56, 0xbc, 0x32, 0x52, 0xdf, 0x4a, 0x7b,
	0x8e, 0xef, 0x01, 0x8a, 0x2d, 0x93, 0x85, 0xa6, 0x7a, 0xfb, 0xff, 0xdd, 0x43, 0x17, 0x45, 0x86,
	0xdd, 0x04, 0x2d, 0x76, 0xb2, 0xf6, 0xbb, 0x59, 0xbf, 0xfd, 0xd0, 0xc9, 0x1a, 0x05, 0x30, 0xbe,
	0xcd, 0x71, 0x7a, 0x9d, 0xe5, 0x29, 0x9e, 0x3c, 0x33, 0xb8, 0x48, 0xc9, 0x97, 0x79, 0x9e, 0xe6,
	0xcb, 0x89, 0x87, 0x4e, 0x61, 0x58, 0xa4, 0x45, 0x91, 0xdd, 0xe4, 0x93, 0xde, 0xd5, 0x6b, 0x78,
	0x55, 0x72, 0xdd, 0xdd, 0x0e, 0xb7, 0x2f, 0x66, 0x41, 0xec, 0xc7, 0xba, 0x1b, 0xd8, 0xcd, 0x78,
	0xff, 0x27, 0x00, 0x00, 0xff, 0xff, 0x6e, 0xa3, 0x1e, 0x60, 0x4a, 0x03, 0x00, 0x00,
}
