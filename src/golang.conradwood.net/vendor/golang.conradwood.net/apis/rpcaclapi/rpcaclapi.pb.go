// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/rpcaclapi/rpcaclapi.proto
// DO NOT EDIT!

/*
Package rpcaclapi is a generated protocol buffer package.

It is generated from these files:
	golang.conradwood.net/apis/rpcaclapi/rpcaclapi.proto

It has these top-level messages:
	Service
	Method
	ServiceList
	GetMethodsRequest
	MethodList
	FullMethodList
	FullMethod
	LogEntryRequest
	LogEntry
	LogEntryList
	MethodIDAndGroupID
	LogSearchRequest
	ErrorSearchRequest
	ErrorEntryList
	ErrorEntry
	Call
	CallList
	ServiceNameRequest
	ServiceIDResponse
	DBRule
	DBRuleMatch
	DBRuleService
	DBRuleGroup
	Rule
	ServiceRules
	ServiceID
	ServiceIDList
	GroupServiceRequest
	ServiceByUserIDRequest
	ServiceByIDRequest
*/
package rpcaclapi

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import auth "golang.conradwood.net/apis/auth"
import common "golang.conradwood.net/apis/common"
import rpcinterceptor "golang.conradwood.net/apis/rpcinterceptor"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// rule matches on wether service or user or both or neither exists
type RuleMatch int32

const (
	RuleMatch_INVALID          RuleMatch = 0
	RuleMatch_NEITHER          RuleMatch = 1
	RuleMatch_SERVICE_ONLY     RuleMatch = 2
	RuleMatch_USER_ONLY        RuleMatch = 3
	RuleMatch_SERVICE_AND_USER RuleMatch = 4
)

var RuleMatch_name = map[int32]string{
	0: "INVALID",
	1: "NEITHER",
	2: "SERVICE_ONLY",
	3: "USER_ONLY",
	4: "SERVICE_AND_USER",
}
var RuleMatch_value = map[string]int32{
	"INVALID":          0,
	"NEITHER":          1,
	"SERVICE_ONLY":     2,
	"USER_ONLY":        3,
	"SERVICE_AND_USER": 4,
}

func (x RuleMatch) String() string {
	return proto.EnumName(RuleMatch_name, int32(x))
}
func (RuleMatch) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Service struct {
	ID     uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Name   string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	UserID string `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Service) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Service) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Service) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

type Method struct {
	ID        uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	ServiceID uint64 `protobuf:"varint,3,opt,name=ServiceID" json:"ServiceID,omitempty"`
}

func (m *Method) Reset()                    { *m = Method{} }
func (m *Method) String() string            { return proto.CompactTextString(m) }
func (*Method) ProtoMessage()               {}
func (*Method) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Method) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Method) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Method) GetServiceID() uint64 {
	if m != nil {
		return m.ServiceID
	}
	return 0
}

type ServiceList struct {
	Services []*Service `protobuf:"bytes,1,rep,name=Services" json:"Services,omitempty"`
}

func (m *ServiceList) Reset()                    { *m = ServiceList{} }
func (m *ServiceList) String() string            { return proto.CompactTextString(m) }
func (*ServiceList) ProtoMessage()               {}
func (*ServiceList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ServiceList) GetServices() []*Service {
	if m != nil {
		return m.Services
	}
	return nil
}

type GetMethodsRequest struct {
	ServiceID uint64 `protobuf:"varint,1,opt,name=ServiceID" json:"ServiceID,omitempty"`
}

func (m *GetMethodsRequest) Reset()                    { *m = GetMethodsRequest{} }
func (m *GetMethodsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetMethodsRequest) ProtoMessage()               {}
func (*GetMethodsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *GetMethodsRequest) GetServiceID() uint64 {
	if m != nil {
		return m.ServiceID
	}
	return 0
}

type MethodList struct {
	Methods []*Method `protobuf:"bytes,1,rep,name=Methods" json:"Methods,omitempty"`
}

func (m *MethodList) Reset()                    { *m = MethodList{} }
func (m *MethodList) String() string            { return proto.CompactTextString(m) }
func (*MethodList) ProtoMessage()               {}
func (*MethodList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *MethodList) GetMethods() []*Method {
	if m != nil {
		return m.Methods
	}
	return nil
}

type FullMethodList struct {
	Methods []*FullMethod `protobuf:"bytes,1,rep,name=Methods" json:"Methods,omitempty"`
}

func (m *FullMethodList) Reset()                    { *m = FullMethodList{} }
func (m *FullMethodList) String() string            { return proto.CompactTextString(m) }
func (*FullMethodList) ProtoMessage()               {}
func (*FullMethodList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *FullMethodList) GetMethods() []*FullMethod {
	if m != nil {
		return m.Methods
	}
	return nil
}

type FullMethod struct {
	ID      uint64   `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Name    string   `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	Service *Service `protobuf:"bytes,3,opt,name=Service" json:"Service,omitempty"`
}

func (m *FullMethod) Reset()                    { *m = FullMethod{} }
func (m *FullMethod) String() string            { return proto.CompactTextString(m) }
func (*FullMethod) ProtoMessage()               {}
func (*FullMethod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FullMethod) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *FullMethod) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FullMethod) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

type LogEntryRequest struct {
	MaxEntries uint64 `protobuf:"varint,1,opt,name=MaxEntries" json:"MaxEntries,omitempty"`
}

func (m *LogEntryRequest) Reset()                    { *m = LogEntryRequest{} }
func (m *LogEntryRequest) String() string            { return proto.CompactTextString(m) }
func (*LogEntryRequest) ProtoMessage()               {}
func (*LogEntryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *LogEntryRequest) GetMaxEntries() uint64 {
	if m != nil {
		return m.MaxEntries
	}
	return 0
}

type LogEntry struct {
	Timestamp uint64                               `protobuf:"varint,1,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Service   *Service                             `protobuf:"bytes,2,opt,name=Service" json:"Service,omitempty"`
	Method    *Method                              `protobuf:"bytes,3,opt,name=Method" json:"Method,omitempty"`
	Response  *rpcinterceptor.InterceptRPCResponse `protobuf:"bytes,4,opt,name=Response" json:"Response,omitempty"`
}

func (m *LogEntry) Reset()                    { *m = LogEntry{} }
func (m *LogEntry) String() string            { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()               {}
func (*LogEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *LogEntry) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *LogEntry) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *LogEntry) GetMethod() *Method {
	if m != nil {
		return m.Method
	}
	return nil
}

func (m *LogEntry) GetResponse() *rpcinterceptor.InterceptRPCResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type LogEntryList struct {
	Entries []*LogEntry `protobuf:"bytes,1,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *LogEntryList) Reset()                    { *m = LogEntryList{} }
func (m *LogEntryList) String() string            { return proto.CompactTextString(m) }
func (*LogEntryList) ProtoMessage()               {}
func (*LogEntryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *LogEntryList) GetEntries() []*LogEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type MethodIDAndGroupID struct {
	MethodID uint64 `protobuf:"varint,1,opt,name=MethodID" json:"MethodID,omitempty"`
	GroupID  string `protobuf:"bytes,2,opt,name=GroupID" json:"GroupID,omitempty"`
}

func (m *MethodIDAndGroupID) Reset()                    { *m = MethodIDAndGroupID{} }
func (m *MethodIDAndGroupID) String() string            { return proto.CompactTextString(m) }
func (*MethodIDAndGroupID) ProtoMessage()               {}
func (*MethodIDAndGroupID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *MethodIDAndGroupID) GetMethodID() uint64 {
	if m != nil {
		return m.MethodID
	}
	return 0
}

func (m *MethodIDAndGroupID) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

type LogSearchRequest struct {
	// only include entries which these user(s) made (empty list=all)
	UserIDs []string `protobuf:"bytes,1,rep,name=UserIDs" json:"UserIDs,omitempty"`
	// only include entries which users in these groups made (empty list=all)
	GroupIDs []string `protobuf:"bytes,2,rep,name=GroupIDs" json:"GroupIDs,omitempty"`
	// automatically include entries which do not match the SearchRequest but have the same requestid as one that matched
	FullRequests bool `protobuf:"varint,3,opt,name=FullRequests" json:"FullRequests,omitempty"`
	// unix epoch starttime (only include entries younger than this). 0 = all
	StartTime uint32 `protobuf:"varint,4,opt,name=StartTime" json:"StartTime,omitempty"`
	// unix epoch endtime (only include entries older than this). 0 = all
	EndTime uint32 `protobuf:"varint,5,opt,name=EndTime" json:"EndTime,omitempty"`
	// only include entries where the caller service is in this list (empty list=all)
	CallerServiceIDs []uint64 `protobuf:"varint,6,rep,packed,name=CallerServiceIDs" json:"CallerServiceIDs,omitempty"`
	// only include entries where the called service is in this list (empty list=all)
	CalledServiceIDs []uint64 `protobuf:"varint,7,rep,packed,name=CalledServiceIDs" json:"CalledServiceIDs,omitempty"`
	// only include entries where the caller method is in this list (empty list=all)
	CallerMethodIDs []uint64 `protobuf:"varint,8,rep,packed,name=CallerMethodIDs" json:"CallerMethodIDs,omitempty"`
	// only include entries where the called method is in this list (empty list=all)
	CalledMethodIDs []uint64 `protobuf:"varint,9,rep,packed,name=CalledMethodIDs" json:"CalledMethodIDs,omitempty"`
	// limit searchlogs to these request IDs
	RequestIDs []string `protobuf:"bytes,10,rep,name=RequestIDs" json:"RequestIDs,omitempty"`
}

func (m *LogSearchRequest) Reset()                    { *m = LogSearchRequest{} }
func (m *LogSearchRequest) String() string            { return proto.CompactTextString(m) }
func (*LogSearchRequest) ProtoMessage()               {}
func (*LogSearchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *LogSearchRequest) GetUserIDs() []string {
	if m != nil {
		return m.UserIDs
	}
	return nil
}

func (m *LogSearchRequest) GetGroupIDs() []string {
	if m != nil {
		return m.GroupIDs
	}
	return nil
}

func (m *LogSearchRequest) GetFullRequests() bool {
	if m != nil {
		return m.FullRequests
	}
	return false
}

func (m *LogSearchRequest) GetStartTime() uint32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *LogSearchRequest) GetEndTime() uint32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *LogSearchRequest) GetCallerServiceIDs() []uint64 {
	if m != nil {
		return m.CallerServiceIDs
	}
	return nil
}

func (m *LogSearchRequest) GetCalledServiceIDs() []uint64 {
	if m != nil {
		return m.CalledServiceIDs
	}
	return nil
}

func (m *LogSearchRequest) GetCallerMethodIDs() []uint64 {
	if m != nil {
		return m.CallerMethodIDs
	}
	return nil
}

func (m *LogSearchRequest) GetCalledMethodIDs() []uint64 {
	if m != nil {
		return m.CalledMethodIDs
	}
	return nil
}

func (m *LogSearchRequest) GetRequestIDs() []string {
	if m != nil {
		return m.RequestIDs
	}
	return nil
}

type ErrorSearchRequest struct {
	// only include entries which these user(s) made (empty list=all)
	UserIDs []string `protobuf:"bytes,1,rep,name=UserIDs" json:"UserIDs,omitempty"`
	// only include entries which users in these groups made (empty list=all)
	GroupIDs []string `protobuf:"bytes,2,rep,name=GroupIDs" json:"GroupIDs,omitempty"`
	// automatically include entries which do not match the SearchRequest but have the same requestid as one that matched
	FullRequests bool `protobuf:"varint,3,opt,name=FullRequests" json:"FullRequests,omitempty"`
	// unix epoch starttime (only include entries younger than this). 0 = all
	StartTime uint32 `protobuf:"varint,4,opt,name=StartTime" json:"StartTime,omitempty"`
	// unix epoch endtime (only include entries older than this). 0 = all
	EndTime uint32 `protobuf:"varint,5,opt,name=EndTime" json:"EndTime,omitempty"`
	// only include entries where the caller service is in this list (empty list=all)
	CallerServiceIDs []uint64 `protobuf:"varint,6,rep,packed,name=CallerServiceIDs" json:"CallerServiceIDs,omitempty"`
	// only include entries where the called service is in this list (empty list=all)
	CalledServiceIDs []uint64 `protobuf:"varint,7,rep,packed,name=CalledServiceIDs" json:"CalledServiceIDs,omitempty"`
	// only include entries where the caller method is in this list (empty list=all)
	CallerMethodIDs []uint64 `protobuf:"varint,8,rep,packed,name=CallerMethodIDs" json:"CallerMethodIDs,omitempty"`
	// only include entries where the called method is in this list (empty list=all)
	CalledMethodIDs []uint64 `protobuf:"varint,9,rep,packed,name=CalledMethodIDs" json:"CalledMethodIDs,omitempty"`
	// limit searchlogs to these request IDs
	RequestIDs []string `protobuf:"bytes,10,rep,name=RequestIDs" json:"RequestIDs,omitempty"`
	// exclude those userids
	ExcludeUserIDs []string `protobuf:"bytes,11,rep,name=ExcludeUserIDs" json:"ExcludeUserIDs,omitempty"`
}

func (m *ErrorSearchRequest) Reset()                    { *m = ErrorSearchRequest{} }
func (m *ErrorSearchRequest) String() string            { return proto.CompactTextString(m) }
func (*ErrorSearchRequest) ProtoMessage()               {}
func (*ErrorSearchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ErrorSearchRequest) GetUserIDs() []string {
	if m != nil {
		return m.UserIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetGroupIDs() []string {
	if m != nil {
		return m.GroupIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetFullRequests() bool {
	if m != nil {
		return m.FullRequests
	}
	return false
}

func (m *ErrorSearchRequest) GetStartTime() uint32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ErrorSearchRequest) GetEndTime() uint32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *ErrorSearchRequest) GetCallerServiceIDs() []uint64 {
	if m != nil {
		return m.CallerServiceIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetCalledServiceIDs() []uint64 {
	if m != nil {
		return m.CalledServiceIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetCallerMethodIDs() []uint64 {
	if m != nil {
		return m.CallerMethodIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetCalledMethodIDs() []uint64 {
	if m != nil {
		return m.CalledMethodIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetRequestIDs() []string {
	if m != nil {
		return m.RequestIDs
	}
	return nil
}

func (m *ErrorSearchRequest) GetExcludeUserIDs() []string {
	if m != nil {
		return m.ExcludeUserIDs
	}
	return nil
}

type ErrorEntryList struct {
	Entries []*ErrorEntry `protobuf:"bytes,1,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *ErrorEntryList) Reset()                    { *m = ErrorEntryList{} }
func (m *ErrorEntryList) String() string            { return proto.CompactTextString(m) }
func (*ErrorEntryList) ProtoMessage()               {}
func (*ErrorEntryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ErrorEntryList) GetEntries() []*ErrorEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type ErrorEntry struct {
	Timestamp      uint64     `protobuf:"varint,1,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Service        *Service   `protobuf:"bytes,2,opt,name=Service" json:"Service,omitempty"`
	Method         *Method    `protobuf:"bytes,3,opt,name=Method" json:"Method,omitempty"`
	RequestID      string     `protobuf:"bytes,4,opt,name=RequestID" json:"RequestID,omitempty"`
	CallerUser     *auth.User `protobuf:"bytes,5,opt,name=CallerUser" json:"CallerUser,omitempty"`
	ErrorCode      uint32     `protobuf:"varint,6,opt,name=ErrorCode" json:"ErrorCode,omitempty"`
	DisplayMessage string     `protobuf:"bytes,7,opt,name=DisplayMessage" json:"DisplayMessage,omitempty"`
	LogMessage     string     `protobuf:"bytes,8,opt,name=LogMessage" json:"LogMessage,omitempty"`
}

func (m *ErrorEntry) Reset()                    { *m = ErrorEntry{} }
func (m *ErrorEntry) String() string            { return proto.CompactTextString(m) }
func (*ErrorEntry) ProtoMessage()               {}
func (*ErrorEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ErrorEntry) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ErrorEntry) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *ErrorEntry) GetMethod() *Method {
	if m != nil {
		return m.Method
	}
	return nil
}

func (m *ErrorEntry) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *ErrorEntry) GetCallerUser() *auth.User {
	if m != nil {
		return m.CallerUser
	}
	return nil
}

func (m *ErrorEntry) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *ErrorEntry) GetDisplayMessage() string {
	if m != nil {
		return m.DisplayMessage
	}
	return ""
}

func (m *ErrorEntry) GetLogMessage() string {
	if m != nil {
		return m.LogMessage
	}
	return ""
}

type Call struct {
	CalledMethod   *FullMethod `protobuf:"bytes,1,opt,name=CalledMethod" json:"CalledMethod,omitempty"`
	CallingService *auth.User  `protobuf:"bytes,2,opt,name=CallingService" json:"CallingService,omitempty"`
	CallingUser    *auth.User  `protobuf:"bytes,3,opt,name=CallingUser" json:"CallingUser,omitempty"`
}

func (m *Call) Reset()                    { *m = Call{} }
func (m *Call) String() string            { return proto.CompactTextString(m) }
func (*Call) ProtoMessage()               {}
func (*Call) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Call) GetCalledMethod() *FullMethod {
	if m != nil {
		return m.CalledMethod
	}
	return nil
}

func (m *Call) GetCallingService() *auth.User {
	if m != nil {
		return m.CallingService
	}
	return nil
}

func (m *Call) GetCallingUser() *auth.User {
	if m != nil {
		return m.CallingUser
	}
	return nil
}

type CallList struct {
	Calls []*Call `protobuf:"bytes,1,rep,name=Calls" json:"Calls,omitempty"`
}

func (m *CallList) Reset()                    { *m = CallList{} }
func (m *CallList) String() string            { return proto.CompactTextString(m) }
func (*CallList) ProtoMessage()               {}
func (*CallList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *CallList) GetCalls() []*Call {
	if m != nil {
		return m.Calls
	}
	return nil
}

type ServiceNameRequest struct {
	Name string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
}

func (m *ServiceNameRequest) Reset()                    { *m = ServiceNameRequest{} }
func (m *ServiceNameRequest) String() string            { return proto.CompactTextString(m) }
func (*ServiceNameRequest) ProtoMessage()               {}
func (*ServiceNameRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ServiceNameRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ServiceIDResponse struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *ServiceIDResponse) Reset()                    { *m = ServiceIDResponse{} }
func (m *ServiceIDResponse) String() string            { return proto.CompactTextString(m) }
func (*ServiceIDResponse) ProtoMessage()               {}
func (*ServiceIDResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ServiceIDResponse) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type DBRule struct {
	ID            uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ServiceID     uint64 `protobuf:"varint,2,opt,name=ServiceID" json:"ServiceID,omitempty"`
	ResultOnMatch bool   `protobuf:"varint,3,opt,name=ResultOnMatch" json:"ResultOnMatch,omitempty"`
}

func (m *DBRule) Reset()                    { *m = DBRule{} }
func (m *DBRule) String() string            { return proto.CompactTextString(m) }
func (*DBRule) ProtoMessage()               {}
func (*DBRule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *DBRule) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBRule) GetServiceID() uint64 {
	if m != nil {
		return m.ServiceID
	}
	return 0
}

func (m *DBRule) GetResultOnMatch() bool {
	if m != nil {
		return m.ResultOnMatch
	}
	return false
}

type DBRuleMatch struct {
	ID        uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RuleID    uint64 `protobuf:"varint,2,opt,name=RuleID" json:"RuleID,omitempty"`
	RuleMatch uint32 `protobuf:"varint,3,opt,name=RuleMatch" json:"RuleMatch,omitempty"`
}

func (m *DBRuleMatch) Reset()                    { *m = DBRuleMatch{} }
func (m *DBRuleMatch) String() string            { return proto.CompactTextString(m) }
func (*DBRuleMatch) ProtoMessage()               {}
func (*DBRuleMatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *DBRuleMatch) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBRuleMatch) GetRuleID() uint64 {
	if m != nil {
		return m.RuleID
	}
	return 0
}

func (m *DBRuleMatch) GetRuleMatch() uint32 {
	if m != nil {
		return m.RuleMatch
	}
	return 0
}

type DBRuleService struct {
	ID            uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RuleID        uint64 `protobuf:"varint,2,opt,name=RuleID" json:"RuleID,omitempty"`
	ServiceUserID string `protobuf:"bytes,3,opt,name=ServiceUserID" json:"ServiceUserID,omitempty"`
}

func (m *DBRuleService) Reset()                    { *m = DBRuleService{} }
func (m *DBRuleService) String() string            { return proto.CompactTextString(m) }
func (*DBRuleService) ProtoMessage()               {}
func (*DBRuleService) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *DBRuleService) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBRuleService) GetRuleID() uint64 {
	if m != nil {
		return m.RuleID
	}
	return 0
}

func (m *DBRuleService) GetServiceUserID() string {
	if m != nil {
		return m.ServiceUserID
	}
	return ""
}

type DBRuleGroup struct {
	ID      uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RuleID  uint64 `protobuf:"varint,2,opt,name=RuleID" json:"RuleID,omitempty"`
	GroupID string `protobuf:"bytes,3,opt,name=GroupID" json:"GroupID,omitempty"`
}

func (m *DBRuleGroup) Reset()                    { *m = DBRuleGroup{} }
func (m *DBRuleGroup) String() string            { return proto.CompactTextString(m) }
func (*DBRuleGroup) ProtoMessage()               {}
func (*DBRuleGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *DBRuleGroup) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBRuleGroup) GetRuleID() uint64 {
	if m != nil {
		return m.RuleID
	}
	return 0
}

func (m *DBRuleGroup) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

//
// the checks on inbound request are done like so:
// 1. check if presence of calleruser and callerservice match any of the "RuleMatch" - if not: skip
// 2. if user exists and is not in group AND group is non-empty: skip
// 3. if service exists and is not in list AND list is non-empty: skip
// 4. Apply "grant"
type Rule struct {
	ID            uint64      `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Match         []RuleMatch `protobuf:"varint,2,rep,packed,name=Match,enum=rpcaclapi.RuleMatch" json:"Match,omitempty"`
	FromServiceID []string    `protobuf:"bytes,3,rep,name=FromServiceID" json:"FromServiceID,omitempty"`
	GroupID       []string    `protobuf:"bytes,4,rep,name=GroupID" json:"GroupID,omitempty"`
	Grant         bool        `protobuf:"varint,5,opt,name=Grant" json:"Grant,omitempty"`
}

func (m *Rule) Reset()                    { *m = Rule{} }
func (m *Rule) String() string            { return proto.CompactTextString(m) }
func (*Rule) ProtoMessage()               {}
func (*Rule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *Rule) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Rule) GetMatch() []RuleMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *Rule) GetFromServiceID() []string {
	if m != nil {
		return m.FromServiceID
	}
	return nil
}

func (m *Rule) GetGroupID() []string {
	if m != nil {
		return m.GroupID
	}
	return nil
}

func (m *Rule) GetGrant() bool {
	if m != nil {
		return m.Grant
	}
	return false
}

// this defines how to decide wether or not to grant access to a service
type ServiceRules struct {
	ServiceID uint64  `protobuf:"varint,1,opt,name=ServiceID" json:"ServiceID,omitempty"`
	Rules     []*Rule `protobuf:"bytes,2,rep,name=Rules" json:"Rules,omitempty"`
}

func (m *ServiceRules) Reset()                    { *m = ServiceRules{} }
func (m *ServiceRules) String() string            { return proto.CompactTextString(m) }
func (*ServiceRules) ProtoMessage()               {}
func (*ServiceRules) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *ServiceRules) GetServiceID() uint64 {
	if m != nil {
		return m.ServiceID
	}
	return 0
}

func (m *ServiceRules) GetRules() []*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type ServiceID struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *ServiceID) Reset()                    { *m = ServiceID{} }
func (m *ServiceID) String() string            { return proto.CompactTextString(m) }
func (*ServiceID) ProtoMessage()               {}
func (*ServiceID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *ServiceID) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type ServiceIDList struct {
	ID []uint64 `protobuf:"varint,1,rep,packed,name=ID" json:"ID,omitempty"`
}

func (m *ServiceIDList) Reset()                    { *m = ServiceIDList{} }
func (m *ServiceIDList) String() string            { return proto.CompactTextString(m) }
func (*ServiceIDList) ProtoMessage()               {}
func (*ServiceIDList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *ServiceIDList) GetID() []uint64 {
	if m != nil {
		return m.ID
	}
	return nil
}

type GroupServiceRequest struct {
	ServiceName string `protobuf:"bytes,1,opt,name=ServiceName" json:"ServiceName,omitempty"`
	ServiceID   uint64 `protobuf:"varint,2,opt,name=ServiceID" json:"ServiceID,omitempty"`
	GroupID     string `protobuf:"bytes,3,opt,name=GroupID" json:"GroupID,omitempty"`
}

func (m *GroupServiceRequest) Reset()                    { *m = GroupServiceRequest{} }
func (m *GroupServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*GroupServiceRequest) ProtoMessage()               {}
func (*GroupServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *GroupServiceRequest) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *GroupServiceRequest) GetServiceID() uint64 {
	if m != nil {
		return m.ServiceID
	}
	return 0
}

func (m *GroupServiceRequest) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

type ServiceByUserIDRequest struct {
	UserID string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
}

func (m *ServiceByUserIDRequest) Reset()                    { *m = ServiceByUserIDRequest{} }
func (m *ServiceByUserIDRequest) String() string            { return proto.CompactTextString(m) }
func (*ServiceByUserIDRequest) ProtoMessage()               {}
func (*ServiceByUserIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *ServiceByUserIDRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

type ServiceByIDRequest struct {
	ID string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *ServiceByIDRequest) Reset()                    { *m = ServiceByIDRequest{} }
func (m *ServiceByIDRequest) String() string            { return proto.CompactTextString(m) }
func (*ServiceByIDRequest) ProtoMessage()               {}
func (*ServiceByIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *ServiceByIDRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func init() {
	proto.RegisterType((*Service)(nil), "rpcaclapi.Service")
	proto.RegisterType((*Method)(nil), "rpcaclapi.Method")
	proto.RegisterType((*ServiceList)(nil), "rpcaclapi.ServiceList")
	proto.RegisterType((*GetMethodsRequest)(nil), "rpcaclapi.GetMethodsRequest")
	proto.RegisterType((*MethodList)(nil), "rpcaclapi.MethodList")
	proto.RegisterType((*FullMethodList)(nil), "rpcaclapi.FullMethodList")
	proto.RegisterType((*FullMethod)(nil), "rpcaclapi.FullMethod")
	proto.RegisterType((*LogEntryRequest)(nil), "rpcaclapi.LogEntryRequest")
	proto.RegisterType((*LogEntry)(nil), "rpcaclapi.LogEntry")
	proto.RegisterType((*LogEntryList)(nil), "rpcaclapi.LogEntryList")
	proto.RegisterType((*MethodIDAndGroupID)(nil), "rpcaclapi.MethodIDAndGroupID")
	proto.RegisterType((*LogSearchRequest)(nil), "rpcaclapi.LogSearchRequest")
	proto.RegisterType((*ErrorSearchRequest)(nil), "rpcaclapi.ErrorSearchRequest")
	proto.RegisterType((*ErrorEntryList)(nil), "rpcaclapi.ErrorEntryList")
	proto.RegisterType((*ErrorEntry)(nil), "rpcaclapi.ErrorEntry")
	proto.RegisterType((*Call)(nil), "rpcaclapi.Call")
	proto.RegisterType((*CallList)(nil), "rpcaclapi.CallList")
	proto.RegisterType((*ServiceNameRequest)(nil), "rpcaclapi.ServiceNameRequest")
	proto.RegisterType((*ServiceIDResponse)(nil), "rpcaclapi.ServiceIDResponse")
	proto.RegisterType((*DBRule)(nil), "rpcaclapi.DBRule")
	proto.RegisterType((*DBRuleMatch)(nil), "rpcaclapi.DBRuleMatch")
	proto.RegisterType((*DBRuleService)(nil), "rpcaclapi.DBRuleService")
	proto.RegisterType((*DBRuleGroup)(nil), "rpcaclapi.DBRuleGroup")
	proto.RegisterType((*Rule)(nil), "rpcaclapi.Rule")
	proto.RegisterType((*ServiceRules)(nil), "rpcaclapi.ServiceRules")
	proto.RegisterType((*ServiceID)(nil), "rpcaclapi.ServiceID")
	proto.RegisterType((*ServiceIDList)(nil), "rpcaclapi.ServiceIDList")
	proto.RegisterType((*GroupServiceRequest)(nil), "rpcaclapi.GroupServiceRequest")
	proto.RegisterType((*ServiceByUserIDRequest)(nil), "rpcaclapi.ServiceByUserIDRequest")
	proto.RegisterType((*ServiceByIDRequest)(nil), "rpcaclapi.ServiceByIDRequest")
	proto.RegisterEnum("rpcaclapi.RuleMatch", RuleMatch_name, RuleMatch_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RPCACLService service

type RPCACLServiceClient interface {
	// given a serviceid for a service, this will return the rpcinterceptor service
	GetServiceByID(ctx context.Context, in *ServiceByIDRequest, opts ...grpc.CallOption) (*Service, error)
	// given a userid for a service, this will return the rpcinterceptor service
	GetServiceByUserID(ctx context.Context, in *ServiceByUserIDRequest, opts ...grpc.CallOption) (*Service, error)
	// get ALL services currently known
	// (known means: a method of this service has requested authentication at least once.)
	GetServices(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*ServiceList, error)
	// get all methods currently known for a given service
	// (known means: the method has requested authentication at least once.)
	GetMethods(ctx context.Context, in *GetMethodsRequest, opts ...grpc.CallOption) (*MethodList, error)
	// get all groups known to the auth service.
	// essentially queries & caches the auth service
	// OBSOLETE
	GetUserGroups(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*auth.GroupList, error)
	// add user to group
	// OBSOLETE
	AddUserToGroup(ctx context.Context, in *auth.AddToGroupRequest, opts ...grpc.CallOption) (*common.Void, error)
	// remove user from a group
	// OBSOLETE
	RemoveUserFromGroup(ctx context.Context, in *auth.RemoveFromGroupRequest, opts ...grpc.CallOption) (*common.Void, error)
	// get all users for a group
	// OBSOLETE
	ListUsersInGroup(ctx context.Context, in *auth.ListGroupRequest, opts ...grpc.CallOption) (*auth.UserListResponse, error)
	// get all groups associated (have access to) a given method
	// OBSOLETE
	GetGroupsForMethod(ctx context.Context, in *Method, opts ...grpc.CallOption) (*auth.GroupList, error)
	// add a group to a Method (grant access to an rpc for a given group)
	// returns the list of groups for this method PRIOR to the update
	// OBSOLETE
	AddGroupToMethod(ctx context.Context, in *MethodIDAndGroupID, opts ...grpc.CallOption) (*auth.GroupList, error)
	// remove a group from a method (revoke access to an rpc for a given group)
	// returns the list of groups for this method PRIOR to the update
	// OBSOLETE
	RemoveGroupFromMethod(ctx context.Context, in *MethodIDAndGroupID, opts ...grpc.CallOption) (*auth.GroupList, error)
	// return list of methods a group as access to
	// OBSOLETE
	GetMethodsForGroups(ctx context.Context, in *auth.Group, opts ...grpc.CallOption) (*FullMethodList, error)
	// gets the most recent logentries limited by some count
	// OBSOLETE
	GetMostRecentLogs(ctx context.Context, in *LogEntryRequest, opts ...grpc.CallOption) (*LogEntryList, error)
	// gets the most recent logentries for the calling user
	// OBSOLETE
	GetMyMostRecentLogs(ctx context.Context, in *LogEntryRequest, opts ...grpc.CallOption) (*LogEntryList, error)
	// sophisticated(ish) search for logs
	// OBSOLETE
	SearchLogs(ctx context.Context, in *LogSearchRequest, opts ...grpc.CallOption) (*LogEntryList, error)
	// UNDOCUMENTED CALL, USE WITH CARE
	// OBSOLETE
	ListCalls(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*CallList, error)
	// sophisticated(ish) search for errors which occured in the system
	// OBSOLETE
	SearchErrors(ctx context.Context, in *ErrorSearchRequest, opts ...grpc.CallOption) (*ErrorEntryList, error)
	// ServiceNametoID (privileged)
	ServiceNameToID(ctx context.Context, in *ServiceNameRequest, opts ...grpc.CallOption) (*ServiceIDResponse, error)
	// provide set of rules to decide wether or not to grant a request
	GetRulesForService(ctx context.Context, in *ServiceID, opts ...grpc.CallOption) (*ServiceRules, error)
	// provide set of rules to decide wether or not to grant a request
	GetRulesForServices(ctx context.Context, in *ServiceIDList, opts ...grpc.CallOption) (*ServiceRules, error)
	// authorize a particular group for a service
	AuthoriseGroupService(ctx context.Context, in *GroupServiceRequest, opts ...grpc.CallOption) (*Service, error)
}

type rPCACLServiceClient struct {
	cc *grpc.ClientConn
}

func NewRPCACLServiceClient(cc *grpc.ClientConn) RPCACLServiceClient {
	return &rPCACLServiceClient{cc}
}

func (c *rPCACLServiceClient) GetServiceByID(ctx context.Context, in *ServiceByIDRequest, opts ...grpc.CallOption) (*Service, error) {
	out := new(Service)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/GetServiceByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) GetServiceByUserID(ctx context.Context, in *ServiceByUserIDRequest, opts ...grpc.CallOption) (*Service, error) {
	out := new(Service)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/GetServiceByUserID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) GetServices(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*ServiceList, error) {
	out := new(ServiceList)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/GetServices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) GetMethods(ctx context.Context, in *GetMethodsRequest, opts ...grpc.CallOption) (*MethodList, error) {
	out := new(MethodList)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/GetMethods", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) GetUserGroups(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*auth.GroupList, error) {
	out := new(auth.GroupList)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/GetUserGroups", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) AddUserToGroup(ctx context.Context, in *auth.AddToGroupRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/AddUserToGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) RemoveUserFromGroup(ctx context.Context, in *auth.RemoveFromGroupRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/RemoveUserFromGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) ListUsersInGroup(ctx context.Context, in *auth.ListGroupRequest, opts ...grpc.CallOption) (*auth.UserListResponse, error) {
	out := new(auth.UserListResponse)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/ListUsersInGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) GetGroupsForMethod(ctx context.Context, in *Method, opts ...grpc.CallOption) (*auth.GroupList, error) {
	out := new(auth.GroupList)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/GetGroupsForMethod", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) AddGroupToMethod(ctx context.Context, in *MethodIDAndGroupID, opts ...grpc.CallOption) (*auth.GroupList, error) {
	out := new(auth.GroupList)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/AddGroupToMethod", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) RemoveGroupFromMethod(ctx context.Context, in *MethodIDAndGroupID, opts ...grpc.CallOption) (*auth.GroupList, error) {
	out := new(auth.GroupList)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/RemoveGroupFromMethod", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) GetMethodsForGroups(ctx context.Context, in *auth.Group, opts ...grpc.CallOption) (*FullMethodList, error) {
	out := new(FullMethodList)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/GetMethodsForGroups", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) GetMostRecentLogs(ctx context.Context, in *LogEntryRequest, opts ...grpc.CallOption) (*LogEntryList, error) {
	out := new(LogEntryList)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/GetMostRecentLogs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) GetMyMostRecentLogs(ctx context.Context, in *LogEntryRequest, opts ...grpc.CallOption) (*LogEntryList, error) {
	out := new(LogEntryList)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/GetMyMostRecentLogs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) SearchLogs(ctx context.Context, in *LogSearchRequest, opts ...grpc.CallOption) (*LogEntryList, error) {
	out := new(LogEntryList)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/SearchLogs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) ListCalls(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*CallList, error) {
	out := new(CallList)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/ListCalls", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) SearchErrors(ctx context.Context, in *ErrorSearchRequest, opts ...grpc.CallOption) (*ErrorEntryList, error) {
	out := new(ErrorEntryList)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/SearchErrors", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) ServiceNameToID(ctx context.Context, in *ServiceNameRequest, opts ...grpc.CallOption) (*ServiceIDResponse, error) {
	out := new(ServiceIDResponse)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/ServiceNameToID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) GetRulesForService(ctx context.Context, in *ServiceID, opts ...grpc.CallOption) (*ServiceRules, error) {
	out := new(ServiceRules)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/GetRulesForService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) GetRulesForServices(ctx context.Context, in *ServiceIDList, opts ...grpc.CallOption) (*ServiceRules, error) {
	out := new(ServiceRules)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/GetRulesForServices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCACLServiceClient) AuthoriseGroupService(ctx context.Context, in *GroupServiceRequest, opts ...grpc.CallOption) (*Service, error) {
	out := new(Service)
	err := grpc.Invoke(ctx, "/rpcaclapi.RPCACLService/AuthoriseGroupService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RPCACLService service

type RPCACLServiceServer interface {
	// given a serviceid for a service, this will return the rpcinterceptor service
	GetServiceByID(context.Context, *ServiceByIDRequest) (*Service, error)
	// given a userid for a service, this will return the rpcinterceptor service
	GetServiceByUserID(context.Context, *ServiceByUserIDRequest) (*Service, error)
	// get ALL services currently known
	// (known means: a method of this service has requested authentication at least once.)
	GetServices(context.Context, *common.Void) (*ServiceList, error)
	// get all methods currently known for a given service
	// (known means: the method has requested authentication at least once.)
	GetMethods(context.Context, *GetMethodsRequest) (*MethodList, error)
	// get all groups known to the auth service.
	// essentially queries & caches the auth service
	// OBSOLETE
	GetUserGroups(context.Context, *common.Void) (*auth.GroupList, error)
	// add user to group
	// OBSOLETE
	AddUserToGroup(context.Context, *auth.AddToGroupRequest) (*common.Void, error)
	// remove user from a group
	// OBSOLETE
	RemoveUserFromGroup(context.Context, *auth.RemoveFromGroupRequest) (*common.Void, error)
	// get all users for a group
	// OBSOLETE
	ListUsersInGroup(context.Context, *auth.ListGroupRequest) (*auth.UserListResponse, error)
	// get all groups associated (have access to) a given method
	// OBSOLETE
	GetGroupsForMethod(context.Context, *Method) (*auth.GroupList, error)
	// add a group to a Method (grant access to an rpc for a given group)
	// returns the list of groups for this method PRIOR to the update
	// OBSOLETE
	AddGroupToMethod(context.Context, *MethodIDAndGroupID) (*auth.GroupList, error)
	// remove a group from a method (revoke access to an rpc for a given group)
	// returns the list of groups for this method PRIOR to the update
	// OBSOLETE
	RemoveGroupFromMethod(context.Context, *MethodIDAndGroupID) (*auth.GroupList, error)
	// return list of methods a group as access to
	// OBSOLETE
	GetMethodsForGroups(context.Context, *auth.Group) (*FullMethodList, error)
	// gets the most recent logentries limited by some count
	// OBSOLETE
	GetMostRecentLogs(context.Context, *LogEntryRequest) (*LogEntryList, error)
	// gets the most recent logentries for the calling user
	// OBSOLETE
	GetMyMostRecentLogs(context.Context, *LogEntryRequest) (*LogEntryList, error)
	// sophisticated(ish) search for logs
	// OBSOLETE
	SearchLogs(context.Context, *LogSearchRequest) (*LogEntryList, error)
	// UNDOCUMENTED CALL, USE WITH CARE
	// OBSOLETE
	ListCalls(context.Context, *common.Void) (*CallList, error)
	// sophisticated(ish) search for errors which occured in the system
	// OBSOLETE
	SearchErrors(context.Context, *ErrorSearchRequest) (*ErrorEntryList, error)
	// ServiceNametoID (privileged)
	ServiceNameToID(context.Context, *ServiceNameRequest) (*ServiceIDResponse, error)
	// provide set of rules to decide wether or not to grant a request
	GetRulesForService(context.Context, *ServiceID) (*ServiceRules, error)
	// provide set of rules to decide wether or not to grant a request
	GetRulesForServices(context.Context, *ServiceIDList) (*ServiceRules, error)
	// authorize a particular group for a service
	AuthoriseGroupService(context.Context, *GroupServiceRequest) (*Service, error)
}

func RegisterRPCACLServiceServer(s *grpc.Server, srv RPCACLServiceServer) {
	s.RegisterService(&_RPCACLService_serviceDesc, srv)
}

func _RPCACLService_GetServiceByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).GetServiceByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/GetServiceByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).GetServiceByID(ctx, req.(*ServiceByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_GetServiceByUserID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceByUserIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).GetServiceByUserID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/GetServiceByUserID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).GetServiceByUserID(ctx, req.(*ServiceByUserIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_GetServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).GetServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/GetServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).GetServices(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_GetMethods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMethodsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).GetMethods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/GetMethods",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).GetMethods(ctx, req.(*GetMethodsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_GetUserGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).GetUserGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/GetUserGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).GetUserGroups(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_AddUserToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.AddToGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).AddUserToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/AddUserToGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).AddUserToGroup(ctx, req.(*auth.AddToGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_RemoveUserFromGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.RemoveFromGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).RemoveUserFromGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/RemoveUserFromGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).RemoveUserFromGroup(ctx, req.(*auth.RemoveFromGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_ListUsersInGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.ListGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).ListUsersInGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/ListUsersInGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).ListUsersInGroup(ctx, req.(*auth.ListGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_GetGroupsForMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Method)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).GetGroupsForMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/GetGroupsForMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).GetGroupsForMethod(ctx, req.(*Method))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_AddGroupToMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MethodIDAndGroupID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).AddGroupToMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/AddGroupToMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).AddGroupToMethod(ctx, req.(*MethodIDAndGroupID))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_RemoveGroupFromMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MethodIDAndGroupID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).RemoveGroupFromMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/RemoveGroupFromMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).RemoveGroupFromMethod(ctx, req.(*MethodIDAndGroupID))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_GetMethodsForGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(auth.Group)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).GetMethodsForGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/GetMethodsForGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).GetMethodsForGroups(ctx, req.(*auth.Group))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_GetMostRecentLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).GetMostRecentLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/GetMostRecentLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).GetMostRecentLogs(ctx, req.(*LogEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_GetMyMostRecentLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).GetMyMostRecentLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/GetMyMostRecentLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).GetMyMostRecentLogs(ctx, req.(*LogEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_SearchLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).SearchLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/SearchLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).SearchLogs(ctx, req.(*LogSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_ListCalls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).ListCalls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/ListCalls",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).ListCalls(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_SearchErrors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ErrorSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).SearchErrors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/SearchErrors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).SearchErrors(ctx, req.(*ErrorSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_ServiceNameToID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).ServiceNameToID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/ServiceNameToID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).ServiceNameToID(ctx, req.(*ServiceNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_GetRulesForService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).GetRulesForService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/GetRulesForService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).GetRulesForService(ctx, req.(*ServiceID))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_GetRulesForServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceIDList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).GetRulesForServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/GetRulesForServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).GetRulesForServices(ctx, req.(*ServiceIDList))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCACLService_AuthoriseGroupService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCACLServiceServer).AuthoriseGroupService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcaclapi.RPCACLService/AuthoriseGroupService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCACLServiceServer).AuthoriseGroupService(ctx, req.(*GroupServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCACLService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpcaclapi.RPCACLService",
	HandlerType: (*RPCACLServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetServiceByID",
			Handler:    _RPCACLService_GetServiceByID_Handler,
		},
		{
			MethodName: "GetServiceByUserID",
			Handler:    _RPCACLService_GetServiceByUserID_Handler,
		},
		{
			MethodName: "GetServices",
			Handler:    _RPCACLService_GetServices_Handler,
		},
		{
			MethodName: "GetMethods",
			Handler:    _RPCACLService_GetMethods_Handler,
		},
		{
			MethodName: "GetUserGroups",
			Handler:    _RPCACLService_GetUserGroups_Handler,
		},
		{
			MethodName: "AddUserToGroup",
			Handler:    _RPCACLService_AddUserToGroup_Handler,
		},
		{
			MethodName: "RemoveUserFromGroup",
			Handler:    _RPCACLService_RemoveUserFromGroup_Handler,
		},
		{
			MethodName: "ListUsersInGroup",
			Handler:    _RPCACLService_ListUsersInGroup_Handler,
		},
		{
			MethodName: "GetGroupsForMethod",
			Handler:    _RPCACLService_GetGroupsForMethod_Handler,
		},
		{
			MethodName: "AddGroupToMethod",
			Handler:    _RPCACLService_AddGroupToMethod_Handler,
		},
		{
			MethodName: "RemoveGroupFromMethod",
			Handler:    _RPCACLService_RemoveGroupFromMethod_Handler,
		},
		{
			MethodName: "GetMethodsForGroups",
			Handler:    _RPCACLService_GetMethodsForGroups_Handler,
		},
		{
			MethodName: "GetMostRecentLogs",
			Handler:    _RPCACLService_GetMostRecentLogs_Handler,
		},
		{
			MethodName: "GetMyMostRecentLogs",
			Handler:    _RPCACLService_GetMyMostRecentLogs_Handler,
		},
		{
			MethodName: "SearchLogs",
			Handler:    _RPCACLService_SearchLogs_Handler,
		},
		{
			MethodName: "ListCalls",
			Handler:    _RPCACLService_ListCalls_Handler,
		},
		{
			MethodName: "SearchErrors",
			Handler:    _RPCACLService_SearchErrors_Handler,
		},
		{
			MethodName: "ServiceNameToID",
			Handler:    _RPCACLService_ServiceNameToID_Handler,
		},
		{
			MethodName: "GetRulesForService",
			Handler:    _RPCACLService_GetRulesForService_Handler,
		},
		{
			MethodName: "GetRulesForServices",
			Handler:    _RPCACLService_GetRulesForServices_Handler,
		},
		{
			MethodName: "AuthoriseGroupService",
			Handler:    _RPCACLService_AuthoriseGroupService_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.conradwood.net/apis/rpcaclapi/rpcaclapi.proto",
}

func init() {
	proto.RegisterFile("golang.conradwood.net/apis/rpcaclapi/rpcaclapi.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1503 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xec, 0x58, 0xeb, 0x6e, 0x1b, 0x45,
	0x14, 0xc6, 0x97, 0xf8, 0x72, 0x7c, 0x89, 0x3b, 0xb9, 0xd4, 0xb8, 0x69, 0x09, 0x4b, 0xa8, 0x42,
	0x28, 0x0e, 0x4d, 0x91, 0xa0, 0x3f, 0x8a, 0xf0, 0x2d, 0xa9, 0x5b, 0x27, 0xad, 0x36, 0x69, 0x25,
	0xa4, 0x42, 0xb5, 0x78, 0x47, 0x8e, 0x25, 0x7b, 0xc7, 0xec, 0xae, 0x4b, 0xf3, 0x14, 0xfc, 0x45,
	0xfc, 0xe5, 0x11, 0x78, 0x04, 0x5e, 0x88, 0x47, 0x40, 0x73, 0x66, 0x66, 0x77, 0xf6, 0x92, 0x34,
	0x42, 0x08, 0xfe, 0xf0, 0x27, 0xd9, 0xf9, 0xe6, 0x3b, 0x67, 0xce, 0x9c, 0x73, 0x66, 0xce, 0x19,
	0xc3, 0x17, 0x13, 0x36, 0xb3, 0x9c, 0x49, 0x7b, 0xcc, 0x1c, 0xd7, 0xb2, 0x7f, 0x62, 0xcc, 0x6e,
	0x3b, 0xd4, 0xdf, 0xb7, 0x16, 0x53, 0x6f, 0xdf, 0x5d, 0x8c, 0xad, 0xf1, 0xcc, 0x5a, 0x4c, 0xc3,
	0xaf, 0xf6, 0xc2, 0x65, 0x3e, 0x23, 0xe5, 0x00, 0x68, 0xed, 0x5d, 0xa1, 0xc0, 0x5a, 0xfa, 0xe7,
	0xf8, 0x47, 0x88, 0xb5, 0xda, 0x57, 0x70, 0xc7, 0x6c, 0x3e, 0x67, 0x8e, 0xfc, 0x27, 0xf9, 0x5f,
	0x5f, 0x6d, 0xdc, 0xd4, 0xf1, 0xa9, 0x3b, 0xa6, 0x0b, 0x9f, 0xb9, 0xb1, 0xa1, 0x90, 0x37, 0x06,
	0x50, 0x3c, 0xa5, 0xee, 0x9b, 0xe9, 0x98, 0x92, 0x3a, 0x64, 0x87, 0xfd, 0x66, 0x66, 0x3b, 0xb3,
	0x9b, 0x37, 0xb3, 0xc3, 0x3e, 0x21, 0x90, 0x3f, 0xb1, 0xe6, 0xb4, 0x99, 0xdd, 0xce, 0xec, 0x96,
	0x4d, 0xfc, 0x26, 0x9b, 0x50, 0x78, 0xe1, 0x51, 0x77, 0xd8, 0x6f, 0xe6, 0x10, 0x95, 0x23, 0xe3,
	0x09, 0x14, 0x8e, 0xa9, 0x7f, 0xce, 0xec, 0x6b, 0x69, 0xd9, 0x82, 0xb2, 0x5c, 0x54, 0x2a, 0xca,
	0x9b, 0x21, 0x60, 0x3c, 0x82, 0x8a, 0x1c, 0x8c, 0xa6, 0x9e, 0x4f, 0xda, 0x50, 0x92, 0x43, 0xaf,
	0x99, 0xd9, 0xce, 0xed, 0x56, 0x0e, 0x48, 0x3b, 0x74, 0xb6, 0x9c, 0x32, 0x03, 0x8e, 0x71, 0x1f,
	0x6e, 0x1c, 0x51, 0x5f, 0x58, 0xe3, 0x99, 0xf4, 0xc7, 0x25, 0xf5, 0xfc, 0xe8, 0x8a, 0x99, 0xf8,
	0x8a, 0x0f, 0x01, 0x04, 0x1f, 0x17, 0xfc, 0x14, 0x8a, 0x52, 0x5a, 0xae, 0x77, 0x43, 0x5b, 0x4f,
	0xcc, 0x98, 0x8a, 0x61, 0x74, 0xa0, 0x7e, 0xb8, 0x9c, 0xcd, 0x34, 0xf1, 0xfd, 0xb8, 0xf8, 0x86,
	0x26, 0x1e, 0x72, 0x43, 0x15, 0xdf, 0x03, 0x84, 0xf0, 0xb5, 0xfc, 0x77, 0x2f, 0x08, 0x1a, 0x7a,
	0x2f, 0xdd, 0x23, 0x8a, 0x62, 0xdc, 0x87, 0xd5, 0x11, 0x9b, 0x0c, 0x1c, 0xdf, 0xbd, 0x50, 0xee,
	0xb8, 0x03, 0x70, 0x6c, 0xbd, 0xe5, 0xd0, 0x14, 0xbd, 0xca, 0x17, 0xd3, 0x10, 0xe3, 0x8f, 0x0c,
	0x94, 0x94, 0x0c, 0xf7, 0xdd, 0xd9, 0x74, 0x4e, 0x3d, 0xdf, 0x9a, 0x2f, 0x94, 0xef, 0x02, 0x40,
	0xb7, 0x25, 0xfb, 0x4e, 0x5b, 0xc8, 0x27, 0x2a, 0x4f, 0xa4, 0xe1, 0x29, 0xae, 0x55, 0x89, 0xf4,
	0x0d, 0x94, 0x4c, 0xea, 0x2d, 0x98, 0xe3, 0xd1, 0x66, 0x1e, 0xc9, 0x3b, 0xed, 0x58, 0x0a, 0x0f,
	0xd5, 0xb7, 0xf9, 0xbc, 0xa7, 0xb8, 0x66, 0x20, 0x65, 0x3c, 0x82, 0xaa, 0xda, 0x04, 0x46, 0xe6,
	0x33, 0x28, 0x86, 0x5b, 0xe6, 0x91, 0x59, 0xd3, 0x56, 0x0f, 0x5c, 0xa4, 0x38, 0xc6, 0x13, 0x20,
	0xc2, 0x94, 0x61, 0xbf, 0xe3, 0xd8, 0x47, 0x2e, 0x5b, 0x2e, 0x86, 0x7d, 0xd2, 0x82, 0x92, 0x42,
	0xa5, 0x33, 0x82, 0x31, 0x69, 0x42, 0x51, 0xd2, 0x64, 0xb8, 0xd4, 0xd0, 0xf8, 0x33, 0x0b, 0x8d,
	0x11, 0x9b, 0x9c, 0x52, 0xcb, 0x1d, 0x9f, 0xab, 0x28, 0x34, 0xa1, 0x28, 0x8e, 0x8f, 0xb0, 0xa7,
	0x6c, 0xaa, 0x21, 0x5f, 0x44, 0x4a, 0x7a, 0xcd, 0x2c, 0x4e, 0x05, 0x63, 0x62, 0x40, 0x95, 0xa7,
	0x8b, 0x54, 0xe2, 0xa1, 0x23, 0x4b, 0x66, 0x04, 0xc3, 0x74, 0xf7, 0x2d, 0xd7, 0xe7, 0x61, 0x42,
	0xe7, 0xd5, 0xcc, 0x10, 0xe0, 0xeb, 0x0e, 0x1c, 0x1b, 0xe7, 0x56, 0x70, 0x4e, 0x0d, 0xc9, 0x1e,
	0x34, 0x7a, 0xd6, 0x6c, 0x46, 0xdd, 0xe0, 0x6c, 0x78, 0xcd, 0xc2, 0x76, 0x6e, 0x37, 0x6f, 0x26,
	0xf0, 0x80, 0x6b, 0x6b, 0xdc, 0xa2, 0xc6, 0xd5, 0x70, 0xb2, 0x0b, 0xab, 0x42, 0x5e, 0xb9, 0xca,
	0x6b, 0x96, 0x90, 0x1a, 0x87, 0x03, 0xa6, 0x1d, 0x32, 0xcb, 0x1a, 0x33, 0x84, 0x79, 0x0e, 0xcb,
	0xfd, 0x72, 0x12, 0xa0, 0x97, 0x34, 0xc4, 0xf8, 0x35, 0x07, 0x64, 0xe0, 0xba, 0xcc, 0xfd, 0xdf,
	0xe9, 0xff, 0x9a, 0xd3, 0xc9, 0x5d, 0xa8, 0x0f, 0xde, 0x8e, 0x67, 0x4b, 0x9b, 0x2a, 0x27, 0x57,
	0x90, 0x13, 0x43, 0xf9, 0xb5, 0x89, 0xb1, 0x09, 0x0f, 0xe7, 0x7e, 0xfc, 0x70, 0xea, 0xd7, 0x66,
	0xc8, 0x0d, 0x8f, 0xe7, 0xef, 0x59, 0x80, 0x10, 0xff, 0xaf, 0x6e, 0xa9, 0x2d, 0x28, 0x07, 0xdb,
	0xc7, 0xa0, 0x97, 0xcd, 0x10, 0x20, 0x7b, 0x00, 0xc2, 0xd7, 0x7c, 0xdf, 0x18, 0xf7, 0xca, 0x01,
	0xb4, 0xb1, 0xdc, 0x73, 0xc4, 0xd4, 0x66, 0xb9, 0x26, 0xdc, 0x4e, 0x8f, 0xd9, 0xb4, 0x59, 0x10,
	0xe9, 0x13, 0x00, 0xdc, 0xb1, 0xfd, 0xa9, 0xb7, 0x98, 0x59, 0x17, 0xc7, 0xd4, 0xf3, 0xac, 0x09,
	0x6d, 0x16, 0x71, 0xb1, 0x18, 0xca, 0x03, 0x34, 0x62, 0x13, 0xc5, 0x29, 0x21, 0x47, 0x43, 0x8c,
	0xdf, 0x32, 0x90, 0xe7, 0x8b, 0x92, 0x87, 0x50, 0xd5, 0x83, 0x8b, 0x2e, 0xbb, 0xb4, 0x56, 0x45,
	0xa8, 0xe4, 0x00, 0xea, 0x7c, 0x3c, 0x75, 0x26, 0x51, 0x9f, 0xea, 0x3b, 0x8b, 0x31, 0xc8, 0x3d,
	0xa8, 0x48, 0x04, 0x5d, 0x91, 0x4b, 0x08, 0xe8, 0xd3, 0xc6, 0x7d, 0x28, 0xf1, 0x21, 0x26, 0xc6,
	0xc7, 0xb0, 0xc2, 0xbf, 0x55, 0x5a, 0xac, 0x6a, 0x16, 0x72, 0xdc, 0x14, 0xb3, 0xc6, 0x2e, 0x10,
	0xb9, 0x16, 0x2f, 0x91, 0xea, 0xb4, 0xab, 0xea, 0x99, 0x09, 0xab, 0xa7, 0xf1, 0x11, 0xdc, 0x08,
	0x4e, 0x89, 0xaa, 0x15, 0xf1, 0xb2, 0x6b, 0xbc, 0x82, 0x42, 0xbf, 0x6b, 0x2e, 0x67, 0xc9, 0xb6,
	0x28, 0xd2, 0x4a, 0x64, 0x63, 0xad, 0x04, 0xd9, 0x81, 0x9a, 0x49, 0xbd, 0xe5, 0xcc, 0x7f, 0xe6,
	0x1c, 0x5b, 0xfe, 0xf8, 0x5c, 0xde, 0x14, 0x51, 0xd0, 0x38, 0x85, 0x8a, 0xd0, 0x8e, 0xc3, 0xc4,
	0x12, 0x9b, 0x50, 0xe0, 0x93, 0x81, 0x7e, 0x39, 0xc2, 0x64, 0x53, 0x42, 0xa8, 0xb8, 0x66, 0x86,
	0x80, 0xf1, 0x1d, 0xd4, 0x84, 0xd2, 0xcb, 0x1a, 0xba, 0xcb, 0xd4, 0xee, 0x40, 0x4d, 0x8a, 0x44,
	0x7a, 0xbb, 0x28, 0x68, 0x3c, 0x53, 0x36, 0xe3, 0xa5, 0x78, 0x6d, 0xe5, 0x5a, 0x4d, 0xcc, 0x45,
	0x6b, 0xe2, 0x2f, 0x19, 0xc8, 0xa7, 0x7a, 0x78, 0x0f, 0x56, 0xc4, 0x16, 0xf9, 0x2d, 0x5c, 0x3f,
	0x58, 0xd7, 0x22, 0x1e, 0xec, 0xd6, 0x14, 0x14, 0x6e, 0xfb, 0xa1, 0xcb, 0xe6, 0x7a, 0x3b, 0xc9,
	0xef, 0x9b, 0x28, 0xa8, 0x1b, 0x91, 0x17, 0x97, 0xbe, 0x2a, 0xe7, 0xeb, 0xb0, 0x72, 0xe4, 0x5a,
	0x8e, 0x8f, 0x87, 0xb3, 0x64, 0x8a, 0x81, 0x71, 0x0a, 0x55, 0x75, 0x29, 0x2c, 0x67, 0xd4, 0xbb,
	0xba, 0x7d, 0xe4, 0x19, 0x8a, 0x34, 0xb4, 0x37, 0x9a, 0xa1, 0x1c, 0x37, 0xc5, 0xac, 0x71, 0x4b,
	0x53, 0x92, 0xc8, 0xb7, 0x0f, 0x82, 0x18, 0x0c, 0xfb, 0x98, 0xf6, 0x8a, 0x90, 0x93, 0x04, 0x06,
	0x6b, 0x68, 0xb3, 0xb2, 0x4b, 0x26, 0xf8, 0x76, 0xd0, 0x2c, 0x6b, 0x79, 0xae, 0x43, 0xef, 0xc8,
	0xd7, 0xcb, 0xc3, 0xf3, 0x39, 0x6c, 0x4a, 0x5a, 0xf7, 0x42, 0xa4, 0x80, 0x5a, 0x33, 0x7c, 0x04,
	0x64, 0x22, 0x8f, 0x80, 0x9d, 0xe0, 0x08, 0x76, 0x2f, 0x42, 0x76, 0xb8, 0xd3, 0x32, 0xdf, 0xc8,
	0xde, 0x2b, 0x2d, 0x89, 0x49, 0x05, 0x8a, 0xc3, 0x93, 0x97, 0x9d, 0xd1, 0xb0, 0xdf, 0x78, 0x8f,
	0x0f, 0x4e, 0x06, 0xc3, 0xb3, 0xc7, 0x03, 0xb3, 0x91, 0x21, 0x0d, 0xa8, 0x9e, 0x0e, 0xcc, 0x97,
	0xc3, 0xde, 0xe0, 0xf5, 0xb3, 0x93, 0xd1, 0xb7, 0x8d, 0x2c, 0xa9, 0x41, 0xf9, 0xc5, 0xe9, 0xc0,
	0x14, 0xc3, 0x1c, 0x59, 0x87, 0x86, 0x22, 0x74, 0x4e, 0xfa, 0xaf, 0xf9, 0x54, 0x23, 0x7f, 0xf0,
	0x73, 0x05, 0x6a, 0xe6, 0xf3, 0x5e, 0xa7, 0x37, 0x52, 0xa7, 0xa0, 0x07, 0xf5, 0x23, 0xea, 0x6b,
	0x86, 0x91, 0xdb, 0xc9, 0xbb, 0x5f, 0x33, 0xb8, 0x95, 0x52, 0x1a, 0xc8, 0x53, 0x20, 0xba, 0x12,
	0xb1, 0x61, 0xf2, 0x61, 0x9a, 0xa2, 0x88, 0xaf, 0x52, 0x95, 0x3d, 0x80, 0x4a, 0xa8, 0xcc, 0x23,
	0xd5, 0xb6, 0x7c, 0xd1, 0xbd, 0x64, 0x53, 0xbb, 0xb5, 0x99, 0x14, 0xc0, 0x7c, 0xe8, 0x00, 0x84,
	0xcf, 0x1a, 0xb2, 0xa5, 0xb1, 0x12, 0xaf, 0x9d, 0xd6, 0x46, 0xa2, 0x5e, 0xc9, 0x97, 0x54, 0xed,
	0x88, 0xfa, 0xdc, 0x3e, 0x8c, 0x71, 0x7c, 0xe5, 0x55, 0x71, 0x1b, 0xe3, 0x1c, 0xf2, 0xbf, 0x84,
	0x7a, 0xc7, 0xb6, 0x39, 0xff, 0x8c, 0x89, 0x43, 0x7f, 0x53, 0x50, 0x3a, 0xb6, 0x2d, 0x11, 0xb5,
	0x62, 0x44, 0x13, 0xe9, 0xc0, 0x9a, 0x49, 0xe7, 0xec, 0x0d, 0x5e, 0x1d, 0xfc, 0x24, 0x0a, 0xe9,
	0x2d, 0x21, 0x2d, 0xa6, 0x02, 0x38, 0x5d, 0x45, 0x17, 0x1a, 0xdc, 0x06, 0xae, 0xc0, 0x1b, 0x3a,
	0x42, 0x7e, 0x53, 0xc8, 0x73, 0x3c, 0x22, 0xb9, 0x19, 0x96, 0x11, 0x3e, 0x17, 0xdc, 0xe9, 0x5f,
	0x61, 0xd0, 0xc4, 0x5e, 0x0f, 0x99, 0xec, 0x77, 0x48, 0xb2, 0x98, 0x27, 0x77, 0xde, 0x85, 0x46,
	0xc7, 0x16, 0x2d, 0xff, 0x19, 0x93, 0x72, 0xb7, 0x13, 0x72, 0xfa, 0xbb, 0x20, 0xa9, 0xe3, 0x08,
	0x36, 0xc4, 0x4e, 0x11, 0xe2, 0xdb, 0xfd, 0x9b, 0x8a, 0x1e, 0xc1, 0x5a, 0x18, 0xe2, 0x43, 0xa6,
	0x82, 0x57, 0xd1, 0x78, 0xad, 0xf7, 0x53, 0xeb, 0x36, 0x8a, 0x3f, 0x16, 0xef, 0x61, 0xc6, 0x1d,
	0x33, 0xa6, 0x8e, 0x3f, 0x62, 0x13, 0x8f, 0xb4, 0xd2, 0x5e, 0x3e, 0xd2, 0x9d, 0x37, 0x53, 0xe6,
	0x50, 0xd3, 0x13, 0x61, 0xc8, 0xc5, 0x3f, 0xa1, 0xab, 0x0b, 0x20, 0xfa, 0x72, 0x54, 0x71, 0x2b,
	0x4a, 0x8b, 0x74, 0xec, 0x97, 0xeb, 0x68, 0x43, 0x99, 0xff, 0xc7, 0xfa, 0x1f, 0xcb, 0xe5, 0xb5,
	0x58, 0x97, 0x20, 0x3d, 0x51, 0x15, 0x9a, 0xb1, 0xad, 0xf2, 0x22, 0x81, 0x48, 0xbe, 0x14, 0x22,
	0x3e, 0x8d, 0x35, 0xab, 0x27, 0xb0, 0xaa, 0x5d, 0xb1, 0x67, 0x2c, 0xfd, 0x52, 0xd1, 0x1a, 0x91,
	0xd6, 0x56, 0x72, 0x5a, 0xeb, 0x3e, 0x7a, 0x98, 0xa9, 0x58, 0x26, 0x0e, 0x99, 0xea, 0xf7, 0xc9,
	0x7a, 0x9a, 0x4c, 0xc4, 0x1d, 0x91, 0x22, 0xf5, 0x18, 0xc3, 0x13, 0x53, 0xe2, 0x91, 0x66, 0x9a,
	0x16, 0xbe, 0x8b, 0xcb, 0x35, 0x3d, 0x85, 0x8d, 0xce, 0xd2, 0x3f, 0x67, 0xee, 0xd4, 0xa3, 0x7a,
	0xd1, 0x21, 0x77, 0xf4, 0x6b, 0x27, 0x59, 0x8d, 0xd2, 0x6e, 0xbb, 0xee, 0x5d, 0xd8, 0x71, 0xa8,
	0xaf, 0xff, 0x40, 0x25, 0x7f, 0xb2, 0xb2, 0x16, 0x53, 0x2f, 0xe4, 0xff, 0x50, 0xc0, 0x1f, 0xa4,
	0x1e, 0xfc, 0x15, 0x00, 0x00, 0xff, 0xff, 0xff, 0x87, 0x59, 0x1b, 0x6f, 0x13, 0x00, 0x00,
}
