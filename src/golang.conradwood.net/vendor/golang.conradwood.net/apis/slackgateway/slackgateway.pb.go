// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/slackgateway/slackgateway.proto
// DO NOT EDIT!

/*
Package slackgateway is a generated protocol buffer package.

It is generated from these files:
	golang.conradwood.net/apis/slackgateway/slackgateway.proto

It has these top-level messages:
	PublishMessageRequest
	EmptyRequest
	EmptyResponse
	User
	UsersResponse
	ChatRequest
	ChatResponse
	Attachment
	AttachmentAuthor
	AttachmentTitle
	AttachmentField
	AttachmentFooter
	PostRequest
	PostResponse
*/
package slackgateway

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import auth "golang.conradwood.net/apis/auth"
import h2gproxy "golang.conradwood.net/apis/h2gproxy"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type PublishMessageRequest struct {
	OriginService string `protobuf:"bytes,1,opt,name=OriginService" json:"OriginService,omitempty"`
	Channel       string `protobuf:"bytes,2,opt,name=Channel" json:"Channel,omitempty"`
	Text          string `protobuf:"bytes,3,opt,name=Text" json:"Text,omitempty"`
}

func (m *PublishMessageRequest) Reset()                    { *m = PublishMessageRequest{} }
func (m *PublishMessageRequest) String() string            { return proto.CompactTextString(m) }
func (*PublishMessageRequest) ProtoMessage()               {}
func (*PublishMessageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PublishMessageRequest) GetOriginService() string {
	if m != nil {
		return m.OriginService
	}
	return ""
}

func (m *PublishMessageRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *PublishMessageRequest) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type EmptyRequest struct {
}

func (m *EmptyRequest) Reset()                    { *m = EmptyRequest{} }
func (m *EmptyRequest) String() string            { return proto.CompactTextString(m) }
func (*EmptyRequest) ProtoMessage()               {}
func (*EmptyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type EmptyResponse struct {
}

func (m *EmptyResponse) Reset()                    { *m = EmptyResponse{} }
func (m *EmptyResponse) String() string            { return proto.CompactTextString(m) }
func (*EmptyResponse) ProtoMessage()               {}
func (*EmptyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type User struct {
	Username    string     `protobuf:"bytes,1,opt,name=Username" json:"Username,omitempty"`
	DisplayName string     `protobuf:"bytes,2,opt,name=DisplayName" json:"DisplayName,omitempty"`
	Realname    string     `protobuf:"bytes,3,opt,name=Realname" json:"Realname,omitempty"`
	Name        string     `protobuf:"bytes,4,opt,name=Name" json:"Name,omitempty"`
	User        *auth.User `protobuf:"bytes,5,opt,name=User" json:"User,omitempty"`
	Email       string     `protobuf:"bytes,6,opt,name=Email" json:"Email,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *User) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *User) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *User) GetRealname() string {
	if m != nil {
		return m.Realname
	}
	return ""
}

func (m *User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *User) GetUser() *auth.User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *User) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

type UsersResponse struct {
	Users []*User `protobuf:"bytes,1,rep,name=Users" json:"Users,omitempty"`
}

func (m *UsersResponse) Reset()                    { *m = UsersResponse{} }
func (m *UsersResponse) String() string            { return proto.CompactTextString(m) }
func (*UsersResponse) ProtoMessage()               {}
func (*UsersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UsersResponse) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type ChatRequest struct {
	// as per auth service
	UserID      []string      `protobuf:"bytes,1,rep,name=UserID" json:"UserID,omitempty"`
	Text        string        `protobuf:"bytes,2,opt,name=Text" json:"Text,omitempty"`
	Attachments []*Attachment `protobuf:"bytes,3,rep,name=Attachments" json:"Attachments,omitempty"`
}

func (m *ChatRequest) Reset()                    { *m = ChatRequest{} }
func (m *ChatRequest) String() string            { return proto.CompactTextString(m) }
func (*ChatRequest) ProtoMessage()               {}
func (*ChatRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ChatRequest) GetUserID() []string {
	if m != nil {
		return m.UserID
	}
	return nil
}

func (m *ChatRequest) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *ChatRequest) GetAttachments() []*Attachment {
	if m != nil {
		return m.Attachments
	}
	return nil
}

type ChatResponse struct {
	// whatever slack calls this... a multi-people-channel or so?
	// essentially it's a chatroom...
	ChatRoomID string `protobuf:"bytes,1,opt,name=ChatRoomID" json:"ChatRoomID,omitempty"`
}

func (m *ChatResponse) Reset()                    { *m = ChatResponse{} }
func (m *ChatResponse) String() string            { return proto.CompactTextString(m) }
func (*ChatResponse) ProtoMessage()               {}
func (*ChatResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ChatResponse) GetChatRoomID() string {
	if m != nil {
		return m.ChatRoomID
	}
	return ""
}

// Slack messages can have zero or more attachments.
type Attachment struct {
	// Fallback is the plain-text summary of the attachment, and is required.
	Fallback string `protobuf:"bytes,1,opt,name=Fallback" json:"Fallback,omitempty"`
	// Color is the hexadecimal RGB colour of the border typically displayed to the left of the message.
	Color string `protobuf:"bytes,2,opt,name=Color" json:"Color,omitempty"`
	// Pretext is optional text that appears above the attachment block.
	Pretext string `protobuf:"bytes,3,opt,name=Pretext" json:"Pretext,omitempty"`
	// Author defines authorship information for the attachment.
	Author *AttachmentAuthor `protobuf:"bytes,4,opt,name=Author" json:"Author,omitempty"`
	// Title defines the title of the attachment.
	Title *AttachmentTitle `protobuf:"bytes,5,opt,name=Title" json:"Title,omitempty"`
	// Text is optional text that appears within the attachment.
	Text string `protobuf:"bytes,6,opt,name=Text" json:"Text,omitempty"`
	// Fields is an array containing one or more fields to be displayed as key-value pairs
	// with the attachment.
	Fields []*AttachmentField `protobuf:"bytes,7,rep,name=Fields" json:"Fields,omitempty"`
	// ImageURL is the valid URL for an image file that will be displayed inside the message
	// attachment. This supports GIF, JPEG, PNG and BMP. Max width is 360px, max height is
	// 500px; larger images will be resized, maintaining aspect ratio.
	ImageURL string `protobuf:"bytes,8,opt,name=ImageURL" json:"ImageURL,omitempty"`
	// ThumbnailURL is the valid URL for an image file that will be displayed as a thumbnail on
	// the right hand side of the attachment. GIF, JPEG, PNG and BMP are supported. The file size
	// is limited to 500KB; max width and height are both 75px. Larger images will be resized,
	// maintaining aspect ratio.
	ThumbnailURL string `protobuf:"bytes,9,opt,name=ThumbnailURL" json:"ThumbnailURL,omitempty"`
	// Footer contains an optional footer message and icon.
	Footer *AttachmentFooter `protobuf:"bytes,10,opt,name=Footer" json:"Footer,omitempty"`
}

func (m *Attachment) Reset()                    { *m = Attachment{} }
func (m *Attachment) String() string            { return proto.CompactTextString(m) }
func (*Attachment) ProtoMessage()               {}
func (*Attachment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Attachment) GetFallback() string {
	if m != nil {
		return m.Fallback
	}
	return ""
}

func (m *Attachment) GetColor() string {
	if m != nil {
		return m.Color
	}
	return ""
}

func (m *Attachment) GetPretext() string {
	if m != nil {
		return m.Pretext
	}
	return ""
}

func (m *Attachment) GetAuthor() *AttachmentAuthor {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *Attachment) GetTitle() *AttachmentTitle {
	if m != nil {
		return m.Title
	}
	return nil
}

func (m *Attachment) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Attachment) GetFields() []*AttachmentField {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *Attachment) GetImageURL() string {
	if m != nil {
		return m.ImageURL
	}
	return ""
}

func (m *Attachment) GetThumbnailURL() string {
	if m != nil {
		return m.ThumbnailURL
	}
	return ""
}

func (m *Attachment) GetFooter() *AttachmentFooter {
	if m != nil {
		return m.Footer
	}
	return nil
}

// AttachmentAuthor represents authorship information for an attachment.
type AttachmentAuthor struct {
	// Name is the name of the author.
	Name string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	// Link is the URL to go to when the author's name is clicked. Only works if Name is
	// present.
	Link string `protobuf:"bytes,2,opt,name=Link" json:"Link,omitempty"`
	// Icon is the valid URL to a 16x16px image, which will be displayed to the left of the
	// author's name. Only works if Name is present.
	Icon string `protobuf:"bytes,3,opt,name=Icon" json:"Icon,omitempty"`
}

func (m *AttachmentAuthor) Reset()                    { *m = AttachmentAuthor{} }
func (m *AttachmentAuthor) String() string            { return proto.CompactTextString(m) }
func (*AttachmentAuthor) ProtoMessage()               {}
func (*AttachmentAuthor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *AttachmentAuthor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AttachmentAuthor) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *AttachmentAuthor) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

// AttachmentTitle represents the title of the attachment.
type AttachmentTitle struct {
	// Text will be displayed as larger, bold text near the top of a message attachment.
	Text string `protobuf:"bytes,1,opt,name=Text" json:"Text,omitempty"`
	// Link is a link to a valid URL to which the user should be taken if they click the
	// text. This is optional, and will only work if Text is provided.
	Link string `protobuf:"bytes,2,opt,name=Link" json:"Link,omitempty"`
}

func (m *AttachmentTitle) Reset()                    { *m = AttachmentTitle{} }
func (m *AttachmentTitle) String() string            { return proto.CompactTextString(m) }
func (*AttachmentTitle) ProtoMessage()               {}
func (*AttachmentTitle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *AttachmentTitle) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *AttachmentTitle) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

// AttachmentField represents a single field on an attachment.
type AttachmentField struct {
	// Title is shown as a bold heading above the value text. It cannot
	// contain markup.
	Title string `protobuf:"bytes,1,opt,name=Title" json:"Title,omitempty"`
	// Value is shown underneath the title; it may contain standard markup.
	// It may also be multi-line.
	Value string `protobuf:"bytes,2,opt,name=Value" json:"Value,omitempty"`
	// Short indicates whether the value is short enough to be displayed side-by-side
	// with other values.
	Short bool `protobuf:"varint,3,opt,name=Short" json:"Short,omitempty"`
}

func (m *AttachmentField) Reset()                    { *m = AttachmentField{} }
func (m *AttachmentField) String() string            { return proto.CompactTextString(m) }
func (*AttachmentField) ProtoMessage()               {}
func (*AttachmentField) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *AttachmentField) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *AttachmentField) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *AttachmentField) GetShort() bool {
	if m != nil {
		return m.Short
	}
	return false
}

// AttachmentFooter represents footer information for an attachment.
type AttachmentFooter struct {
	// Text is the text that should be displayed in the footer.
	Text string `protobuf:"bytes,1,opt,name=Text" json:"Text,omitempty"`
	// Icon is the valid URL to a 16x16px image that will be displayed to the left of the provided
	// text. Larger images will be rendered at 16x16 irrespective of size, so providing the correct
	// size image is recommended.
	Icon string `protobuf:"bytes,2,opt,name=Icon" json:"Icon,omitempty"`
	// Timestamp is a UNIX timestamp measured in epoch time displayed as part of the attachment's
	// footer.
	Timestamp int32 `protobuf:"varint,3,opt,name=Timestamp" json:"Timestamp,omitempty"`
}

func (m *AttachmentFooter) Reset()                    { *m = AttachmentFooter{} }
func (m *AttachmentFooter) String() string            { return proto.CompactTextString(m) }
func (*AttachmentFooter) ProtoMessage()               {}
func (*AttachmentFooter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *AttachmentFooter) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *AttachmentFooter) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *AttachmentFooter) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type PostRequest struct {
	UserID string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
	Text   string `protobuf:"bytes,2,opt,name=Text" json:"Text,omitempty"`
}

func (m *PostRequest) Reset()                    { *m = PostRequest{} }
func (m *PostRequest) String() string            { return proto.CompactTextString(m) }
func (*PostRequest) ProtoMessage()               {}
func (*PostRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *PostRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *PostRequest) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type PostResponse struct {
	SlackUserID string `protobuf:"bytes,1,opt,name=SlackUserID" json:"SlackUserID,omitempty"`
}

func (m *PostResponse) Reset()                    { *m = PostResponse{} }
func (m *PostResponse) String() string            { return proto.CompactTextString(m) }
func (*PostResponse) ProtoMessage()               {}
func (*PostResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *PostResponse) GetSlackUserID() string {
	if m != nil {
		return m.SlackUserID
	}
	return ""
}

func init() {
	proto.RegisterType((*PublishMessageRequest)(nil), "slackgateway.PublishMessageRequest")
	proto.RegisterType((*EmptyRequest)(nil), "slackgateway.EmptyRequest")
	proto.RegisterType((*EmptyResponse)(nil), "slackgateway.EmptyResponse")
	proto.RegisterType((*User)(nil), "slackgateway.User")
	proto.RegisterType((*UsersResponse)(nil), "slackgateway.UsersResponse")
	proto.RegisterType((*ChatRequest)(nil), "slackgateway.ChatRequest")
	proto.RegisterType((*ChatResponse)(nil), "slackgateway.ChatResponse")
	proto.RegisterType((*Attachment)(nil), "slackgateway.Attachment")
	proto.RegisterType((*AttachmentAuthor)(nil), "slackgateway.AttachmentAuthor")
	proto.RegisterType((*AttachmentTitle)(nil), "slackgateway.AttachmentTitle")
	proto.RegisterType((*AttachmentField)(nil), "slackgateway.AttachmentField")
	proto.RegisterType((*AttachmentFooter)(nil), "slackgateway.AttachmentFooter")
	proto.RegisterType((*PostRequest)(nil), "slackgateway.PostRequest")
	proto.RegisterType((*PostResponse)(nil), "slackgateway.PostResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SlackGateway service

type SlackGatewayClient interface {
	ListUsers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*UsersResponse, error)
	// DEPRECATED - old stuff
	PublishMessage(ctx context.Context, in *PublishMessageRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// DEPRECATED - old stuff - send to one or more users
	ChatToUsers(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error)
	// send to exactly one user
	Post(ctx context.Context, in *PostRequest, opts ...grpc.CallOption) (*PostResponse, error)
	// slack sends us events
	ServeHTML(ctx context.Context, in *h2gproxy.ServeRequest, opts ...grpc.CallOption) (*h2gproxy.ServeResponse, error)
}

type slackGatewayClient struct {
	cc *grpc.ClientConn
}

func NewSlackGatewayClient(cc *grpc.ClientConn) SlackGatewayClient {
	return &slackGatewayClient{cc}
}

func (c *slackGatewayClient) ListUsers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*UsersResponse, error) {
	out := new(UsersResponse)
	err := grpc.Invoke(ctx, "/slackgateway.SlackGateway/ListUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *slackGatewayClient) PublishMessage(ctx context.Context, in *PublishMessageRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/slackgateway.SlackGateway/PublishMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *slackGatewayClient) ChatToUsers(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (*ChatResponse, error) {
	out := new(ChatResponse)
	err := grpc.Invoke(ctx, "/slackgateway.SlackGateway/ChatToUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *slackGatewayClient) Post(ctx context.Context, in *PostRequest, opts ...grpc.CallOption) (*PostResponse, error) {
	out := new(PostResponse)
	err := grpc.Invoke(ctx, "/slackgateway.SlackGateway/Post", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *slackGatewayClient) ServeHTML(ctx context.Context, in *h2gproxy.ServeRequest, opts ...grpc.CallOption) (*h2gproxy.ServeResponse, error) {
	out := new(h2gproxy.ServeResponse)
	err := grpc.Invoke(ctx, "/slackgateway.SlackGateway/ServeHTML", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SlackGateway service

type SlackGatewayServer interface {
	ListUsers(context.Context, *EmptyRequest) (*UsersResponse, error)
	// DEPRECATED - old stuff
	PublishMessage(context.Context, *PublishMessageRequest) (*EmptyResponse, error)
	// DEPRECATED - old stuff - send to one or more users
	ChatToUsers(context.Context, *ChatRequest) (*ChatResponse, error)
	// send to exactly one user
	Post(context.Context, *PostRequest) (*PostResponse, error)
	// slack sends us events
	ServeHTML(context.Context, *h2gproxy.ServeRequest) (*h2gproxy.ServeResponse, error)
}

func RegisterSlackGatewayServer(s *grpc.Server, srv SlackGatewayServer) {
	s.RegisterService(&_SlackGateway_serviceDesc, srv)
}

func _SlackGateway_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SlackGatewayServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/slackgateway.SlackGateway/ListUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SlackGatewayServer).ListUsers(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SlackGateway_PublishMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SlackGatewayServer).PublishMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/slackgateway.SlackGateway/PublishMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SlackGatewayServer).PublishMessage(ctx, req.(*PublishMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SlackGateway_ChatToUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SlackGatewayServer).ChatToUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/slackgateway.SlackGateway/ChatToUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SlackGatewayServer).ChatToUsers(ctx, req.(*ChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SlackGateway_Post_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SlackGatewayServer).Post(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/slackgateway.SlackGateway/Post",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SlackGatewayServer).Post(ctx, req.(*PostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SlackGateway_ServeHTML_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(h2gproxy.ServeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SlackGatewayServer).ServeHTML(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/slackgateway.SlackGateway/ServeHTML",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SlackGatewayServer).ServeHTML(ctx, req.(*h2gproxy.ServeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SlackGateway_serviceDesc = grpc.ServiceDesc{
	ServiceName: "slackgateway.SlackGateway",
	HandlerType: (*SlackGatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListUsers",
			Handler:    _SlackGateway_ListUsers_Handler,
		},
		{
			MethodName: "PublishMessage",
			Handler:    _SlackGateway_PublishMessage_Handler,
		},
		{
			MethodName: "ChatToUsers",
			Handler:    _SlackGateway_ChatToUsers_Handler,
		},
		{
			MethodName: "Post",
			Handler:    _SlackGateway_Post_Handler,
		},
		{
			MethodName: "ServeHTML",
			Handler:    _SlackGateway_ServeHTML_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.conradwood.net/apis/slackgateway/slackgateway.proto",
}

func init() {
	proto.RegisterFile("golang.conradwood.net/apis/slackgateway/slackgateway.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 785 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x55, 0xdd, 0x4e, 0x1b, 0x3b,
	0x10, 0xd6, 0xe6, 0x0f, 0x32, 0x1b, 0xe0, 0xc8, 0xe2, 0x70, 0xf6, 0xe4, 0x9c, 0xa2, 0xc8, 0xad,
	0xd4, 0xb4, 0x17, 0xa1, 0x0a, 0x6a, 0x25, 0x50, 0x7b, 0x41, 0x09, 0xb4, 0x48, 0x81, 0xa2, 0x4d,
	0xa8, 0x7a, 0xeb, 0x04, 0x2b, 0xbb, 0xca, 0xee, 0x3a, 0x5d, 0x3b, 0x85, 0xbc, 0x41, 0x9f, 0xa5,
	0xaf, 0xd6, 0x97, 0xa8, 0x6c, 0xef, 0x8f, 0x37, 0x24, 0xb9, 0x49, 0x76, 0xc6, 0xdf, 0x37, 0x33,
	0xfe, 0xc6, 0x1e, 0xc3, 0xe9, 0x84, 0x05, 0x24, 0x9a, 0x74, 0xc6, 0x2c, 0x8a, 0xc9, 0xfd, 0x03,
	0x63, 0xf7, 0x9d, 0x88, 0x8a, 0x23, 0x32, 0xf3, 0xf9, 0x11, 0x0f, 0xc8, 0x78, 0x3a, 0x21, 0x82,
	0x3e, 0x90, 0x45, 0xc1, 0xe8, 0xcc, 0x62, 0x26, 0x18, 0x6a, 0x98, 0xbe, 0xe6, 0xeb, 0x0d, 0x91,
	0xc8, 0x5c, 0x78, 0xea, 0x47, 0x33, 0x9b, 0xdd, 0x0d, 0x58, 0xaf, 0x3b, 0x99, 0xc5, 0xec, 0x71,
	0x91, 0x7d, 0x68, 0x0e, 0x9e, 0xc2, 0xdf, 0xb7, 0xf3, 0x51, 0xe0, 0x73, 0xef, 0x9a, 0x72, 0x4e,
	0x26, 0xd4, 0xa5, 0xdf, 0xe7, 0x94, 0x0b, 0xf4, 0x02, 0x76, 0xbe, 0xc4, 0xfe, 0xc4, 0x8f, 0x06,
	0x34, 0xfe, 0xe1, 0x8f, 0xa9, 0x63, 0xb5, 0xac, 0x76, 0xdd, 0x2d, 0x3a, 0x91, 0x03, 0x5b, 0xe7,
	0x1e, 0x89, 0x22, 0x1a, 0x38, 0x25, 0xb5, 0x9e, 0x9a, 0x08, 0x41, 0x65, 0x48, 0x1f, 0x85, 0x53,
	0x56, 0x6e, 0xf5, 0x8d, 0x77, 0xa1, 0x71, 0x11, 0xce, 0xc4, 0x22, 0xc9, 0x81, 0xf7, 0x60, 0x27,
	0xb1, 0xf9, 0x8c, 0x45, 0x9c, 0xe2, 0x5f, 0x16, 0x54, 0xee, 0x38, 0x8d, 0x51, 0x13, 0xb6, 0xe5,
	0x7f, 0x44, 0xc2, 0x34, 0x71, 0x66, 0xa3, 0x16, 0xd8, 0x3d, 0x9f, 0xcf, 0x02, 0xb2, 0xb8, 0x91,
	0xcb, 0x3a, 0xaf, 0xe9, 0x92, 0x6c, 0x97, 0x92, 0x40, 0xb1, 0x75, 0xfe, 0xcc, 0x96, 0x75, 0x29,
	0x5a, 0x45, 0xd7, 0xa5, 0xf0, 0x87, 0x3a, 0xab, 0x53, 0x6d, 0x59, 0x6d, 0xbb, 0x0b, 0x1d, 0xa5,
	0xa9, 0xf4, 0xb8, 0xba, 0x9a, 0x7d, 0xa8, 0x5e, 0x84, 0xc4, 0x0f, 0x9c, 0x9a, 0x22, 0x69, 0x03,
	0x9f, 0xc0, 0x8e, 0x5c, 0xe5, 0x69, 0xf5, 0xa8, 0x0d, 0x55, 0xe5, 0x70, 0xac, 0x56, 0xb9, 0x6d,
	0x77, 0x51, 0xa7, 0xd0, 0x5d, 0x15, 0x4f, 0x03, 0xf0, 0x1c, 0xec, 0x73, 0x8f, 0x88, 0x54, 0xeb,
	0x03, 0xa8, 0x49, 0xff, 0x55, 0x4f, 0x31, 0xeb, 0x6e, 0x62, 0x65, 0x1a, 0x96, 0x72, 0x0d, 0xd1,
	0x29, 0xd8, 0x67, 0x42, 0x90, 0xb1, 0x17, 0xd2, 0x48, 0x70, 0xa7, 0xac, 0x52, 0x39, 0xc5, 0x54,
	0x39, 0xc0, 0x35, 0xc1, 0xb8, 0x03, 0x0d, 0x9d, 0x36, 0x29, 0xf8, 0x10, 0x40, 0xd9, 0x8c, 0x85,
	0x2a, 0xb7, 0xcc, 0x62, 0x78, 0xf0, 0xcf, 0x32, 0x40, 0xce, 0x97, 0xb2, 0x5e, 0x92, 0x20, 0x18,
	0x91, 0xf1, 0x34, 0x6d, 0x4a, 0x6a, 0x4b, 0x89, 0xce, 0x59, 0xc0, 0xe2, 0xa4, 0x56, 0x6d, 0xc8,
	0xe3, 0x71, 0x1b, 0x53, 0x91, 0x9f, 0x83, 0xd4, 0x44, 0xef, 0xa0, 0x76, 0x36, 0x17, 0x1e, 0x8b,
	0x55, 0x23, 0xec, 0xee, 0xe1, 0xba, 0x1d, 0x68, 0x94, 0x9b, 0xa0, 0xd1, 0x31, 0x54, 0x87, 0xbe,
	0x08, 0x68, 0xd2, 0xab, 0x67, 0xeb, 0x68, 0x0a, 0xe4, 0x6a, 0x6c, 0xa6, 0x63, 0xcd, 0xd0, 0xf1,
	0x2d, 0xd4, 0x2e, 0x7d, 0x1a, 0xdc, 0x73, 0x67, 0x4b, 0x49, 0xb8, 0x36, 0x92, 0x42, 0xb9, 0x09,
	0x58, 0x6a, 0x70, 0x15, 0x92, 0x09, 0xbd, 0x73, 0xfb, 0xce, 0xb6, 0xd6, 0x20, 0xb5, 0x11, 0x86,
	0xc6, 0xd0, 0x9b, 0x87, 0xa3, 0x88, 0xf8, 0x81, 0x5c, 0xaf, 0xab, 0xf5, 0x82, 0x4f, 0xee, 0xfb,
	0x92, 0x31, 0x41, 0x63, 0x07, 0x36, 0xef, 0x5b, 0xa3, 0xdc, 0x04, 0x8d, 0x6f, 0xe0, 0xaf, 0x65,
	0x4d, 0xb2, 0xa3, 0x6c, 0x19, 0x47, 0x19, 0x41, 0xa5, 0xef, 0x47, 0xd3, 0xf4, 0xc8, 0xc8, 0x6f,
	0xe9, 0xbb, 0x1a, 0xb3, 0x28, 0xbd, 0x8a, 0xf2, 0x1b, 0x9f, 0xc0, 0xde, 0x92, 0x58, 0x99, 0x4a,
	0x96, 0xa1, 0xd2, 0x8a, 0x70, 0x78, 0x60, 0x52, 0x95, 0x2c, 0xb2, 0xfb, 0xba, 0x2b, 0x9a, 0x9b,
	0xc8, 0xbe, 0x0f, 0xd5, 0xaf, 0x24, 0x98, 0xa7, 0x57, 0x54, 0x1b, 0xd2, 0x3b, 0xf0, 0x58, 0xac,
	0x4f, 0xc4, 0xb6, 0xab, 0x0d, 0xfc, 0xcd, 0xdc, 0x9f, 0xde, 0xf3, 0xba, 0x82, 0xd4, 0x5e, 0x4a,
	0xf9, 0x5e, 0xd0, 0xff, 0x50, 0x1f, 0xfa, 0x21, 0xe5, 0x82, 0x84, 0x33, 0x15, 0xb5, 0xea, 0xe6,
	0x0e, 0x7c, 0x02, 0xf6, 0x2d, 0xe3, 0x2b, 0xef, 0x9a, 0xb5, 0xf9, 0xae, 0xe1, 0x37, 0xd0, 0xd0,
	0xd4, 0xe4, 0xbe, 0xb4, 0xc0, 0x1e, 0xc8, 0x6e, 0x15, 0x02, 0x98, 0xae, 0xee, 0xef, 0x12, 0x34,
	0x94, 0xfd, 0x49, 0x37, 0x14, 0xf5, 0xa0, 0xde, 0xf7, 0xb9, 0x50, 0xd7, 0x1e, 0x35, 0x8b, 0xcd,
	0x36, 0x67, 0x61, 0xf3, 0xbf, 0xa7, 0xd3, 0x22, 0x9f, 0x2c, 0x2e, 0xec, 0x16, 0xa7, 0x34, 0x7a,
	0x5e, 0x84, 0xaf, 0x9c, 0xe1, 0xcb, 0x31, 0x0b, 0xb3, 0x16, 0xf5, 0xf4, 0x0c, 0x1a, 0x32, 0x5d,
	0xdb, 0xbf, 0x45, 0xac, 0x31, 0x9e, 0x9a, 0xcd, 0x55, 0x4b, 0x49, 0x94, 0x0f, 0x50, 0x91, 0x12,
	0x2d, 0xd3, 0x0d, 0xc5, 0x97, 0xe9, 0x05, 0x45, 0xdf, 0x43, 0x5d, 0x3e, 0x25, 0xf4, 0xf3, 0xf0,
	0xba, 0x8f, 0x0e, 0x3a, 0xd9, 0xe3, 0xa4, 0x9c, 0x69, 0x80, 0x7f, 0x9e, 0xf8, 0x35, 0xfb, 0xe3,
	0x2b, 0x78, 0x19, 0x51, 0x61, 0xbe, 0x77, 0xc9, 0x0b, 0x28, 0x9f, 0xbc, 0x42, 0xd6, 0x51, 0x4d,
	0x3d, 0x77, 0xc7, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x5e, 0x6c, 0x50, 0x16, 0x9a, 0x07, 0x00,
	0x00,
}
